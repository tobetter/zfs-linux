Index: zfs-linux-0.6.5.6/config/kernel-vfs-rw-iterate.m4
===================================================================
--- zfs-linux-0.6.5.6.orig/config/kernel-vfs-rw-iterate.m4
+++ zfs-linux-0.6.5.6/config/kernel-vfs-rw-iterate.m4
@@ -25,3 +25,24 @@ AC_DEFUN([ZFS_AC_KERNEL_VFS_RW_ITERATE],
 		AC_MSG_RESULT(no)
 	])
 ])
+
+dnl #
+dnl # Linux 4.1.x API
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_GENERIC_WRITE_CHECKS],
+	[AC_MSG_CHECKING([whether generic_write_checks() takes kiocb])
+	ZFS_LINUX_TRY_COMPILE([
+		#include <linux/fs.h>
+
+	],[
+		struct kiocb *iocb = NULL;
+		struct iov_iter *iov = NULL;
+		generic_write_checks(iocb, iov);
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_GENERIC_WRITE_CHECKS_KIOCB, 1,
+			[generic_write_checks() takes kiocb])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
Index: zfs-linux-0.6.5.6/config/kernel.m4
===================================================================
--- zfs-linux-0.6.5.6.orig/config/kernel.m4
+++ zfs-linux-0.6.5.6/config/kernel.m4
@@ -89,6 +89,7 @@ AC_DEFUN([ZFS_AC_CONFIG_KERNEL], [
 	ZFS_AC_KERNEL_LSEEK_EXECUTE
 	ZFS_AC_KERNEL_VFS_ITERATE
 	ZFS_AC_KERNEL_VFS_RW_ITERATE
+	ZFS_AC_KERNEL_GENERIC_WRITE_CHECKS
 	ZFS_AC_KERNEL_KMAP_ATOMIC_ARGS
 	ZFS_AC_KERNEL_FOLLOW_DOWN_ONE
 	ZFS_AC_KERNEL_MAKE_REQUEST_FN
Index: zfs-linux-0.6.5.6/module/zfs/zpl_file.c
===================================================================
--- zfs-linux-0.6.5.6.orig/module/zfs/zpl_file.c
+++ zfs-linux-0.6.5.6/module/zfs/zpl_file.c
@@ -251,20 +251,6 @@ zpl_read_common(struct inode *ip, const
 }
 
 static ssize_t
-zpl_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)
-{
-	cred_t *cr = CRED();
-	ssize_t read;
-
-	crhold(cr);
-	read = zpl_read_common(filp->f_mapping->host, buf, len, ppos,
-	    UIO_USERSPACE, filp->f_flags, cr);
-	crfree(cr);
-
-	return (read);
-}
-
-static ssize_t
 zpl_iter_read_common(struct kiocb *kiocb, const struct iovec *iovp,
     unsigned long nr_segs, size_t count, uio_seg_t seg, size_t skip)
 {
@@ -301,7 +287,7 @@ static ssize_t
 zpl_aio_read(struct kiocb *kiocb, const struct iovec *iovp,
     unsigned long nr_segs, loff_t pos)
 {
-	return (zpl_iter_read_common(kiocb, iovp, nr_segs, kiocb->ki_nbytes,
+	return (zpl_iter_read_common(kiocb, iovp, nr_segs, count,
 	    UIO_USERSPACE, 0));
 }
 #endif /* HAVE_VFS_RW_ITERATE */
@@ -353,20 +339,6 @@ zpl_write_common(struct inode *ip, const
 }
 
 static ssize_t
-zpl_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)
-{
-	cred_t *cr = CRED();
-	ssize_t wrote;
-
-	crhold(cr);
-	wrote = zpl_write_common(filp->f_mapping->host, buf, len, ppos,
-	    UIO_USERSPACE, filp->f_flags, cr);
-	crfree(cr);
-
-	return (wrote);
-}
-
-static ssize_t
 zpl_iter_write_common(struct kiocb *kiocb, const struct iovec *iovp,
     unsigned long nr_segs, size_t count, uio_seg_t seg, size_t skip)
 {
@@ -386,16 +358,40 @@ zpl_iter_write_common(struct kiocb *kioc
 static ssize_t
 zpl_iter_write(struct kiocb *kiocb, struct iov_iter *from)
 {
+	size_t count;
 	ssize_t ret;
 	uio_seg_t seg = UIO_USERSPACE;
+
+#ifndef HAVE_GENERIC_WRITE_CHECKS_KIOCB
+	struct file *file = kiocb->ki_filp;
+	struct address_space *mapping = file->f_mapping;
+	struct inode *ip = mapping->host;
+	int isblk = S_ISBLK(ip->i_mode);
+
+	count = iov_iter_count(from);
+	ret = generic_write_checks(file, &kiocb->ki_pos, &count, isblk);
+#else
+	/*
+	 * XXX - ideally this check should be in the same lock region with
+	 * write operations, so that there's no TOCTTOU race when doing
+	 * append and someone else grow the file.
+	 */
+	ret = generic_write_checks(kiocb, from);
+	count = ret;
+#endif
+	if (ret <= 0)
+		return (ret);
+
 	if (from->type & ITER_KVEC)
 		seg = UIO_SYSSPACE;
 	if (from->type & ITER_BVEC)
 		seg = UIO_BVEC;
+
 	ret = zpl_iter_write_common(kiocb, from->iov, from->nr_segs,
-	    iov_iter_count(from), seg, from->iov_offset);
+		count, seg, from->iov_offset);
 	if (ret > 0)
 		iov_iter_advance(from, ret);
+
 	return (ret);
 }
 #else
@@ -403,7 +399,22 @@ static ssize_t
 zpl_aio_write(struct kiocb *kiocb, const struct iovec *iovp,
     unsigned long nr_segs, loff_t pos)
 {
-	return (zpl_iter_write_common(kiocb, iovp, nr_segs, kiocb->ki_nbytes,
+	struct file *file = kiocb->ki_filp;
+	struct address_space *mapping = file->f_mapping;
+	struct inode *ip = mapping->host;
+	int isblk = S_ISBLK(ip->i_mode);
+	size_t count;
+	ssize_t ret;
+
+	ret = generic_segment_checks(iovp, &nr_segs, &count, VERIFY_READ);
+	if (ret)
+		return (ret);
+
+	ret = generic_write_checks(file, &pos, &count, isblk);
+	if (ret)
+		return (ret);
+
+	return (zpl_iter_write_common(kiocb, iovp, nr_segs, count,
 	    UIO_USERSPACE, 0));
 }
 #endif /* HAVE_VFS_RW_ITERATE */
@@ -827,8 +838,6 @@ const struct file_operations zpl_file_op
 	.open		= zpl_open,
 	.release	= zpl_release,
 	.llseek		= zpl_llseek,
-	.read		= zpl_read,
-	.write		= zpl_write,
 #ifdef HAVE_VFS_RW_ITERATE
 	.read_iter	= zpl_iter_read,
 	.write_iter	= zpl_iter_write,
