From 006e9a40882468be68f276c946bae812b74ac35c Mon Sep 17 00:00:00 2001
From: Matthew Macy <mmacy@mattmacy.io>
Date: Thu, 5 Sep 2019 09:34:54 -0700
Subject: [PATCH] OpenZFS restructuring - move platform specific headers

Move platform specific Linux headers under include/os/linux/.
Update the build system accordingly to detect the platform.
This lays some of the initial groundwork to supporting building
for other platforms.

As part of this change it was necessary to create both a user
and kernel space sys/simd.h header which can be included in
either context.  No functional change, the source has been
refactored and the relevant #include's updated.

Reviewed-by: Jorgen Lundman <lundman@lundman.net>
Reviewed-by: Igor Kozhukhov <igor@dilos.org>
Signed-off-by: Matthew Macy <mmacy@FreeBSD.org>
Signed-off-by: Brian Behlendorf <behlendorf1@llnl.gov>
Closes #9198
---

Index: zfs-linux-0.8.2/include/linux/simd.h
===================================================================
--- zfs-linux-0.8.2.orig/include/linux/simd.h
+++ zfs-linux-0.8.2/include/linux/simd.h
@@ -32,7 +32,7 @@
 #include <linux/simd_aarch64.h>
 #else
 
-#define	kfpu_allowed()		1
+#define	kfpu_allowed()		0
 #define	kfpu_initialize(tsk)	do {} while (0)
 #define	kfpu_begin()		do {} while (0)
 #define	kfpu_end()		do {} while (0)
Index: zfs-linux-0.8.2/include/linux/simd_aarch64.h
===================================================================
--- zfs-linux-0.8.2.orig/include/linux/simd_aarch64.h
+++ zfs-linux-0.8.2/include/linux/simd_aarch64.h
@@ -41,21 +41,11 @@
 
 #include <sys/types.h>
 
-#if defined(_KERNEL)
 #include <asm/neon.h>
 #define	kfpu_allowed()		1
 #define	kfpu_initialize(tsk)	do {} while (0)
 #define	kfpu_begin()		kernel_neon_begin()
 #define	kfpu_end()		kernel_neon_end()
-#else
-/*
- * fpu dummy methods for userspace
- */
-#define	kfpu_allowed()		1
-#define	kfpu_initialize(tsk)	do {} while (0)
-#define	kfpu_begin()		do {} while (0)
-#define	kfpu_end()		do {} while (0)
-#endif /* defined(_KERNEL) */
 
 #endif /* __aarch64__ */
 
Index: zfs-linux-0.8.2/include/linux/simd_x86.h
===================================================================
--- zfs-linux-0.8.2.orig/include/linux/simd_x86.h
+++ zfs-linux-0.8.2/include/linux/simd_x86.h
@@ -69,20 +69,11 @@
 #ifndef _SIMD_X86_H
 #define	_SIMD_X86_H
 
-#include <sys/isa_defs.h>
-
 /* only for __x86 */
 #if defined(__x86)
 
 #include <sys/types.h>
-
-#if defined(_KERNEL)
 #include <asm/cpufeature.h>
-#else
-#include <cpuid.h>
-#endif
-
-#if defined(_KERNEL)
 
 /*
  * Disable the WARN_ON_FPU() macro to prevent additional dependencies
@@ -222,185 +213,9 @@ kfpu_end(void)
 }
 #endif /* defined(HAVE_KERNEL_FPU) */
 
-#else /* defined(_KERNEL) */
 /*
- * FPU dummy methods for user space.
+ * Linux kernel provides an interface for CPU feature testing.
  */
-#define	kfpu_allowed()		1
-#define	kfpu_initialize(tsk)	do {} while (0)
-#define	kfpu_begin()		do {} while (0)
-#define	kfpu_end()		do {} while (0)
-#endif /* defined(_KERNEL) */
-
-/*
- * CPUID feature tests for user-space. Linux kernel provides an interface for
- * CPU feature testing.
- */
-#if !defined(_KERNEL)
-
-/*
- * x86 registers used implicitly by CPUID
- */
-typedef enum cpuid_regs {
-	EAX = 0,
-	EBX,
-	ECX,
-	EDX,
-	CPUID_REG_CNT = 4
-} cpuid_regs_t;
-
-/*
- * List of instruction sets identified by CPUID
- */
-typedef enum cpuid_inst_sets {
-	SSE = 0,
-	SSE2,
-	SSE3,
-	SSSE3,
-	SSE4_1,
-	SSE4_2,
-	OSXSAVE,
-	AVX,
-	AVX2,
-	BMI1,
-	BMI2,
-	AVX512F,
-	AVX512CD,
-	AVX512DQ,
-	AVX512BW,
-	AVX512IFMA,
-	AVX512VBMI,
-	AVX512PF,
-	AVX512ER,
-	AVX512VL,
-	AES,
-	PCLMULQDQ
-} cpuid_inst_sets_t;
-
-/*
- * Instruction set descriptor.
- */
-typedef struct cpuid_feature_desc {
-	uint32_t leaf;		/* CPUID leaf */
-	uint32_t subleaf;	/* CPUID sub-leaf */
-	uint32_t flag;		/* bit mask of the feature */
-	cpuid_regs_t reg;	/* which CPUID return register to test */
-} cpuid_feature_desc_t;
-
-#define	_AVX512F_BIT		(1U << 16)
-#define	_AVX512CD_BIT		(_AVX512F_BIT | (1U << 28))
-#define	_AVX512DQ_BIT		(_AVX512F_BIT | (1U << 17))
-#define	_AVX512BW_BIT		(_AVX512F_BIT | (1U << 30))
-#define	_AVX512IFMA_BIT		(_AVX512F_BIT | (1U << 21))
-#define	_AVX512VBMI_BIT		(1U << 1) /* AVX512F_BIT is on another leaf  */
-#define	_AVX512PF_BIT		(_AVX512F_BIT | (1U << 26))
-#define	_AVX512ER_BIT		(_AVX512F_BIT | (1U << 27))
-#define	_AVX512VL_BIT		(1U << 31) /* if used also check other levels */
-#define	_AES_BIT		(1U << 25)
-#define	_PCLMULQDQ_BIT		(1U << 1)
-
-/*
- * Descriptions of supported instruction sets
- */
-static const cpuid_feature_desc_t cpuid_features[] = {
-	[SSE]		= {1U, 0U,	1U << 25,	EDX	},
-	[SSE2]		= {1U, 0U,	1U << 26,	EDX	},
-	[SSE3]		= {1U, 0U,	1U << 0,	ECX	},
-	[SSSE3]		= {1U, 0U,	1U << 9,	ECX	},
-	[SSE4_1]	= {1U, 0U,	1U << 19,	ECX	},
-	[SSE4_2]	= {1U, 0U,	1U << 20,	ECX	},
-	[OSXSAVE]	= {1U, 0U,	1U << 27,	ECX	},
-	[AVX]		= {1U, 0U,	1U << 28,	ECX	},
-	[AVX2]		= {7U, 0U,	1U << 5,	EBX	},
-	[BMI1]		= {7U, 0U,	1U << 3,	EBX	},
-	[BMI2]		= {7U, 0U,	1U << 8,	EBX	},
-	[AVX512F]	= {7U, 0U, _AVX512F_BIT,	EBX	},
-	[AVX512CD]	= {7U, 0U, _AVX512CD_BIT,	EBX	},
-	[AVX512DQ]	= {7U, 0U, _AVX512DQ_BIT,	EBX	},
-	[AVX512BW]	= {7U, 0U, _AVX512BW_BIT,	EBX	},
-	[AVX512IFMA]	= {7U, 0U, _AVX512IFMA_BIT,	EBX	},
-	[AVX512VBMI]	= {7U, 0U, _AVX512VBMI_BIT,	ECX	},
-	[AVX512PF]	= {7U, 0U, _AVX512PF_BIT,	EBX	},
-	[AVX512ER]	= {7U, 0U, _AVX512ER_BIT,	EBX	},
-	[AVX512VL]	= {7U, 0U, _AVX512ER_BIT,	EBX	},
-	[AES]		= {1U, 0U, _AES_BIT,		ECX	},
-	[PCLMULQDQ]	= {1U, 0U, _PCLMULQDQ_BIT,	ECX	},
-};
-
-/*
- * Check if OS supports AVX and AVX2 by checking XCR0
- * Only call this function if CPUID indicates that AVX feature is
- * supported by the CPU, otherwise it might be an illegal instruction.
- */
-static inline uint64_t
-xgetbv(uint32_t index)
-{
-	uint32_t eax, edx;
-	/* xgetbv - instruction byte code */
-	__asm__ __volatile__(".byte 0x0f; .byte 0x01; .byte 0xd0"
-	    : "=a" (eax), "=d" (edx)
-	    : "c" (index));
-
-	return ((((uint64_t)edx)<<32) | (uint64_t)eax);
-}
-
-/*
- * Check if CPU supports a feature
- */
-static inline boolean_t
-__cpuid_check_feature(const cpuid_feature_desc_t *desc)
-{
-	uint32_t r[CPUID_REG_CNT];
-
-	if (__get_cpuid_max(0, NULL) >= desc->leaf) {
-		/*
-		 * __cpuid_count is needed to properly check
-		 * for AVX2. It is a macro, so return parameters
-		 * are passed by value.
-		 */
-		__cpuid_count(desc->leaf, desc->subleaf,
-		    r[EAX], r[EBX], r[ECX], r[EDX]);
-		return ((r[desc->reg] & desc->flag) == desc->flag);
-	}
-	return (B_FALSE);
-}
-
-#define	CPUID_FEATURE_CHECK(name, id)				\
-static inline boolean_t						\
-__cpuid_has_ ## name(void)					\
-{								\
-	return (__cpuid_check_feature(&cpuid_features[id]));	\
-}
-
-/*
- * Define functions for user-space CPUID features testing
- */
-CPUID_FEATURE_CHECK(sse, SSE);
-CPUID_FEATURE_CHECK(sse2, SSE2);
-CPUID_FEATURE_CHECK(sse3, SSE3);
-CPUID_FEATURE_CHECK(ssse3, SSSE3);
-CPUID_FEATURE_CHECK(sse4_1, SSE4_1);
-CPUID_FEATURE_CHECK(sse4_2, SSE4_2);
-CPUID_FEATURE_CHECK(avx, AVX);
-CPUID_FEATURE_CHECK(avx2, AVX2);
-CPUID_FEATURE_CHECK(osxsave, OSXSAVE);
-CPUID_FEATURE_CHECK(bmi1, BMI1);
-CPUID_FEATURE_CHECK(bmi2, BMI2);
-CPUID_FEATURE_CHECK(avx512f, AVX512F);
-CPUID_FEATURE_CHECK(avx512cd, AVX512CD);
-CPUID_FEATURE_CHECK(avx512dq, AVX512DQ);
-CPUID_FEATURE_CHECK(avx512bw, AVX512BW);
-CPUID_FEATURE_CHECK(avx512ifma, AVX512IFMA);
-CPUID_FEATURE_CHECK(avx512vbmi, AVX512VBMI);
-CPUID_FEATURE_CHECK(avx512pf, AVX512PF);
-CPUID_FEATURE_CHECK(avx512er, AVX512ER);
-CPUID_FEATURE_CHECK(avx512vl, AVX512VL);
-CPUID_FEATURE_CHECK(aes, AES);
-CPUID_FEATURE_CHECK(pclmulqdq, PCLMULQDQ);
-
-#endif /* !defined(_KERNEL) */
-
-
 /*
  * Detect register set support
  */
@@ -410,16 +225,11 @@ __simd_state_enabled(const uint64_t stat
 	boolean_t has_osxsave;
 	uint64_t xcr0;
 
-#if defined(_KERNEL)
 #if defined(X86_FEATURE_OSXSAVE)
 	has_osxsave = !!boot_cpu_has(X86_FEATURE_OSXSAVE);
 #else
 	has_osxsave = B_FALSE;
 #endif
-#elif !defined(_KERNEL)
-	has_osxsave = __cpuid_has_osxsave();
-#endif
-
 	if (!has_osxsave)
 		return (B_FALSE);
 
@@ -440,11 +250,7 @@ __simd_state_enabled(const uint64_t stat
 static inline boolean_t
 zfs_sse_available(void)
 {
-#if defined(_KERNEL)
 	return (!!boot_cpu_has(X86_FEATURE_XMM));
-#elif !defined(_KERNEL)
-	return (__cpuid_has_sse());
-#endif
 }
 
 /*
@@ -453,11 +259,7 @@ zfs_sse_available(void)
 static inline boolean_t
 zfs_sse2_available(void)
 {
-#if defined(_KERNEL)
 	return (!!boot_cpu_has(X86_FEATURE_XMM2));
-#elif !defined(_KERNEL)
-	return (__cpuid_has_sse2());
-#endif
 }
 
 /*
@@ -466,11 +268,7 @@ zfs_sse2_available(void)
 static inline boolean_t
 zfs_sse3_available(void)
 {
-#if defined(_KERNEL)
 	return (!!boot_cpu_has(X86_FEATURE_XMM3));
-#elif !defined(_KERNEL)
-	return (__cpuid_has_sse3());
-#endif
 }
 
 /*
@@ -479,11 +277,7 @@ zfs_sse3_available(void)
 static inline boolean_t
 zfs_ssse3_available(void)
 {
-#if defined(_KERNEL)
 	return (!!boot_cpu_has(X86_FEATURE_SSSE3));
-#elif !defined(_KERNEL)
-	return (__cpuid_has_ssse3());
-#endif
 }
 
 /*
@@ -492,11 +286,7 @@ zfs_ssse3_available(void)
 static inline boolean_t
 zfs_sse4_1_available(void)
 {
-#if defined(_KERNEL)
 	return (!!boot_cpu_has(X86_FEATURE_XMM4_1));
-#elif !defined(_KERNEL)
-	return (__cpuid_has_sse4_1());
-#endif
 }
 
 /*
@@ -505,11 +295,7 @@ zfs_sse4_1_available(void)
 static inline boolean_t
 zfs_sse4_2_available(void)
 {
-#if defined(_KERNEL)
 	return (!!boot_cpu_has(X86_FEATURE_XMM4_2));
-#elif !defined(_KERNEL)
-	return (__cpuid_has_sse4_2());
-#endif
 }
 
 /*
@@ -518,14 +304,7 @@ zfs_sse4_2_available(void)
 static inline boolean_t
 zfs_avx_available(void)
 {
-	boolean_t has_avx;
-#if defined(_KERNEL)
-	has_avx = !!boot_cpu_has(X86_FEATURE_AVX);
-#elif !defined(_KERNEL)
-	has_avx = __cpuid_has_avx();
-#endif
-
-	return (has_avx && __ymm_enabled());
+	return (boot_cpu_has(X86_FEATURE_AVX) && __ymm_enabled());
 }
 
 /*
@@ -534,14 +313,7 @@ zfs_avx_available(void)
 static inline boolean_t
 zfs_avx2_available(void)
 {
-	boolean_t has_avx2;
-#if defined(_KERNEL)
-	has_avx2 = !!boot_cpu_has(X86_FEATURE_AVX2);
-#elif !defined(_KERNEL)
-	has_avx2 = __cpuid_has_avx2();
-#endif
-
-	return (has_avx2 && __ymm_enabled());
+	return (boot_cpu_has(X86_FEATURE_AVX2) && __ymm_enabled());
 }
 
 /*
@@ -550,15 +322,11 @@ zfs_avx2_available(void)
 static inline boolean_t
 zfs_bmi1_available(void)
 {
-#if defined(_KERNEL)
 #if defined(X86_FEATURE_BMI1)
 	return (!!boot_cpu_has(X86_FEATURE_BMI1));
 #else
 	return (B_FALSE);
 #endif
-#elif !defined(_KERNEL)
-	return (__cpuid_has_bmi1());
-#endif
 }
 
 /*
@@ -567,15 +335,11 @@ zfs_bmi1_available(void)
 static inline boolean_t
 zfs_bmi2_available(void)
 {
-#if defined(_KERNEL)
 #if defined(X86_FEATURE_BMI2)
 	return (!!boot_cpu_has(X86_FEATURE_BMI2));
 #else
 	return (B_FALSE);
 #endif
-#elif !defined(_KERNEL)
-	return (__cpuid_has_bmi2());
-#endif
 }
 
 /*
@@ -584,15 +348,11 @@ zfs_bmi2_available(void)
 static inline boolean_t
 zfs_aes_available(void)
 {
-#if defined(_KERNEL)
 #if defined(X86_FEATURE_AES)
 	return (!!boot_cpu_has(X86_FEATURE_AES));
 #else
 	return (B_FALSE);
 #endif
-#elif !defined(_KERNEL)
-	return (__cpuid_has_aes());
-#endif
 }
 
 /*
@@ -601,15 +361,11 @@ zfs_aes_available(void)
 static inline boolean_t
 zfs_pclmulqdq_available(void)
 {
-#if defined(_KERNEL)
 #if defined(X86_FEATURE_PCLMULQDQ)
 	return (!!boot_cpu_has(X86_FEATURE_PCLMULQDQ));
 #else
 	return (B_FALSE);
 #endif
-#elif !defined(_KERNEL)
-	return (__cpuid_has_pclmulqdq());
-#endif
 }
 
 /*
@@ -628,184 +384,137 @@ zfs_pclmulqdq_available(void)
  * AVX512VBMI	Vector Byte Manipulation Instructions
  */
 
-
-/* Check if AVX512F instruction set is available */
+/*
+ * Check if AVX512F instruction set is available
+ */
 static inline boolean_t
 zfs_avx512f_available(void)
 {
 	boolean_t has_avx512 = B_FALSE;
 
-#if defined(_KERNEL)
 #if defined(X86_FEATURE_AVX512F)
 	has_avx512 = !!boot_cpu_has(X86_FEATURE_AVX512F);
-#else
-	has_avx512 = B_FALSE;
-#endif
-#elif !defined(_KERNEL)
-	has_avx512 = __cpuid_has_avx512f();
 #endif
-
 	return (has_avx512 && __zmm_enabled());
 }
 
-/* Check if AVX512CD instruction set is available */
+/*
+ * Check if AVX512CD instruction set is available
+ */
 static inline boolean_t
 zfs_avx512cd_available(void)
 {
 	boolean_t has_avx512 = B_FALSE;
 
-#if defined(_KERNEL)
 #if defined(X86_FEATURE_AVX512CD)
 	has_avx512 = boot_cpu_has(X86_FEATURE_AVX512F) &&
 	    boot_cpu_has(X86_FEATURE_AVX512CD);
-#else
-	has_avx512 = B_FALSE;
-#endif
-#elif !defined(_KERNEL)
-	has_avx512 = __cpuid_has_avx512cd();
 #endif
-
 	return (has_avx512 && __zmm_enabled());
 }
 
-/* Check if AVX512ER instruction set is available */
+/*
+ * Check if AVX512ER instruction set is available
+ */
 static inline boolean_t
 zfs_avx512er_available(void)
 {
 	boolean_t has_avx512 = B_FALSE;
 
-#if defined(_KERNEL)
 #if defined(X86_FEATURE_AVX512ER)
 	has_avx512 = boot_cpu_has(X86_FEATURE_AVX512F) &&
 	    boot_cpu_has(X86_FEATURE_AVX512ER);
-#else
-	has_avx512 = B_FALSE;
-#endif
-#elif !defined(_KERNEL)
-	has_avx512 = __cpuid_has_avx512er();
 #endif
-
 	return (has_avx512 && __zmm_enabled());
 }
 
-/* Check if AVX512PF instruction set is available */
+/*
+ * Check if AVX512PF instruction set is available
+ */
 static inline boolean_t
 zfs_avx512pf_available(void)
 {
 	boolean_t has_avx512 = B_FALSE;
 
-#if defined(_KERNEL)
 #if defined(X86_FEATURE_AVX512PF)
 	has_avx512 = boot_cpu_has(X86_FEATURE_AVX512F) &&
 	    boot_cpu_has(X86_FEATURE_AVX512PF);
-#else
-	has_avx512 = B_FALSE;
-#endif
-#elif !defined(_KERNEL)
-	has_avx512 = __cpuid_has_avx512pf();
 #endif
-
 	return (has_avx512 && __zmm_enabled());
 }
 
-/* Check if AVX512BW instruction set is available */
+/*
+ * Check if AVX512BW instruction set is available
+ */
 static inline boolean_t
 zfs_avx512bw_available(void)
 {
 	boolean_t has_avx512 = B_FALSE;
 
-#if defined(_KERNEL)
 #if defined(X86_FEATURE_AVX512BW)
 	has_avx512 = boot_cpu_has(X86_FEATURE_AVX512F) &&
 	    boot_cpu_has(X86_FEATURE_AVX512BW);
-#else
-	has_avx512 = B_FALSE;
-#endif
-#elif !defined(_KERNEL)
-	has_avx512 = __cpuid_has_avx512bw();
 #endif
-
 	return (has_avx512 && __zmm_enabled());
 }
 
-/* Check if AVX512DQ instruction set is available */
+/*
+ * Check if AVX512DQ instruction set is available
+ */
 static inline boolean_t
 zfs_avx512dq_available(void)
 {
 	boolean_t has_avx512 = B_FALSE;
 
-#if defined(_KERNEL)
 #if defined(X86_FEATURE_AVX512DQ)
 	has_avx512 = boot_cpu_has(X86_FEATURE_AVX512F) &&
 	    boot_cpu_has(X86_FEATURE_AVX512DQ);
-#else
-	has_avx512 = B_FALSE;
-#endif
-#elif !defined(_KERNEL)
-	has_avx512 = __cpuid_has_avx512dq();
 #endif
-
 	return (has_avx512 && __zmm_enabled());
 }
 
-/* Check if AVX512VL instruction set is available */
+/*
+ * Check if AVX512VL instruction set is available
+ */
 static inline boolean_t
 zfs_avx512vl_available(void)
 {
 	boolean_t has_avx512 = B_FALSE;
 
-#if defined(_KERNEL)
 #if defined(X86_FEATURE_AVX512VL)
 	has_avx512 = boot_cpu_has(X86_FEATURE_AVX512F) &&
 	    boot_cpu_has(X86_FEATURE_AVX512VL);
-#else
-	has_avx512 = B_FALSE;
-#endif
-#elif !defined(_KERNEL)
-	has_avx512 = __cpuid_has_avx512vl();
 #endif
-
 	return (has_avx512 && __zmm_enabled());
 }
 
-/* Check if AVX512IFMA instruction set is available */
+/*
+ * Check if AVX512IFMA instruction set is available
+ */
 static inline boolean_t
 zfs_avx512ifma_available(void)
 {
 	boolean_t has_avx512 = B_FALSE;
 
-#if defined(_KERNEL)
 #if defined(X86_FEATURE_AVX512IFMA)
 	has_avx512 = boot_cpu_has(X86_FEATURE_AVX512F) &&
 	    boot_cpu_has(X86_FEATURE_AVX512IFMA);
-#else
-	has_avx512 = B_FALSE;
-#endif
-#elif !defined(_KERNEL)
-	has_avx512 = __cpuid_has_avx512ifma();
 #endif
-
 	return (has_avx512 && __zmm_enabled());
 }
 
-/* Check if AVX512VBMI instruction set is available */
+/*
+ * Check if AVX512VBMI instruction set is available
+ */
 static inline boolean_t
 zfs_avx512vbmi_available(void)
 {
 	boolean_t has_avx512 = B_FALSE;
 
-#if defined(_KERNEL)
 #if defined(X86_FEATURE_AVX512VBMI)
 	has_avx512 = boot_cpu_has(X86_FEATURE_AVX512F) &&
 	    boot_cpu_has(X86_FEATURE_AVX512VBMI);
-#else
-	has_avx512 = B_FALSE;
 #endif
-#elif !defined(_KERNEL)
-	has_avx512 = __cpuid_has_avx512f() &&
-	    __cpuid_has_avx512vbmi();
-#endif
-
 	return (has_avx512 && __zmm_enabled());
 }
 
Index: zfs-linux-0.8.2/include/spl/sys/simd.h
===================================================================
--- /dev/null
+++ zfs-linux-0.8.2/include/spl/sys/simd.h
@@ -0,0 +1,31 @@
+/*
+ *  Copyright (C) 2007-2010 Lawrence Livermore National Security, LLC.
+ *  Copyright (C) 2007 The Regents of the University of California.
+ *  Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).
+ *  Written by Brian Behlendorf <behlendorf1@llnl.gov>.
+ *  UCRL-CODE-235197
+ *
+ *  This file is part of the SPL, Solaris Porting Layer.
+ *  For details, see <http://zfsonlinux.org/>.
+ *
+ *  The SPL is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  The SPL is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with the SPL.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef	_SPL_SYS_SIMD_H
+#define	_SPL_SYS_SIMD_H
+
+#include <sys/isa_defs.h>
+#include <linux/simd.h>
+
+#endif /* _SPL_SYS_SIMD_H */
Index: zfs-linux-0.8.2/lib/libspl/include/sys/Makefile.am
===================================================================
--- zfs-linux-0.8.2.orig/lib/libspl/include/sys/Makefile.am
+++ zfs-linux-0.8.2/lib/libspl/include/sys/Makefile.am
@@ -33,6 +33,7 @@ libspl_HEADERS = \
 	$(top_srcdir)/lib/libspl/include/sys/priv.h \
 	$(top_srcdir)/lib/libspl/include/sys/processor.h \
 	$(top_srcdir)/lib/libspl/include/sys/signal.h \
+	$(top_srcdir)/lib/libspl/include/sys/simd.h \
 	$(top_srcdir)/lib/libspl/include/sys/stack.h \
 	$(top_srcdir)/lib/libspl/include/sys/stat.h \
 	$(top_srcdir)/lib/libspl/include/sys/stdtypes.h \
Index: zfs-linux-0.8.2/lib/libspl/include/sys/simd.h
===================================================================
--- /dev/null
+++ zfs-linux-0.8.2/lib/libspl/include/sys/simd.h
@@ -0,0 +1,448 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+/*
+ * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ */
+
+#ifndef _LIBSPL_SYS_SIMD_H
+#define	_LIBSPL_SYS_SIMD_H
+
+#include <sys/isa_defs.h>
+#include <sys/types.h>
+
+#if defined(__x86)
+#include <cpuid.h>
+
+#define	kfpu_allowed()		1
+#define	kfpu_initialize(tsk)	do {} while (0)
+#define	kfpu_begin()		do {} while (0)
+#define	kfpu_end()		do {} while (0)
+
+/*
+ * CPUID feature tests for user-space.
+ *
+ * x86 registers used implicitly by CPUID
+ */
+typedef enum cpuid_regs {
+	EAX = 0,
+	EBX,
+	ECX,
+	EDX,
+	CPUID_REG_CNT = 4
+} cpuid_regs_t;
+
+/*
+ * List of instruction sets identified by CPUID
+ */
+typedef enum cpuid_inst_sets {
+	SSE = 0,
+	SSE2,
+	SSE3,
+	SSSE3,
+	SSE4_1,
+	SSE4_2,
+	OSXSAVE,
+	AVX,
+	AVX2,
+	BMI1,
+	BMI2,
+	AVX512F,
+	AVX512CD,
+	AVX512DQ,
+	AVX512BW,
+	AVX512IFMA,
+	AVX512VBMI,
+	AVX512PF,
+	AVX512ER,
+	AVX512VL,
+	AES,
+	PCLMULQDQ
+} cpuid_inst_sets_t;
+
+/*
+ * Instruction set descriptor.
+ */
+typedef struct cpuid_feature_desc {
+	uint32_t leaf;		/* CPUID leaf */
+	uint32_t subleaf;	/* CPUID sub-leaf */
+	uint32_t flag;		/* bit mask of the feature */
+	cpuid_regs_t reg;	/* which CPUID return register to test */
+} cpuid_feature_desc_t;
+
+#define	_AVX512F_BIT		(1U << 16)
+#define	_AVX512CD_BIT		(_AVX512F_BIT | (1U << 28))
+#define	_AVX512DQ_BIT		(_AVX512F_BIT | (1U << 17))
+#define	_AVX512BW_BIT		(_AVX512F_BIT | (1U << 30))
+#define	_AVX512IFMA_BIT		(_AVX512F_BIT | (1U << 21))
+#define	_AVX512VBMI_BIT		(1U << 1) /* AVX512F_BIT is on another leaf  */
+#define	_AVX512PF_BIT		(_AVX512F_BIT | (1U << 26))
+#define	_AVX512ER_BIT		(_AVX512F_BIT | (1U << 27))
+#define	_AVX512VL_BIT		(1U << 31) /* if used also check other levels */
+#define	_AES_BIT		(1U << 25)
+#define	_PCLMULQDQ_BIT		(1U << 1)
+
+/*
+ * Descriptions of supported instruction sets
+ */
+static const cpuid_feature_desc_t cpuid_features[] = {
+	[SSE]		= {1U, 0U,	1U << 25,	EDX	},
+	[SSE2]		= {1U, 0U,	1U << 26,	EDX	},
+	[SSE3]		= {1U, 0U,	1U << 0,	ECX	},
+	[SSSE3]		= {1U, 0U,	1U << 9,	ECX	},
+	[SSE4_1]	= {1U, 0U,	1U << 19,	ECX	},
+	[SSE4_2]	= {1U, 0U,	1U << 20,	ECX	},
+	[OSXSAVE]	= {1U, 0U,	1U << 27,	ECX	},
+	[AVX]		= {1U, 0U,	1U << 28,	ECX	},
+	[AVX2]		= {7U, 0U,	1U << 5,	EBX	},
+	[BMI1]		= {7U, 0U,	1U << 3,	EBX	},
+	[BMI2]		= {7U, 0U,	1U << 8,	EBX	},
+	[AVX512F]	= {7U, 0U, _AVX512F_BIT,	EBX	},
+	[AVX512CD]	= {7U, 0U, _AVX512CD_BIT,	EBX	},
+	[AVX512DQ]	= {7U, 0U, _AVX512DQ_BIT,	EBX	},
+	[AVX512BW]	= {7U, 0U, _AVX512BW_BIT,	EBX	},
+	[AVX512IFMA]	= {7U, 0U, _AVX512IFMA_BIT,	EBX	},
+	[AVX512VBMI]	= {7U, 0U, _AVX512VBMI_BIT,	ECX	},
+	[AVX512PF]	= {7U, 0U, _AVX512PF_BIT,	EBX	},
+	[AVX512ER]	= {7U, 0U, _AVX512ER_BIT,	EBX	},
+	[AVX512VL]	= {7U, 0U, _AVX512ER_BIT,	EBX	},
+	[AES]		= {1U, 0U, _AES_BIT,		ECX	},
+	[PCLMULQDQ]	= {1U, 0U, _PCLMULQDQ_BIT,	ECX	},
+};
+
+/*
+ * Check if OS supports AVX and AVX2 by checking XCR0
+ * Only call this function if CPUID indicates that AVX feature is
+ * supported by the CPU, otherwise it might be an illegal instruction.
+ */
+static inline uint64_t
+xgetbv(uint32_t index)
+{
+	uint32_t eax, edx;
+	/* xgetbv - instruction byte code */
+	__asm__ __volatile__(".byte 0x0f; .byte 0x01; .byte 0xd0"
+	    : "=a" (eax), "=d" (edx)
+	    : "c" (index));
+
+	return ((((uint64_t)edx)<<32) | (uint64_t)eax);
+}
+
+/*
+ * Check if CPU supports a feature
+ */
+static inline boolean_t
+__cpuid_check_feature(const cpuid_feature_desc_t *desc)
+{
+	uint32_t r[CPUID_REG_CNT];
+
+	if (__get_cpuid_max(0, NULL) >= desc->leaf) {
+		/*
+		 * __cpuid_count is needed to properly check
+		 * for AVX2. It is a macro, so return parameters
+		 * are passed by value.
+		 */
+		__cpuid_count(desc->leaf, desc->subleaf,
+		    r[EAX], r[EBX], r[ECX], r[EDX]);
+		return ((r[desc->reg] & desc->flag) == desc->flag);
+	}
+	return (B_FALSE);
+}
+
+#define	CPUID_FEATURE_CHECK(name, id)				\
+static inline boolean_t						\
+__cpuid_has_ ## name(void)					\
+{								\
+	return (__cpuid_check_feature(&cpuid_features[id]));	\
+}
+
+/*
+ * Define functions for user-space CPUID features testing
+ */
+CPUID_FEATURE_CHECK(sse, SSE);
+CPUID_FEATURE_CHECK(sse2, SSE2);
+CPUID_FEATURE_CHECK(sse3, SSE3);
+CPUID_FEATURE_CHECK(ssse3, SSSE3);
+CPUID_FEATURE_CHECK(sse4_1, SSE4_1);
+CPUID_FEATURE_CHECK(sse4_2, SSE4_2);
+CPUID_FEATURE_CHECK(avx, AVX);
+CPUID_FEATURE_CHECK(avx2, AVX2);
+CPUID_FEATURE_CHECK(osxsave, OSXSAVE);
+CPUID_FEATURE_CHECK(bmi1, BMI1);
+CPUID_FEATURE_CHECK(bmi2, BMI2);
+CPUID_FEATURE_CHECK(avx512f, AVX512F);
+CPUID_FEATURE_CHECK(avx512cd, AVX512CD);
+CPUID_FEATURE_CHECK(avx512dq, AVX512DQ);
+CPUID_FEATURE_CHECK(avx512bw, AVX512BW);
+CPUID_FEATURE_CHECK(avx512ifma, AVX512IFMA);
+CPUID_FEATURE_CHECK(avx512vbmi, AVX512VBMI);
+CPUID_FEATURE_CHECK(avx512pf, AVX512PF);
+CPUID_FEATURE_CHECK(avx512er, AVX512ER);
+CPUID_FEATURE_CHECK(avx512vl, AVX512VL);
+CPUID_FEATURE_CHECK(aes, AES);
+CPUID_FEATURE_CHECK(pclmulqdq, PCLMULQDQ);
+
+/*
+ * Detect register set support
+ */
+static inline boolean_t
+__simd_state_enabled(const uint64_t state)
+{
+	boolean_t has_osxsave;
+	uint64_t xcr0;
+
+	has_osxsave = __cpuid_has_osxsave();
+	if (!has_osxsave)
+		return (B_FALSE);
+
+	xcr0 = xgetbv(0);
+	return ((xcr0 & state) == state);
+}
+
+#define	_XSTATE_SSE_AVX		(0x2 | 0x4)
+#define	_XSTATE_AVX512		(0xE0 | _XSTATE_SSE_AVX)
+
+#define	__ymm_enabled()		__simd_state_enabled(_XSTATE_SSE_AVX)
+#define	__zmm_enabled()		__simd_state_enabled(_XSTATE_AVX512)
+
+/*
+ * Check if SSE instruction set is available
+ */
+static inline boolean_t
+zfs_sse_available(void)
+{
+	return (__cpuid_has_sse());
+}
+
+/*
+ * Check if SSE2 instruction set is available
+ */
+static inline boolean_t
+zfs_sse2_available(void)
+{
+	return (__cpuid_has_sse2());
+}
+
+/*
+ * Check if SSE3 instruction set is available
+ */
+static inline boolean_t
+zfs_sse3_available(void)
+{
+	return (__cpuid_has_sse3());
+}
+
+/*
+ * Check if SSSE3 instruction set is available
+ */
+static inline boolean_t
+zfs_ssse3_available(void)
+{
+	return (__cpuid_has_ssse3());
+}
+
+/*
+ * Check if SSE4.1 instruction set is available
+ */
+static inline boolean_t
+zfs_sse4_1_available(void)
+{
+	return (__cpuid_has_sse4_1());
+}
+
+/*
+ * Check if SSE4.2 instruction set is available
+ */
+static inline boolean_t
+zfs_sse4_2_available(void)
+{
+	return (__cpuid_has_sse4_2());
+}
+
+/*
+ * Check if AVX instruction set is available
+ */
+static inline boolean_t
+zfs_avx_available(void)
+{
+	return (__cpuid_has_avx() && __ymm_enabled());
+}
+
+/*
+ * Check if AVX2 instruction set is available
+ */
+static inline boolean_t
+zfs_avx2_available(void)
+{
+	return (__cpuid_has_avx2() && __ymm_enabled());
+}
+
+/*
+ * Check if BMI1 instruction set is available
+ */
+static inline boolean_t
+zfs_bmi1_available(void)
+{
+	return (__cpuid_has_bmi1());
+}
+
+/*
+ * Check if BMI2 instruction set is available
+ */
+static inline boolean_t
+zfs_bmi2_available(void)
+{
+	return (__cpuid_has_bmi2());
+}
+
+/*
+ * Check if AES instruction set is available
+ */
+static inline boolean_t
+zfs_aes_available(void)
+{
+	return (__cpuid_has_aes());
+}
+
+/*
+ * Check if PCLMULQDQ instruction set is available
+ */
+static inline boolean_t
+zfs_pclmulqdq_available(void)
+{
+	return (__cpuid_has_pclmulqdq());
+}
+
+/*
+ * AVX-512 family of instruction sets:
+ *
+ * AVX512F	Foundation
+ * AVX512CD	Conflict Detection Instructions
+ * AVX512ER	Exponential and Reciprocal Instructions
+ * AVX512PF	Prefetch Instructions
+ *
+ * AVX512BW	Byte and Word Instructions
+ * AVX512DQ	Double-word and Quadword Instructions
+ * AVX512VL	Vector Length Extensions
+ *
+ * AVX512IFMA	Integer Fused Multiply Add (Not supported by kernel 4.4)
+ * AVX512VBMI	Vector Byte Manipulation Instructions
+ */
+
+/*
+ * Check if AVX512F instruction set is available
+ */
+static inline boolean_t
+zfs_avx512f_available(void)
+{
+	return (__cpuid_has_avx512f() && __zmm_enabled());
+}
+
+/*
+ * Check if AVX512CD instruction set is available
+ */
+static inline boolean_t
+zfs_avx512cd_available(void)
+{
+	return (__cpuid_has_avx512cd() && __zmm_enabled());
+}
+
+/*
+ * Check if AVX512ER instruction set is available
+ */
+static inline boolean_t
+zfs_avx512er_available(void)
+{
+	return (__cpuid_has_avx512er() && __zmm_enabled());
+}
+
+/*
+ * Check if AVX512PF instruction set is available
+ */
+static inline boolean_t
+zfs_avx512pf_available(void)
+{
+	return (__cpuid_has_avx512pf() && __zmm_enabled());
+}
+
+/*
+ * Check if AVX512BW instruction set is available
+ */
+static inline boolean_t
+zfs_avx512bw_available(void)
+{
+	return (__cpuid_has_avx512bw() && __zmm_enabled());
+}
+
+/*
+ * Check if AVX512DQ instruction set is available
+ */
+static inline boolean_t
+zfs_avx512dq_available(void)
+{
+	return (__cpuid_has_avx512dq() && __zmm_enabled());
+}
+
+/*
+ * Check if AVX512VL instruction set is available
+ */
+static inline boolean_t
+zfs_avx512vl_available(void)
+{
+	return (__cpuid_has_avx512vl() && __zmm_enabled());
+}
+
+/*
+ * Check if AVX512IFMA instruction set is available
+ */
+static inline boolean_t
+zfs_avx512ifma_available(void)
+{
+	return (__cpuid_has_avx512ifma() && __zmm_enabled());
+}
+
+/*
+ * Check if AVX512VBMI instruction set is available
+ */
+static inline boolean_t
+zfs_avx512vbmi_available(void)
+{
+	return (__cpuid_has_avx512f() && __cpuid_has_avx512vbmi() &&
+	    __zmm_enabled());
+}
+
+#elif defined(__aarch64__)
+
+#define	kfpu_allowed()		1
+#define	kfpu_initialize(tsk)	do {} while (0)
+#define	kfpu_begin()		do {} while (0)
+#define	kfpu_end()		do {} while (0)
+
+#else
+
+#define	kfpu_allowed()		0
+#define	kfpu_initialize(tsk)	do {} while (0)
+#define	kfpu_begin()		do {} while (0)
+#define	kfpu_end()		do {} while (0)
+
+#endif
+
+#endif /* _LIBSPL_SYS_SIMD_H */
Index: zfs-linux-0.8.2/module/icp/algs/aes/aes_impl.c
===================================================================
--- zfs-linux-0.8.2.orig/module/icp/algs/aes/aes_impl.c
+++ zfs-linux-0.8.2/module/icp/algs/aes/aes_impl.c
@@ -25,9 +25,9 @@
 #include <sys/zfs_context.h>
 #include <sys/crypto/icp.h>
 #include <sys/crypto/spi.h>
+#include <sys/simd.h>
 #include <modes/modes.h>
 #include <aes/aes_impl.h>
-#include <linux/simd.h>
 
 /*
  * Initialize AES encryption and decryption key schedules.
Index: zfs-linux-0.8.2/module/icp/algs/aes/aes_impl_aesni.c
===================================================================
--- zfs-linux-0.8.2.orig/module/icp/algs/aes/aes_impl_aesni.c
+++ zfs-linux-0.8.2/module/icp/algs/aes/aes_impl_aesni.c
@@ -24,7 +24,8 @@
 
 #if defined(__x86_64) && defined(HAVE_AES)
 
-#include <linux/simd_x86.h>
+#include <sys/simd.h>
+#include <sys/types.h>
 
 /* These functions are used to execute AES-NI instructions: */
 extern int rijndael_key_setup_enc_intel(uint32_t rk[],
Index: zfs-linux-0.8.2/module/icp/algs/aes/aes_impl_x86-64.c
===================================================================
--- zfs-linux-0.8.2.orig/module/icp/algs/aes/aes_impl_x86-64.c
+++ zfs-linux-0.8.2/module/icp/algs/aes/aes_impl_x86-64.c
@@ -24,7 +24,7 @@
 
 #if defined(__x86_64)
 
-#include <linux/simd_x86.h>
+#include <sys/simd.h>
 
 /* These functions are used to execute amd64 instructions for AMD or Intel: */
 extern int rijndael_key_setup_enc_amd64(uint32_t rk[],
Index: zfs-linux-0.8.2/module/icp/algs/modes/gcm.c
===================================================================
--- zfs-linux-0.8.2.orig/module/icp/algs/modes/gcm.c
+++ zfs-linux-0.8.2/module/icp/algs/modes/gcm.c
@@ -27,9 +27,9 @@
 #include <sys/crypto/common.h>
 #include <sys/crypto/icp.h>
 #include <sys/crypto/impl.h>
+#include <sys/simd.h>
 #include <sys/byteorder.h>
 #include <modes/gcm_impl.h>
-#include <linux/simd.h>
 
 #define	GHASH(c, d, t, o) \
 	xor_block((uint8_t *)(d), (uint8_t *)(c)->gcm_ghash); \
Index: zfs-linux-0.8.2/module/icp/algs/modes/gcm_pclmulqdq.c
===================================================================
--- zfs-linux-0.8.2.orig/module/icp/algs/modes/gcm_pclmulqdq.c
+++ zfs-linux-0.8.2/module/icp/algs/modes/gcm_pclmulqdq.c
@@ -24,7 +24,8 @@
 
 #if defined(__x86_64) && defined(HAVE_PCLMULQDQ)
 
-#include <linux/simd_x86.h>
+#include <sys/types.h>
+#include <sys/simd.h>
 
 /* These functions are used to execute pclmulqdq based assembly methods */
 extern void gcm_mul_pclmulqdq(uint64_t *, uint64_t *, uint64_t *);
Index: zfs-linux-0.8.2/module/icp/io/aes.c
===================================================================
--- zfs-linux-0.8.2.orig/module/icp/io/aes.c
+++ zfs-linux-0.8.2/module/icp/io/aes.c
@@ -212,8 +212,8 @@ aes_mod_init(void)
 	 * are run in dedicated kernel threads to allow Linux 5.0+ kernels
 	 * to use SIMD operations.  If for some reason this isn't possible,
 	 * fallback to the generic implementations.  See the comment in
-	 * include/linux/simd_x86.h for additional details.  Additionally,
-	 * this has the benefit of allowing them to be run in parallel.
+	 * linux/simd_x86.h for additional details.  Additionally, this has
+	 * the benefit of allowing them to be run in parallel.
 	 */
 	taskqid_t aes_id = taskq_dispatch(system_taskq, aes_impl_init,
 	    NULL, TQ_SLEEP);
Index: zfs-linux-0.8.2/module/spl/spl-taskq.c
===================================================================
--- zfs-linux-0.8.2.orig/module/spl/spl-taskq.c
+++ zfs-linux-0.8.2/module/spl/spl-taskq.c
@@ -28,7 +28,7 @@
 #include <sys/taskq.h>
 #include <sys/kmem.h>
 #include <sys/tsd.h>
-#include <linux/simd.h>
+#include <sys/simd.h>
 
 int spl_taskq_thread_bind = 0;
 module_param(spl_taskq_thread_bind, int, 0644);
Index: zfs-linux-0.8.2/module/spl/spl-thread.c
===================================================================
--- zfs-linux-0.8.2.orig/module/spl/spl-thread.c
+++ zfs-linux-0.8.2/module/spl/spl-thread.c
@@ -27,7 +27,7 @@
 #include <sys/thread.h>
 #include <sys/kmem.h>
 #include <sys/tsd.h>
-#include <linux/simd.h>
+#include <sys/simd.h>
 
 /*
  * Thread interfaces
Index: zfs-linux-0.8.2/module/zcommon/zfs_fletcher.c
===================================================================
--- zfs-linux-0.8.2.orig/module/zcommon/zfs_fletcher.c
+++ zfs-linux-0.8.2/module/zcommon/zfs_fletcher.c
@@ -137,10 +137,10 @@
 #include <sys/sysmacros.h>
 #include <sys/byteorder.h>
 #include <sys/spa.h>
+#include <sys/simd.h>
 #include <sys/zio_checksum.h>
 #include <sys/zfs_context.h>
 #include <zfs_fletcher.h>
-#include <linux/simd.h>
 
 #define	FLETCHER_MIN_SIMD_SIZE	64
 
Index: zfs-linux-0.8.2/module/zcommon/zfs_fletcher_aarch64_neon.c
===================================================================
--- zfs-linux-0.8.2.orig/module/zcommon/zfs_fletcher_aarch64_neon.c
+++ zfs-linux-0.8.2/module/zcommon/zfs_fletcher_aarch64_neon.c
@@ -43,7 +43,7 @@
 
 #if defined(__aarch64__)
 
-#include <linux/simd_aarch64.h>
+#include <sys/simd.h>
 #include <sys/spa_checksum.h>
 #include <sys/strings.h>
 #include <zfs_fletcher.h>
Index: zfs-linux-0.8.2/module/zcommon/zfs_fletcher_avx512.c
===================================================================
--- zfs-linux-0.8.2.orig/module/zcommon/zfs_fletcher_avx512.c
+++ zfs-linux-0.8.2/module/zcommon/zfs_fletcher_avx512.c
@@ -24,11 +24,11 @@
 
 #if defined(__x86_64) && defined(HAVE_AVX512F)
 
-#include <linux/simd_x86.h>
 #include <sys/byteorder.h>
 #include <sys/frame.h>
 #include <sys/spa_checksum.h>
 #include <sys/strings.h>
+#include <sys/simd.h>
 #include <zfs_fletcher.h>
 
 #define	__asm __asm__ __volatile__
Index: zfs-linux-0.8.2/module/zcommon/zfs_fletcher_intel.c
===================================================================
--- zfs-linux-0.8.2.orig/module/zcommon/zfs_fletcher_intel.c
+++ zfs-linux-0.8.2/module/zcommon/zfs_fletcher_intel.c
@@ -42,7 +42,7 @@
 
 #if defined(HAVE_AVX) && defined(HAVE_AVX2)
 
-#include <linux/simd_x86.h>
+#include <sys/simd.h>
 #include <sys/spa_checksum.h>
 #include <sys/strings.h>
 #include <zfs_fletcher.h>
Index: zfs-linux-0.8.2/module/zfs/vdev_raidz_math.c
===================================================================
--- zfs-linux-0.8.2.orig/module/zfs/vdev_raidz_math.c
+++ zfs-linux-0.8.2/module/zfs/vdev_raidz_math.c
@@ -29,7 +29,7 @@
 #include <sys/zfs_debug.h>
 #include <sys/vdev_raidz.h>
 #include <sys/vdev_raidz_impl.h>
-#include <linux/simd.h>
+#include <sys/simd.h>
 
 extern boolean_t raidz_will_scalar_work(void);
 
Index: zfs-linux-0.8.2/module/zfs/vdev_raidz_math_aarch64_neon_common.h
===================================================================
--- zfs-linux-0.8.2.orig/module/zfs/vdev_raidz_math_aarch64_neon_common.h
+++ zfs-linux-0.8.2/module/zfs/vdev_raidz_math_aarch64_neon_common.h
@@ -23,7 +23,7 @@
  */
 
 #include <sys/types.h>
-#include <linux/simd_aarch64.h>
+#include <sys/simd.h>
 
 #define	__asm __asm__ __volatile__
 
Index: zfs-linux-0.8.2/module/zfs/vdev_raidz_math_avx512bw.c
===================================================================
--- zfs-linux-0.8.2.orig/module/zfs/vdev_raidz_math_avx512bw.c
+++ zfs-linux-0.8.2/module/zfs/vdev_raidz_math_avx512bw.c
@@ -28,7 +28,7 @@
 #if defined(__x86_64) && defined(HAVE_AVX512BW)
 
 #include <sys/types.h>
-#include <linux/simd_x86.h>
+#include <sys/simd.h>
 
 #define	__asm __asm__ __volatile__
 
Index: zfs-linux-0.8.2/module/zfs/vdev_raidz_math_avx512f.c
===================================================================
--- zfs-linux-0.8.2.orig/module/zfs/vdev_raidz_math_avx512f.c
+++ zfs-linux-0.8.2/module/zfs/vdev_raidz_math_avx512f.c
@@ -28,7 +28,7 @@
 #if defined(__x86_64) && defined(HAVE_AVX512F)
 
 #include <sys/types.h>
-#include <linux/simd_x86.h>
+#include <sys/simd.h>
 
 #define	__asm __asm__ __volatile__
 
Index: zfs-linux-0.8.2/module/zfs/vdev_raidz_math_sse2.c
===================================================================
--- zfs-linux-0.8.2.orig/module/zfs/vdev_raidz_math_sse2.c
+++ zfs-linux-0.8.2/module/zfs/vdev_raidz_math_sse2.c
@@ -27,7 +27,7 @@
 #if defined(__x86_64) && defined(HAVE_SSE2)
 
 #include <sys/types.h>
-#include <linux/simd_x86.h>
+#include <sys/simd.h>
 
 #define	__asm __asm__ __volatile__
 
Index: zfs-linux-0.8.2/module/zfs/vdev_raidz_math_ssse3.c
===================================================================
--- zfs-linux-0.8.2.orig/module/zfs/vdev_raidz_math_ssse3.c
+++ zfs-linux-0.8.2/module/zfs/vdev_raidz_math_ssse3.c
@@ -27,7 +27,7 @@
 #if defined(__x86_64) && defined(HAVE_SSSE3)
 
 #include <sys/types.h>
-#include <linux/simd_x86.h>
+#include <sys/simd.h>
 
 #define	__asm __asm__ __volatile__
 
Index: zfs-linux-0.8.2/module/zfs/vdev_raidz_math_avx2.c
===================================================================
--- zfs-linux-0.8.2.orig/module/zfs/vdev_raidz_math_avx2.c
+++ zfs-linux-0.8.2/module/zfs/vdev_raidz_math_avx2.c
@@ -26,7 +26,7 @@
 #if defined(__x86_64) && defined(HAVE_AVX2)
 
 #include <sys/types.h>
-#include <linux/simd_x86.h>
+#include <sys/simd.h>
 
 #define	__asm __asm__ __volatile__
 
Index: zfs-linux-0.8.2/module/zfs/zio_crypt.c
===================================================================
--- zfs-linux-0.8.2.orig/module/zfs/zio_crypt.c
+++ zfs-linux-0.8.2/module/zfs/zio_crypt.c
@@ -22,10 +22,10 @@
 #include <sys/dmu_objset.h>
 #include <sys/dnode.h>
 #include <sys/fs/zfs.h>
+#include <sys/simd.h>
 #include <sys/zio.h>
 #include <sys/zil.h>
 #include <sys/sha2.h>
-#include <linux/simd.h>
 #include <sys/spa_impl.h>
 #include <sys/hkdf.h>
 #include "qat.h"
Index: zfs-linux-0.8.2/module/zcommon/zfs_fletcher_sse.c
===================================================================
--- zfs-linux-0.8.2.orig/module/zcommon/zfs_fletcher_sse.c
+++ zfs-linux-0.8.2/module/zcommon/zfs_fletcher_sse.c
@@ -43,7 +43,7 @@
 
 #if defined(HAVE_SSE2)
 
-#include <linux/simd_x86.h>
+#include <sys/simd.h>
 #include <sys/spa_checksum.h>
 #include <sys/byteorder.h>
 #include <sys/strings.h>
Index: zfs-linux-0.8.2/include/spl/sys/Makefile.am
===================================================================
--- zfs-linux-0.8.2.orig/include/spl/sys/Makefile.am
+++ zfs-linux-0.8.2/include/spl/sys/Makefile.am
@@ -33,6 +33,7 @@ KERNEL_H = \
 	$(top_srcdir)/include/spl/sys/shrinker.h \
 	$(top_srcdir)/include/spl/sys/sid.h \
 	$(top_srcdir)/include/spl/sys/signal.h \
+	$(top_srcdir)/include/spl/sys/simd.h \
 	$(top_srcdir)/include/spl/sys/stat.h \
 	$(top_srcdir)/include/spl/sys/strings.h \
 	$(top_srcdir)/include/spl/sys/sunddi.h \
