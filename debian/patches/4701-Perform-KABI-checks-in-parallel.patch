From 608f8749a1055e6769899788e11bd51fd396f9e5 Mon Sep 17 00:00:00 2001
From: Brian Behlendorf <behlendorf1@llnl.gov>
Date: Tue, 1 Oct 2019 12:50:34 -0700
Subject: [PATCH] Perform KABI checks in parallel

Reduce the time required for ./configure to perform the needed
KABI checks by allowing kbuild to compile multiple test cases in
parallel.  This was accomplished by splitting each test's source
code from the logic handling whether that code could be compiled
or not.

By introducing this split it's possible to minimize the number of
times kbuild needs to be invoked.  As importantly, it means all of
the tests can be built in parallel.  This does require a little extra
care since we expect some tests to fail, so the --keep-going (-k)
option must be provided otherwise some tests may not get compiled.
Furthermore, since a failure during the kbuild modpost phase will
result in an early exit; the final linking phase is limited to tests
which passed the initial compilation and produced an object file.

Once everything has been built the configure script proceeds as
previously.  The only significant difference is that it now merely
needs to test for the existence of a .ko file to determine the
result of a given test.  This vastly speeds up the entire process.

New test cases should use ZFS_LINUX_TEST_SRC to declare their test
source code and ZFS_LINUX_TEST_RESULT to check the result.  All of
the existing kernel-*.m4 files have been updated accordingly, see
config/kernel-current-time.m4 for a basic example.  The legacy
ZFS_LINUX_TRY_COMPILE macro has been kept to handle special cases
but it's use is not encouraged.

                  master (secs)   patched (secs)
                  -------------   ----------------
autogen.sh        61              68
configure         137             24  (~17% of current run time)
make -j $(nproc)  44              44
make rpms         287             150

Reviewed-by: Tony Hutter <hutter2@llnl.gov>
Signed-off-by: Brian Behlendorf <behlendorf1@llnl.gov>
Closes #8547
Closes #9132
Closes #9341
---
 Makefile.am                                   |   6 +-
 config/iconv.m4                               |   3 +-
 config/kernel-access-ok-type.m4               |  18 +-
 config/kernel-acl.m4                          | 253 ++++--
 config/kernel-aio-fsync.m4                    |  14 +-
 config/kernel-automount.m4                    |  13 +-
 config/kernel-bdev-logical-size.m4            |  17 +-
 config/kernel-bdev-physical-size.m4           |  17 +-
 config/kernel-bdi.m4                          |  78 +-
 config/kernel-bio-bvec-iter.m4                |  13 +-
 config/kernel-bio-end-io-t-args.m4            |  34 +-
 config/kernel-bio-failfast.m4                 |  39 +-
 config/kernel-bio-op.m4                       |  74 +-
 config/kernel-bio-rw-barrier.m4               |  15 +-
 config/kernel-bio-rw-discard.m4               |  15 +-
 config/kernel-bio_set_dev.m4                  |  51 +-
 config/kernel-blk-queue-bdi.m4                |  12 +-
 config/kernel-blk-queue-discard.m4            |  41 +-
 config/kernel-blk-queue-flags.m4              |  40 +-
 config/kernel-blk-queue-flush.m4              |  64 +-
 config/kernel-blk-queue-max-hw-sectors.m4     |  19 +-
 config/kernel-blk-queue-max-segments.m4       |  21 +-
 config/kernel-blk-queue-unplug.m4             |  48 +-
 config/kernel-blkdev-get-by-path.m4           |  15 +-
 config/kernel-blkdev-reread-part.m4           |  12 +-
 config/kernel-block-device-operations.m4      |  46 +-
 config/kernel-clear-inode.m4                  |  13 +-
 config/kernel-commit-metadata.m4              |  15 +-
 config/kernel-config-defined.m4               | 183 ++++
 config/kernel-create-nameidata.m4             |  15 +-
 config/kernel-ctl-table-name.m4               |  12 +-
 config/kernel-current-time.m4                 |  13 +-
 config/kernel-current_bio_tail.m4             |  30 +-
 config/kernel-d-make-root.m4                  |  17 -
 config/kernel-d-obtain-alias.m4               |  18 -
 config/kernel-d-prune-aliases.m4              |  19 -
 config/kernel-declare-event-class.m4          |   8 +-
 config/kernel-dentry-operations.m4            | 174 +++-
 config/kernel-dirty-inode.m4                  |  15 +-
 config/kernel-discard-granularity.m4          |  15 +-
 config/kernel-elevator-change.m4              |  21 +-
 config/kernel-encode-fh-inode.m4              |  15 +-
 config/kernel-evict-inode.m4                  |  13 +-
 config/kernel-fallocate.m4                    |  50 +-
 config/kernel-file-dentry.m4                  |  12 +-
 config/kernel-file-inode.m4                   |  12 +-
 config/kernel-fmode-t.m4                      |  15 +-
 config/kernel-follow-down-one.m4              |  12 +-
 config/kernel-fpu.m4                          |  99 ++-
 config/kernel-fst-mount.m4                    |  13 +-
 config/kernel-fsync.m4                        |  83 +-
 config/kernel-generic_io_acct.m4              |  63 +-
 config/kernel-generic_readlink.m4             |  15 +-
 config/kernel-get-disk-and-module.m4          |  13 +-
 config/kernel-get-disk-ro.m4                  |  18 +-
 config/kernel-get-link.m4                     | 126 +--
 config/kernel-global_page_state.m4            |  72 +-
 config/kernel-group-info.m4                   |  15 +-
 config/kernel-in-compat-syscall.m4            |  12 +-
 config/kernel-inode-getattr.m4                |  56 +-
 config/kernel-inode-lock.m4                   |  15 +-
 config/kernel-inode-set-flags.m4              |  12 +-
 config/kernel-inode-set-iversion.m4           |  12 +-
 config/kernel-inode-times.m4                  |  15 +-
 config/kernel-insert-inode-locked.m4          |  15 +-
 config/kernel-invalidate-bdev-args.m4         |  14 +-
 config/kernel-is_owner_or_cap.m4              |  31 +-
 config/kernel-kmap-atomic-args.m4             |  14 +-
 config/kernel-kmem-cache.m4                   |  62 +-
 config/kernel-kstrtoul.m4                     |  14 +-
 config/kernel-ktime_get_coarse_real_ts64.m4   |  15 +-
 config/kernel-kuid-helpers.m4                 |  12 +-
 config/kernel-kuidgid.m4                      |  26 +-
 config/kernel-lookup-bdev.m4                  |  32 +-
 config/kernel-lookup-nameidata.m4             |  15 +-
 config/kernel-lseek-execute.m4                |  16 +-
 config/kernel-make-request-fn.m4              |  77 ++
 config/kernel-misc-minor.m4                   |   2 +-
 config/kernel-mk-request-fn.m4                |  65 --
 config/kernel-mkdir-umode-t.m4                |  13 +-
 config/kernel-mod-param.m4                    |  13 +-
 config/kernel-objtool.m4                      |  47 +-
 config/kernel-open-bdev-exclusive.m4          |  15 +-
 config/kernel-pde-data.m4                     |  14 +-
 config/kernel-put-link.m4                     |  57 +-
 config/kernel-rename.m4                       |  16 +-
 config/kernel-rw.m4                           |  40 +-
 config/kernel-rwsem.m4                        |  65 +-
 config/kernel-sched.m4                        |  53 +-
 config/kernel-security-inode-init.m4          |  38 +-
 config/kernel-set-nlink.m4                    |  15 +-
 config/kernel-setattr-prepare.m4              |  16 +-
 config/kernel-sget-args.m4                    |  13 +-
 config/kernel-show-options.m4                 |  21 +-
 config/kernel-shrink.m4                       | 219 +++--
 config/kernel-submit_bio.m4                   |  12 +-
 config/kernel-super-userns.m4                 |  14 +-
 config/kernel-timer.m4                        |  52 +-
 config/kernel-tmpfile.m4                      |  16 +-
 config/kernel-totalhigh_pages.m4              |  14 +-
 config/kernel-totalram-pages-func.m4          |  15 +-
 config/kernel-truncate-range.m4               |  13 +-
 config/kernel-truncate-setsize.m4             |  15 +-
 config/kernel-userns-capabilities.m4          |  48 +-
 ...urange-sleep.m4 => kernel-usleep_range.m4} |  19 +-
 config/kernel-vfs-direct_IO.m4                | 145 ++--
 config/kernel-vfs-fsync.m4                    |  12 +-
 config/kernel-vfs-getattr.m4                  |  54 +-
 config/kernel-vfs-iterate.m4                  |  84 +-
 config/kernel-vfs-rw-iterate.m4               |  76 +-
 config/kernel-wait.m4                         |  73 +-
 config/kernel-xattr-handler.m4                | 442 +++++-----
 config/kernel-zlib.m4                         |  57 +-
 config/kernel.m4                              | 783 +++++++++++-------
 config/zfs-build.m4                           |  11 +
 config/zfs-meta.m4                            |  18 +
 118 files changed, 3245 insertions(+), 2127 deletions(-)
 create mode 100644 config/kernel-config-defined.m4
 delete mode 100644 config/kernel-d-make-root.m4
 delete mode 100644 config/kernel-d-obtain-alias.m4
 delete mode 100644 config/kernel-d-prune-aliases.m4
 create mode 100644 config/kernel-make-request-fn.m4
 delete mode 100644 config/kernel-mk-request-fn.m4
 rename config/{kernel-urange-sleep.m4 => kernel-usleep_range.m4} (60%)

Index: zfs-linux-0.8.2/Makefile.am
===================================================================
--- zfs-linux-0.8.2.orig/Makefile.am
+++ zfs-linux-0.8.2/Makefile.am
@@ -40,7 +40,7 @@ gitrev:
 BUILT_SOURCES = gitrev
 
 distclean-local::
-	-$(RM) -R autom4te*.cache
+	-$(RM) -R autom4te*.cache build
 	-find . \( -name SCCS -o -name BitKeeper -o -name .svn -o -name CVS \
 		-o -name .pc -o -name .hg -o -name .git \) -prune -o \
 		\( -name '*.orig' -o -name '*.rej' -o -name '*~' \
@@ -87,8 +87,8 @@ commitcheck:
 	fi
 
 cstyle:
-	@find ${top_srcdir} -name '*.[hc]' ! -name 'zfs_config.*' \
-		! -name '*.mod.c' -type f \
+	@find ${top_srcdir} -name build -prune -o -name '*.[hc]' \
+		! -name 'zfs_config.*' ! -name '*.mod.c' -type f \
 		-exec ${top_srcdir}/scripts/cstyle.pl -cpP {} \+
 
 shellcheck:
Index: zfs-linux-0.8.2/config/iconv.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/iconv.m4
+++ zfs-linux-0.8.2/config/iconv.m4
@@ -269,8 +269,7 @@ size_t iconv();
         [am_cv_proto_iconv_arg1="const"])
       am_cv_proto_iconv="extern size_t iconv (iconv_t cd, $am_cv_proto_iconv_arg1 char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);"])
     am_cv_proto_iconv=`echo "[$]am_cv_proto_iconv" | tr -s ' ' | sed -e 's/( /(/'`
-    AC_MSG_RESULT([
-         $am_cv_proto_iconv])
+    AC_MSG_RESULT([$am_cv_proto_iconv])
   else
     dnl When compiling GNU libiconv on a system that does not have iconv yet,
     dnl pick the POSIX compliant declaration without 'const'.
Index: zfs-linux-0.8.2/config/kernel-access-ok-type.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-access-ok-type.m4
+++ zfs-linux-0.8.2/config/kernel-access-ok-type.m4
@@ -4,17 +4,23 @@ dnl #
 dnl # - access_ok(type, addr, size)
 dnl # + access_ok(addr, size)
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_ACCESS_OK_TYPE], [
-	AC_MSG_CHECKING([whether access_ok() has 'type' parameter])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_ACCESS_OK_TYPE], [
+	ZFS_LINUX_TEST_SRC([access_ok_type], [
 		#include <linux/uaccess.h>
 	],[
-		const void __user __attribute__((unused)) *addr = (void *) 0xdeadbeef;
+		const void __user __attribute__((unused)) *addr =
+		    (void *) 0xdeadbeef;
 		unsigned long __attribute__((unused)) size = 1;
 		int error __attribute__((unused)) = access_ok(0, addr, size);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_ACCESS_OK_TYPE], [
+	AC_MSG_CHECKING([whether access_ok() has 'type' parameter])
+	ZFS_LINUX_TEST_RESULT([access_ok_type], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_ACCESS_OK_TYPE, 1, [kernel has access_ok with 'type' parameter])
+		AC_DEFINE(HAVE_ACCESS_OK_TYPE, 1,
+		    [kernel has access_ok with 'type' parameter])
 	],[
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-acl.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-acl.m4
+++ zfs-linux-0.8.2/config/kernel-acl.m4
@@ -3,32 +3,26 @@ dnl # Check if posix_acl_release can be
 dnl # module.  The is_owner_or_cap macro was replaced by
 dnl # inode_owner_or_capable
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_POSIX_ACL_RELEASE], [
-	AC_MSG_CHECKING([whether posix_acl_release() is available])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_POSIX_ACL_RELEASE], [
+	ZFS_LINUX_TEST_SRC([posix_acl_release], [
 		#include <linux/cred.h>
 		#include <linux/fs.h>
 		#include <linux/posix_acl.h>
-	],[
-		struct posix_acl* tmp = posix_acl_alloc(1, 0);
+	], [
+		struct posix_acl *tmp = posix_acl_alloc(1, 0);
 		posix_acl_release(tmp);
-	],[
+	], [], [$ZFS_META_LICENSE])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_POSIX_ACL_RELEASE], [
+	AC_MSG_CHECKING([whether posix_acl_release() is available])
+	ZFS_LINUX_TEST_RESULT([posix_acl_release], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_POSIX_ACL_RELEASE, 1,
 		    [posix_acl_release() is available])
 
 		AC_MSG_CHECKING([whether posix_acl_release() is GPL-only])
-		ZFS_LINUX_TRY_COMPILE([
-			#include <linux/module.h>
-			#include <linux/cred.h>
-			#include <linux/fs.h>
-			#include <linux/posix_acl.h>
-
-			MODULE_LICENSE("$ZFS_META_LICENSE");
-		],[
-			struct posix_acl* tmp = posix_acl_alloc(1, 0);
-			posix_acl_release(tmp);
-		],[
+		ZFS_LINUX_TEST_RESULT([posix_acl_release_license], [
 			AC_MSG_RESULT(no)
 		],[
 			AC_MSG_RESULT(yes)
@@ -46,24 +40,25 @@ dnl # set_cached_acl() and forget_cached
 dnl # EXPORT_SYMBOL. In the former case, they may not be usable because of
 dnl # posix_acl_release. In the latter case, we can always use them.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_SET_CACHED_ACL_USABLE], [
-	AC_MSG_CHECKING([whether set_cached_acl() is usable])
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/module.h>
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SET_CACHED_ACL_USABLE], [
+	ZFS_LINUX_TEST_SRC([set_cached_acl], [
 		#include <linux/cred.h>
 		#include <linux/fs.h>
 		#include <linux/posix_acl.h>
-
-		MODULE_LICENSE("$ZFS_META_LICENSE");
-	],[
+	], [
 		struct inode *ip = NULL;
 		struct posix_acl *acl = posix_acl_alloc(1, 0);
 		set_cached_acl(ip, ACL_TYPE_ACCESS, acl);
 		forget_cached_acl(ip, ACL_TYPE_ACCESS);
-	],[
+	], [], [$ZFS_META_LICENSE])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SET_CACHED_ACL_USABLE], [
+	AC_MSG_CHECKING([whether set_cached_acl() is usable])
+	ZFS_LINUX_TEST_RESULT([set_cached_acl_license], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_SET_CACHED_ACL_USABLE, 1,
-		    [posix_acl_release() is usable])
+		    [set_cached_acl() is usable])
 	],[
 		AC_MSG_RESULT(no)
 	])
@@ -77,14 +72,25 @@ dnl #
 dnl # 3.14 API change,
 dnl # posix_acl_chmod() is changed to __posix_acl_chmod()
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_POSIX_ACL_CHMOD], [
-	AC_MSG_CHECKING([whether posix_acl_chmod exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_POSIX_ACL_CHMOD], [
+	ZFS_LINUX_TEST_SRC([posix_acl_chmod], [
 		#include <linux/fs.h>
 		#include <linux/posix_acl.h>
 	],[
 		posix_acl_chmod(NULL, 0, 0)
+	])
+
+	ZFS_LINUX_TEST_SRC([__posix_acl_chmod], [
+		#include <linux/fs.h>
+		#include <linux/posix_acl.h>
 	],[
+		__posix_acl_chmod(NULL, 0, 0)
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_POSIX_ACL_CHMOD], [
+	AC_MSG_CHECKING([whether posix_acl_chmod exists])
+	ZFS_LINUX_TEST_RESULT([posix_acl_chmod], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_POSIX_ACL_CHMOD, 1, [posix_acl_chmod() exists])
 	],[
@@ -92,14 +98,10 @@ AC_DEFUN([ZFS_AC_KERNEL_POSIX_ACL_CHMOD]
 	])
 
 	AC_MSG_CHECKING([whether __posix_acl_chmod exists])
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/fs.h>
-		#include <linux/posix_acl.h>
-	],[
-		__posix_acl_chmod(NULL, 0, 0)
-	],[
+	ZFS_LINUX_TEST_RESULT([__posix_acl_chmod], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE___POSIX_ACL_CHMOD, 1, [__posix_acl_chmod() exists])
+		AC_DEFINE(HAVE___POSIX_ACL_CHMOD, 1,
+		    [__posix_acl_chmod() exists])
 	],[
 		AC_MSG_RESULT(no)
 	])
@@ -109,18 +111,22 @@ dnl #
 dnl # 3.1 API change,
 dnl # posix_acl_equiv_mode now wants an umode_t* instead of a mode_t*
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_POSIX_ACL_EQUIV_MODE_WANTS_UMODE_T], [
-	AC_MSG_CHECKING([whether posix_acl_equiv_mode() wants umode_t])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_POSIX_ACL_EQUIV_MODE_WANTS_UMODE_T], [
+	ZFS_LINUX_TEST_SRC([posix_acl_equiv_mode], [
 		#include <linux/fs.h>
 		#include <linux/posix_acl.h>
 	],[
 		umode_t tmp;
 		posix_acl_equiv_mode(NULL,&tmp);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_POSIX_ACL_EQUIV_MODE_WANTS_UMODE_T], [
+	AC_MSG_CHECKING([whether posix_acl_equiv_mode() wants umode_t])
+	ZFS_LINUX_TEST_RESULT([posix_acl_equiv_mode], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_POSIX_ACL_EQUIV_MODE_UMODE_T, 1,
-		    [ posix_acl_equiv_mode wants umode_t*])
+		    [posix_acl_equiv_mode wants umode_t*])
 	],[
 		AC_MSG_RESULT(no)
 	])
@@ -130,9 +136,8 @@ dnl #
 dnl # 4.8 API change,
 dnl # The function posix_acl_valid now must be passed a namespace.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_POSIX_ACL_VALID_WITH_NS], [
-	AC_MSG_CHECKING([whether posix_acl_valid() wants user namespace])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_POSIX_ACL_VALID_WITH_NS], [
+	ZFS_LINUX_TEST_SRC([posix_acl_valid_with_ns], [
 		#include <linux/fs.h>
 		#include <linux/posix_acl.h>
 	],[
@@ -141,7 +146,12 @@ AC_DEFUN([ZFS_AC_KERNEL_POSIX_ACL_VALID_
 		int error;
 
 		error = posix_acl_valid(user_ns, acl);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_POSIX_ACL_VALID_WITH_NS], [
+	AC_MSG_CHECKING([whether posix_acl_valid() wants user namespace])
+	ZFS_LINUX_TEST_RESULT([posix_acl_valid_with_ns], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_POSIX_ACL_VALID_WITH_NS, 1,
 		    [posix_acl_valid() wants user namespace])
@@ -155,9 +165,8 @@ dnl # 2.6.27 API change,
 dnl # Check if inode_operations contains the function permission
 dnl # and expects the nameidata structure to have been removed.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS_PERMISSION], [
-	AC_MSG_CHECKING([whether iops->permission() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_INODE_OPERATIONS_PERMISSION], [
+	ZFS_LINUX_TEST_SRC([inode_operations_permission], [
 		#include <linux/fs.h>
 
 		int permission_fn(struct inode *inode, int mask) { return 0; }
@@ -166,8 +175,12 @@ AC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS
 		    iops __attribute__ ((unused)) = {
 			.permission = permission_fn,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS_PERMISSION], [
+	AC_MSG_CHECKING([whether iops->permission() exists])
+	ZFS_LINUX_TEST_RESULT([inode_operations_permission], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_PERMISSION, 1, [iops->permission() exists])
 	],[
@@ -180,9 +193,8 @@ dnl # 2.6.26 API change,
 dnl # Check if inode_operations contains the function permission
 dnl # and expects the nameidata structure to be passed.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS_PERMISSION_WITH_NAMEIDATA], [
-	AC_MSG_CHECKING([whether iops->permission() wants nameidata])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_INODE_OPERATIONS_PERMISSION_WITH_NAMEIDATA], [
+	ZFS_LINUX_TEST_SRC([inode_operations_permission_with_nameidata], [
 		#include <linux/fs.h>
 		#include <linux/sched.h>
 
@@ -193,8 +205,12 @@ AC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS
 		    iops __attribute__ ((unused)) = {
 			.permission = permission_fn,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS_PERMISSION_WITH_NAMEIDATA], [
+	AC_MSG_CHECKING([whether iops->permission() wants nameidata])
+	ZFS_LINUX_TEST_RESULT([inode_operations_permission_with_nameidata], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_PERMISSION, 1, [iops->permission() exists])
 		AC_DEFINE(HAVE_PERMISSION_WITH_NAMEIDATA, 1,
@@ -208,9 +224,8 @@ dnl #
 dnl # 2.6.32 API change,
 dnl # Check if inode_operations contains the function check_acl
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS_CHECK_ACL], [
-	AC_MSG_CHECKING([whether iops->check_acl() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_INODE_OPERATIONS_CHECK_ACL], [
+	ZFS_LINUX_TEST_SRC([inode_operations_check_acl], [
 		#include <linux/fs.h>
 
 		int check_acl_fn(struct inode *inode, int mask) { return 0; }
@@ -219,8 +234,12 @@ AC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS
 		    iops __attribute__ ((unused)) = {
 			.check_acl = check_acl_fn,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS_CHECK_ACL], [
+	AC_MSG_CHECKING([whether iops->check_acl() exists])
+	ZFS_LINUX_TEST_RESULT([inode_operations_check_acl], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_CHECK_ACL, 1, [iops->check_acl() exists])
 	],[
@@ -232,9 +251,8 @@ dnl #
 dnl # 2.6.38 API change,
 dnl # The function check_acl gained a new parameter: flags
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS_CHECK_ACL_WITH_FLAGS], [
-	AC_MSG_CHECKING([whether iops->check_acl() wants flags])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_INODE_OPERATIONS_CHECK_ACL_WITH_FLAGS], [
+	ZFS_LINUX_TEST_SRC([inode_operations_check_acl_with_flags], [
 		#include <linux/fs.h>
 
 		int check_acl_fn(struct inode *inode, int mask,
@@ -244,8 +262,12 @@ AC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS
 		    iops __attribute__ ((unused)) = {
 			.check_acl = check_acl_fn,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS_CHECK_ACL_WITH_FLAGS], [
+	AC_MSG_CHECKING([whether iops->check_acl() wants flags])
+	ZFS_LINUX_TEST_RESULT([inode_operations_check_acl_with_flags], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_CHECK_ACL, 1, [iops->check_acl() exists])
 		AC_DEFINE(HAVE_CHECK_ACL_WITH_FLAGS, 1,
@@ -259,9 +281,8 @@ dnl #
 dnl # 3.1 API change,
 dnl # Check if inode_operations contains the function get_acl
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS_GET_ACL], [
-	AC_MSG_CHECKING([whether iops->get_acl() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_INODE_OPERATIONS_GET_ACL], [
+	ZFS_LINUX_TEST_SRC([inode_operations_get_acl], [
 		#include <linux/fs.h>
 
 		struct posix_acl *get_acl_fn(struct inode *inode, int type)
@@ -271,8 +292,12 @@ AC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS
 		    iops __attribute__ ((unused)) = {
 			.get_acl = get_acl_fn,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS_GET_ACL], [
+	AC_MSG_CHECKING([whether iops->get_acl() exists])
+	ZFS_LINUX_TEST_RESULT([inode_operations_get_acl], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_GET_ACL, 1, [iops->get_acl() exists])
 	],[
@@ -284,20 +309,23 @@ dnl #
 dnl # 3.14 API change,
 dnl # Check if inode_operations contains the function set_acl
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS_SET_ACL], [
-	AC_MSG_CHECKING([whether iops->set_acl() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_INODE_OPERATIONS_SET_ACL], [
+	ZFS_LINUX_TEST_SRC([inode_operations_set_acl], [
 		#include <linux/fs.h>
 
-		int set_acl_fn(struct inode *inode, struct posix_acl *acl, int type)
-		    { return 0; }
+		int set_acl_fn(struct inode *inode, struct posix_acl *acl,
+		    int type) { return 0; }
 
 		static const struct inode_operations
 		    iops __attribute__ ((unused)) = {
 			.set_acl = set_acl_fn,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS_SET_ACL], [
+	AC_MSG_CHECKING([whether iops->set_acl() exists])
+	ZFS_LINUX_TEST_RESULT([inode_operations_set_acl], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_SET_ACL, 1, [iops->set_acl() exists])
 	],[
@@ -311,16 +339,79 @@ dnl # The kernel get_acl will now check
 dnl # do set_cached_acl after that, so i_op->get_acl don't need to do that
 dnl # anymore.
 dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_GET_ACL_HANDLE_CACHE], [
+	ZFS_LINUX_TEST_SRC([get_acl_handle_cache], [
+		#include <linux/fs.h>
+	],[
+		void *sentinel __attribute__ ((unused)) =
+		    uncached_acl_sentinel(NULL);
+	])
+])
+
 AC_DEFUN([ZFS_AC_KERNEL_GET_ACL_HANDLE_CACHE], [
 	AC_MSG_CHECKING([whether uncached_acl_sentinel() exists])
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/fs.h>
+	ZFS_LINUX_TEST_RESULT([get_acl_handle_cache], [
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_KERNEL_GET_ACL_HANDLE_CACHE, 1,
+		    [uncached_acl_sentinel() exists])
 	],[
-		void *sentinel __attribute__ ((unused)) = uncached_acl_sentinel(NULL);
+		AC_MSG_RESULT(no)
+	])
+])
+
+dnl #
+dnl # 4.16 kernel: check if struct posix_acl acl.a_refcount is a refcount_t.
+dnl # It's an atomic_t on older kernels.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_ACL_HAS_REFCOUNT], [
+	ZFS_LINUX_TEST_SRC([acl_refcount], [
+		#include <linux/backing-dev.h>
+		#include <linux/refcount.h>
+		#include <linux/posix_acl.h>
 	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_KERNEL_GET_ACL_HANDLE_CACHE, 1, [uncached_acl_sentinel() exists])
+		struct posix_acl acl;
+		refcount_t *r __attribute__ ((unused)) = &acl.a_refcount;
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_ACL_HAS_REFCOUNT], [
+	AC_MSG_CHECKING([whether posix_acl has refcount_t])
+	ZFS_LINUX_TEST_RESULT([acl_refcount], [
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_ACL_REFCOUNT, 1, [posix_acl has refcount_t])
 	],[
 		AC_MSG_RESULT(no)
 	])
 ])
+
+AC_DEFUN([ZFS_AC_KERNEL_SRC_ACL], [
+	ZFS_AC_KERNEL_SRC_POSIX_ACL_RELEASE
+	ZFS_AC_KERNEL_SRC_SET_CACHED_ACL_USABLE
+	ZFS_AC_KERNEL_SRC_POSIX_ACL_CHMOD
+	ZFS_AC_KERNEL_SRC_POSIX_ACL_EQUIV_MODE_WANTS_UMODE_T
+	ZFS_AC_KERNEL_SRC_POSIX_ACL_VALID_WITH_NS
+	ZFS_AC_KERNEL_SRC_INODE_OPERATIONS_PERMISSION
+	ZFS_AC_KERNEL_SRC_INODE_OPERATIONS_PERMISSION_WITH_NAMEIDATA
+	ZFS_AC_KERNEL_SRC_INODE_OPERATIONS_CHECK_ACL
+	ZFS_AC_KERNEL_SRC_INODE_OPERATIONS_CHECK_ACL_WITH_FLAGS
+	ZFS_AC_KERNEL_SRC_INODE_OPERATIONS_GET_ACL
+	ZFS_AC_KERNEL_SRC_INODE_OPERATIONS_SET_ACL
+	ZFS_AC_KERNEL_SRC_GET_ACL_HANDLE_CACHE
+	ZFS_AC_KERNEL_SRC_ACL_HAS_REFCOUNT
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_ACL], [
+	ZFS_AC_KERNEL_POSIX_ACL_RELEASE
+	ZFS_AC_KERNEL_SET_CACHED_ACL_USABLE
+	ZFS_AC_KERNEL_POSIX_ACL_CHMOD
+	ZFS_AC_KERNEL_POSIX_ACL_EQUIV_MODE_WANTS_UMODE_T
+	ZFS_AC_KERNEL_POSIX_ACL_VALID_WITH_NS
+	ZFS_AC_KERNEL_INODE_OPERATIONS_PERMISSION
+	ZFS_AC_KERNEL_INODE_OPERATIONS_PERMISSION_WITH_NAMEIDATA
+	ZFS_AC_KERNEL_INODE_OPERATIONS_CHECK_ACL
+	ZFS_AC_KERNEL_INODE_OPERATIONS_CHECK_ACL_WITH_FLAGS
+	ZFS_AC_KERNEL_INODE_OPERATIONS_GET_ACL
+	ZFS_AC_KERNEL_INODE_OPERATIONS_SET_ACL
+	ZFS_AC_KERNEL_GET_ACL_HANDLE_CACHE
+	ZFS_AC_KERNEL_ACL_HAS_REFCOUNT
+])
Index: zfs-linux-0.8.2/config/kernel-aio-fsync.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-aio-fsync.m4
+++ zfs-linux-0.8.2/config/kernel-aio-fsync.m4
@@ -1,21 +1,23 @@
 dnl #
 dnl # Linux 4.9-rc5+ ABI, removal of the .aio_fsync field
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_AIO_FSYNC], [
-	AC_MSG_CHECKING([whether fops->aio_fsync() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_AIO_FSYNC], [
+	ZFS_LINUX_TEST_SRC([aio_fsync], [
 		#include <linux/fs.h>
 
 		static const struct file_operations
 		    fops __attribute__ ((unused)) = {
 			.aio_fsync = NULL,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_AIO_FSYNC], [
+	AC_MSG_CHECKING([whether fops->aio_fsync() exists])
+	ZFS_LINUX_TEST_RESULT([aio_fsync], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_FILE_AIO_FSYNC, 1, [fops->aio_fsync() exists])
 	],[
 		AC_MSG_RESULT(no)
 	])
 ])
-
Index: zfs-linux-0.8.2/config/kernel-automount.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-automount.m4
+++ zfs-linux-0.8.2/config/kernel-automount.m4
@@ -5,16 +5,19 @@ dnl # solution to handling automounts.
 dnl # which required automount support would abuse the follow_link()
 dnl # operation on directories for this purpose.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_AUTOMOUNT], [
-	AC_MSG_CHECKING([whether dops->d_automount() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_AUTOMOUNT], [
+	ZFS_LINUX_TEST_SRC([dentry_operations_d_automount], [
 		#include <linux/dcache.h>
 		struct vfsmount *d_automount(struct path *p) { return NULL; }
 		struct dentry_operations dops __attribute__ ((unused)) = {
 			.d_automount = d_automount,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_AUTOMOUNT], [
+	AC_MSG_CHECKING([whether dops->d_automount() exists])
+	ZFS_LINUX_TEST_RESULT([dentry_operations_d_automount], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_AUTOMOUNT, 1, [dops->automount() exists])
 	],[
Index: zfs-linux-0.8.2/config/kernel-bdev-logical-size.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-bdev-logical-size.m4
+++ zfs-linux-0.8.2/config/kernel-bdev-logical-size.m4
@@ -5,21 +5,22 @@ dnl # it has been true for a while that
 dnl # between physical sector size and logical block size this change makes
 dnl # it explicit.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BDEV_LOGICAL_BLOCK_SIZE], [
-	AC_MSG_CHECKING([whether bdev_logical_block_size() is available])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="${NO_UNUSED_BUT_SET_VARIABLE}"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BDEV_LOGICAL_BLOCK_SIZE], [
+	ZFS_LINUX_TEST_SRC([bdev_logical_block_size], [
 		#include <linux/blkdev.h>
 	],[
 		struct block_device *bdev = NULL;
 		bdev_logical_block_size(bdev);
-	],[
+	], [$NO_UNUSED_BUT_SET_VARIABLE])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BDEV_LOGICAL_BLOCK_SIZE], [
+	AC_MSG_CHECKING([whether bdev_logical_block_size() is available])
+	ZFS_LINUX_TEST_RESULT([bdev_logical_block_size], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BDEV_LOGICAL_BLOCK_SIZE, 1,
-		          [bdev_logical_block_size() is available])
+		    [bdev_logical_block_size() is available])
 	],[
 		AC_MSG_RESULT(no)
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
 ])
Index: zfs-linux-0.8.2/config/kernel-bdev-physical-size.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-bdev-physical-size.m4
+++ zfs-linux-0.8.2/config/kernel-bdev-physical-size.m4
@@ -19,21 +19,22 @@ dnl #
 dnl # Unfortunately, this interface isn't entirely reliable because
 dnl # drives are sometimes known to misreport this value.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BDEV_PHYSICAL_BLOCK_SIZE], [
-	AC_MSG_CHECKING([whether bdev_physical_block_size() is available])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="${NO_UNUSED_BUT_SET_VARIABLE}"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BDEV_PHYSICAL_BLOCK_SIZE], [
+	ZFS_LINUX_TEST_SRC([bdev_physical_block_size], [
 		#include <linux/blkdev.h>
 	],[
 		struct block_device *bdev = NULL;
 		bdev_physical_block_size(bdev);
-	],[
+	], [$NO_UNUSED_BUT_SET_VARIABLE])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BDEV_PHYSICAL_BLOCK_SIZE], [
+	AC_MSG_CHECKING([whether bdev_physical_block_size() is available])
+	ZFS_LINUX_TEST_RESULT([bdev_physical_block_size], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BDEV_PHYSICAL_BLOCK_SIZE, 1,
-		          [bdev_physical_block_size() is available])
+		    [bdev_physical_block_size() is available])
 	],[
 		AC_MSG_RESULT(no)
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
 ])
Index: zfs-linux-0.8.2/config/kernel-bdi.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-bdi.m4
+++ zfs-linux-0.8.2/config/kernel-bdi.m4
@@ -1,55 +1,81 @@
 dnl #
-dnl # 2.6.32 - 2.6.33, bdi_setup_and_register() is not exported.
-dnl # 2.6.34 - 3.19, bdi_setup_and_register() takes 3 arguments.
-dnl # 4.0 - 4.11, bdi_setup_and_register() takes 2 arguments.
-dnl # 4.12 - x.y, super_setup_bdi_name() new interface.
+dnl # Check available BDI interfaces.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BDI], [
-	AC_MSG_CHECKING([whether super_setup_bdi_name() exists])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BDI], [
+	ZFS_LINUX_TEST_SRC([super_setup_bdi_name], [
 		#include <linux/fs.h>
 		struct super_block sb;
 	], [
 		char *name = "bdi";
 		atomic_long_t zfs_bdi_seq;
 		int error __attribute__((unused)) =
-		    super_setup_bdi_name(&sb, "%.28s-%ld", name, atomic_long_inc_return(&zfs_bdi_seq));
-	], [super_setup_bdi_name], [fs/super.c], [
+		    super_setup_bdi_name(&sb, "%.28s-%ld", name,
+		    atomic_long_inc_return(&zfs_bdi_seq));
+	])
+
+	ZFS_LINUX_TEST_SRC([bdi_setup_and_register], [
+		#include <linux/backing-dev.h>
+		struct backing_dev_info bdi;
+	], [
+		char *name = "bdi";
+		int error __attribute__((unused)) =
+		    bdi_setup_and_register(&bdi, name);
+	])
+
+	ZFS_LINUX_TEST_SRC([bdi_setup_and_register_3args], [
+		#include <linux/backing-dev.h>
+		struct backing_dev_info bdi;
+	], [
+		char *name = "bdi";
+		unsigned int cap = BDI_CAP_MAP_COPY;
+		int error __attribute__((unused)) =
+		    bdi_setup_and_register(&bdi, name, cap);
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BDI], [
+	dnl #
+	dnl # 4.12, super_setup_bdi_name() introduced.
+	dnl #
+	AC_MSG_CHECKING([whether super_setup_bdi_name() exists])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([super_setup_bdi_name],
+	    [super_setup_bdi_name], [fs/super.c], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_SUPER_SETUP_BDI_NAME, 1,
                     [super_setup_bdi_name() exits])
 	], [
 		AC_MSG_RESULT(no)
+
+		dnl #
+		dnl # 4.0 - 4.11, bdi_setup_and_register() takes 2 arguments.
+		dnl #
 		AC_MSG_CHECKING(
 		    [whether bdi_setup_and_register() wants 2 args])
-		ZFS_LINUX_TRY_COMPILE_SYMBOL([
-			#include <linux/backing-dev.h>
-			struct backing_dev_info bdi;
-		], [
-			char *name = "bdi";
-			int error __attribute__((unused)) =
-			    bdi_setup_and_register(&bdi, name);
-		], [bdi_setup_and_register], [mm/backing-dev.c], [
+		ZFS_LINUX_TEST_RESULT_SYMBOL([bdi_setup_and_register],
+		    [bdi_setup_and_register], [mm/backing-dev.c], [
 			AC_MSG_RESULT(yes)
 			AC_DEFINE(HAVE_2ARGS_BDI_SETUP_AND_REGISTER, 1,
 			    [bdi_setup_and_register() wants 2 args])
 		], [
 			AC_MSG_RESULT(no)
+
+			dnl #
+			dnl # 2.6.34 - 3.19, bdi_setup_and_register()
+			dnl # takes 3 arguments.
+			dnl #
 			AC_MSG_CHECKING(
 			    [whether bdi_setup_and_register() wants 3 args])
-			ZFS_LINUX_TRY_COMPILE_SYMBOL([
-				#include <linux/backing-dev.h>
-				struct backing_dev_info bdi;
-			], [
-				char *name = "bdi";
-				unsigned int cap = BDI_CAP_MAP_COPY;
-				int error __attribute__((unused)) =
-				    bdi_setup_and_register(&bdi, name, cap);
-			], [bdi_setup_and_register], [mm/backing-dev.c], [
+			ZFS_LINUX_TEST_RESULT_SYMBOL(
+			    [bdi_setup_and_register_3args],
+			    [bdi_setup_and_register], [mm/backing-dev.c], [
 				AC_MSG_RESULT(yes)
 				AC_DEFINE(HAVE_3ARGS_BDI_SETUP_AND_REGISTER, 1,
 				    [bdi_setup_and_register() wants 3 args])
 			], [
+				dnl #
+				dnl # 2.6.32 - 2.6.33, bdi_setup_and_register()
+				dnl # is not exported.
+				dnl #
 				AC_MSG_RESULT(no)
 			])
 		])
Index: zfs-linux-0.8.2/config/kernel-bio-bvec-iter.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-bio-bvec-iter.m4
+++ zfs-linux-0.8.2/config/kernel-bio-bvec-iter.m4
@@ -3,18 +3,21 @@ dnl # 3.14 API change,
 dnl # Immutable biovecs. A number of fields of struct bio are moved to
 dnl # struct bvec_iter.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BIO_BVEC_ITER], [
-	AC_MSG_CHECKING([whether bio has bi_iter])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BIO_BVEC_ITER], [
+	ZFS_LINUX_TEST_SRC([bio_bvec_iter], [
 		#include <linux/bio.h>
 	],[
 		struct bio bio;
 		bio.bi_iter.bi_sector = 0;
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BIO_BVEC_ITER], [
+	AC_MSG_CHECKING([whether bio has bi_iter])
+	ZFS_LINUX_TEST_RESULT([bio_bvec_iter], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BIO_BVEC_ITER, 1, [bio has bi_iter])
 	],[
 		AC_MSG_RESULT(no)
 	])
 ])
-
Index: zfs-linux-0.8.2/config/kernel-bio-end-io-t-args.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-bio-end-io-t-args.m4
+++ zfs-linux-0.8.2/config/kernel-bio-end-io-t-args.m4
@@ -5,20 +5,21 @@ dnl # bio->bi_error. This also replaces
 dnl # Introduced by torvalds/linux@4246a0b63bd8f56a1469b12eafeb875b1041a451
 dnl # ("block: add a bi_error field to struct bio").
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BIO_END_IO_T_ARGS], [
-	AC_MSG_CHECKING([whether bio_end_io_t wants 1 arg])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BIO_END_IO_T_ARGS], [
+	ZFS_LINUX_TEST_SRC([bio_end_io_t_args], [
 		#include <linux/bio.h>
-
 		void wanted_end_io(struct bio *bio) { return; }
-
 		bio_end_io_t *end_io __attribute__ ((unused)) = wanted_end_io;
-	],[
-	],[
+	], [])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BIO_END_IO_T_ARGS], [
+	AC_MSG_CHECKING([whether bio_end_io_t wants 1 arg])
+	ZFS_LINUX_TEST_RESULT([bio_end_io_t_args], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_1ARG_BIO_END_IO_T, 1,
-			  [bio_end_io_t wants 1 arg])
-	],[
+		    [bio_end_io_t wants 1 arg])
+	], [
 		AC_MSG_RESULT(no)
 	])
 ])
@@ -28,16 +29,19 @@ dnl # 4.13 API change
 dnl # The bio->bi_error field was replaced with bio->bi_status which is an
 dnl # enum which describes all possible error types.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BIO_BI_STATUS], [
-	AC_MSG_CHECKING([whether bio->bi_status exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BIO_BI_STATUS], [
+	ZFS_LINUX_TEST_SRC([bio_bi_status], [
 		#include <linux/bio.h>
-	],[
+	], [
 		struct bio bio __attribute__ ((unused));
 		blk_status_t status __attribute__ ((unused)) = BLK_STS_OK;
-
 		bio.bi_status = status;
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BIO_BI_STATUS], [
+	AC_MSG_CHECKING([whether bio->bi_status exists])
+	ZFS_LINUX_TEST_RESULT([bio_bi_status], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BIO_BI_STATUS, 1, [bio->bi_status exists])
 	],[
Index: zfs-linux-0.8.2/config/kernel-bio-failfast.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-bio-failfast.m4
+++ zfs-linux-0.8.2/config/kernel-bio-failfast.m4
@@ -3,37 +3,54 @@ dnl # Preferred interface for setting FA
 dnl #   2.6.28-2.6.35: BIO_RW_FAILFAST_{DEV|TRANSPORT|DRIVER}
 dnl #       >= 2.6.36: REQ_FAILFAST_{DEV|TRANSPORT|DRIVER}
 dnl #
-
-AC_DEFUN([ZFS_AC_KERNEL_BIO_FAILFAST_DTD], [
-	AC_MSG_CHECKING([whether BIO_RW_FAILFAST_* are defined])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BIO_FAILFAST_DTD], [
+	ZFS_LINUX_TEST_SRC([bio_failfast_dtd], [
 		#include <linux/bio.h>
 	],[
 		int flags __attribute__ ((unused));
 		flags = ((1 << BIO_RW_FAILFAST_DEV) |
 			 (1 << BIO_RW_FAILFAST_TRANSPORT) |
 			 (1 << BIO_RW_FAILFAST_DRIVER));
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BIO_FAILFAST_DTD], [
+	AC_MSG_CHECKING([whether BIO_RW_FAILFAST_* are defined])
+	ZFS_LINUX_TEST_RESULT([bio_failfast_dtd], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BIO_RW_FAILFAST_DTD, 1,
-		          [BIO_RW_FAILFAST_* are defined])
+		    [BIO_RW_FAILFAST_* are defined])
 	],[
 		AC_MSG_RESULT(no)
 	])
 ])
 
-AC_DEFUN([ZFS_AC_KERNEL_REQ_FAILFAST_MASK], [
-	AC_MSG_CHECKING([whether REQ_FAILFAST_MASK is defined])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_REQ_FAILFAST_MASK], [
+	ZFS_LINUX_TEST_SRC([bio_failfast_mask], [
 		#include <linux/bio.h>
 	],[
 		int flags __attribute__ ((unused));
 		flags = REQ_FAILFAST_MASK;
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_REQ_FAILFAST_MASK], [
+	AC_MSG_CHECKING([whether REQ_FAILFAST_MASK is defined])
+	ZFS_LINUX_TEST_RESULT([bio_failfast_mask], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_REQ_FAILFAST_MASK, 1,
-		          [REQ_FAILFAST_MASK is defined])
+		    [REQ_FAILFAST_MASK is defined])
 	],[
 		AC_MSG_RESULT(no)
 	])
 ])
+
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BIO_FAILFAST], [
+	ZFS_AC_KERNEL_SRC_BIO_FAILFAST_DTD
+	ZFS_AC_KERNEL_SRC_REQ_FAILFAST_MASK
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BIO_FAILFAST], [
+	ZFS_AC_KERNEL_BIO_FAILFAST_DTD
+	ZFS_AC_KERNEL_REQ_FAILFAST_MASK
+])
Index: zfs-linux-0.8.2/config/kernel-bio-op.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-bio-op.m4
+++ zfs-linux-0.8.2/config/kernel-bio-op.m4
@@ -5,13 +5,43 @@ dnl # The bio_op() helper was introduced
 dnl # checking the bio->bi_rw flags.  The following checks are used to
 dnl # detect if a specific operation is supported.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_REQ_OP_DISCARD], [
-	AC_MSG_CHECKING([whether REQ_OP_DISCARD is defined])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BIO_OPS], [
+	ZFS_LINUX_TEST_SRC([req_op_discard], [
 		#include <linux/blk_types.h>
 	],[
 		int op __attribute__ ((unused)) = REQ_OP_DISCARD;
+	])
+
+	ZFS_LINUX_TEST_SRC([req_op_secure_erase], [
+		#include <linux/blk_types.h>
 	],[
+		int op __attribute__ ((unused)) = REQ_OP_SECURE_ERASE;
+	])
+
+	ZFS_LINUX_TEST_SRC([req_op_flush], [
+		#include <linux/blk_types.h>
+	],[
+		int op __attribute__ ((unused)) = REQ_OP_FLUSH;
+	])
+
+	ZFS_LINUX_TEST_SRC([bio_bi_opf], [
+		#include <linux/bio.h>
+	],[
+		struct bio bio __attribute__ ((unused));
+		bio.bi_opf = 0;
+	])
+
+	ZFS_LINUX_TEST_SRC([bio_set_op_attrs], [
+		#include <linux/bio.h>
+	],[
+		struct bio *bio __attribute__ ((unused)) = NULL;
+		bio_set_op_attrs(bio, 0, 0);
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_REQ_OP_DISCARD], [
+	AC_MSG_CHECKING([whether REQ_OP_DISCARD is defined])
+	ZFS_LINUX_TEST_RESULT([req_op_discard], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_REQ_OP_DISCARD, 1,
 		    [REQ_OP_DISCARD is defined])
@@ -22,11 +52,7 @@ AC_DEFUN([ZFS_AC_KERNEL_REQ_OP_DISCARD],
 
 AC_DEFUN([ZFS_AC_KERNEL_REQ_OP_SECURE_ERASE], [
 	AC_MSG_CHECKING([whether REQ_OP_SECURE_ERASE is defined])
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/blk_types.h>
-	],[
-		int op __attribute__ ((unused)) = REQ_OP_SECURE_ERASE;
-	],[
+	ZFS_LINUX_TEST_RESULT([req_op_secure_erase], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_REQ_OP_SECURE_ERASE, 1,
 		    [REQ_OP_SECURE_ERASE is defined])
@@ -38,14 +64,9 @@ AC_DEFUN([ZFS_AC_KERNEL_REQ_OP_SECURE_ER
 
 AC_DEFUN([ZFS_AC_KERNEL_REQ_OP_FLUSH], [
 	AC_MSG_CHECKING([whether REQ_OP_FLUSH is defined])
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/blk_types.h>
-	],[
-		int op __attribute__ ((unused)) = REQ_OP_FLUSH;
-	],[
+	ZFS_LINUX_TEST_RESULT([req_op_flush], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_REQ_OP_FLUSH, 1,
-		    [REQ_OP_FLUSH is defined])
+		AC_DEFINE(HAVE_REQ_OP_FLUSH, 1, [REQ_OP_FLUSH is defined])
 	],[
 		AC_MSG_RESULT(no)
 	])
@@ -53,12 +74,7 @@ AC_DEFUN([ZFS_AC_KERNEL_REQ_OP_FLUSH], [
 
 AC_DEFUN([ZFS_AC_KERNEL_BIO_BI_OPF], [
 	AC_MSG_CHECKING([whether bio->bi_opf is defined])
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/bio.h>
-	],[
-		struct bio bio __attribute__ ((unused));
-		bio.bi_opf = 0;
-	],[
+	ZFS_LINUX_TEST_RESULT([bio_bi_opf], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BIO_BI_OPF, 1, [bio->bi_opf is defined])
 	],[
@@ -68,13 +84,7 @@ AC_DEFUN([ZFS_AC_KERNEL_BIO_BI_OPF], [
 
 AC_DEFUN([ZFS_AC_KERNEL_HAVE_BIO_SET_OP_ATTRS], [
 	AC_MSG_CHECKING([whether bio_set_op_attrs is available])
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/bio.h>
-	],[
-		struct bio *bio __attribute__ ((unused)) = NULL;
-
-		bio_set_op_attrs(bio, 0, 0);
-	],[
+	ZFS_LINUX_TEST_RESULT([bio_set_op_attrs], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BIO_SET_OP_ATTRS, 1,
 		    [bio_set_op_attrs is available])
@@ -82,3 +92,11 @@ AC_DEFUN([ZFS_AC_KERNEL_HAVE_BIO_SET_OP_
 		AC_MSG_RESULT(no)
 	])
 ])
+
+AC_DEFUN([ZFS_AC_KERNEL_BIO_OPS], [
+	ZFS_AC_KERNEL_REQ_OP_DISCARD
+	ZFS_AC_KERNEL_REQ_OP_SECURE_ERASE
+	ZFS_AC_KERNEL_REQ_OP_FLUSH
+	ZFS_AC_KERNEL_BIO_BI_OPF
+	ZFS_AC_KERNEL_HAVE_BIO_SET_OP_ATTRS
+])
Index: zfs-linux-0.8.2/config/kernel-bio-rw-barrier.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-bio-rw-barrier.m4
+++ zfs-linux-0.8.2/config/kernel-bio-rw-barrier.m4
@@ -3,20 +3,25 @@ dnl # Interface for issuing a discard bi
 dnl # 2.6.28-2.6.35: BIO_RW_BARRIER
 dnl # 2.6.36-3.x:    REQ_BARRIER
 dnl #
-
+dnl #
 dnl # Since REQ_BARRIER is a preprocessor definition, there is no need for an
 dnl # autotools check for it. Also, REQ_BARRIER existed in the request layer
 dnl # until torvalds/linux@7b6d91daee5cac6402186ff224c3af39d79f4a0e unified the
 dnl # request layer and bio layer flags, so it would be wrong to assume that
 dnl # the APIs are mutually exclusive contrary to the typical case.
-AC_DEFUN([ZFS_AC_KERNEL_BIO_RW_BARRIER], [
-	AC_MSG_CHECKING([whether BIO_RW_BARRIER is defined])
-	ZFS_LINUX_TRY_COMPILE([
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BIO_RW_BARRIER], [
+	ZFS_LINUX_TEST_SRC([bio_rw_barrier], [
 		#include <linux/bio.h>
 	],[
 		int flags __attribute__ ((unused));
 		flags = BIO_RW_BARRIER;
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BIO_RW_BARRIER], [
+	AC_MSG_CHECKING([whether BIO_RW_BARRIER is defined])
+	ZFS_LINUX_TEST_RESULT([bio_rw_barrier], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BIO_RW_BARRIER, 1, [BIO_RW_BARRIER is defined])
 	],[
Index: zfs-linux-0.8.2/config/kernel-bio-rw-discard.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-bio-rw-discard.m4
+++ zfs-linux-0.8.2/config/kernel-bio-rw-discard.m4
@@ -3,20 +3,25 @@ dnl # Interface for issuing a discard bi
 dnl # 2.6.28-2.6.35: BIO_RW_DISCARD
 dnl # 2.6.36-3.x:    REQ_DISCARD
 dnl #
-
+dnl #
 dnl # Since REQ_DISCARD is a preprocessor definition, there is no need for an
 dnl # autotools check for it. Also, REQ_DISCARD existed in the request layer
 dnl # until torvalds/linux@7b6d91daee5cac6402186ff224c3af39d79f4a0e unified the
 dnl # request layer and bio layer flags, so it would be wrong to assume that
 dnl # the APIs are mutually exclusive contrary to the typical case.
-AC_DEFUN([ZFS_AC_KERNEL_BIO_RW_DISCARD], [
-	AC_MSG_CHECKING([whether BIO_RW_DISCARD is defined])
-	ZFS_LINUX_TRY_COMPILE([
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BIO_RW_DISCARD], [
+	ZFS_LINUX_TEST_SRC([bio_rw_discard], [
 		#include <linux/bio.h>
 	],[
 		int flags __attribute__ ((unused));
 		flags = BIO_RW_DISCARD;
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BIO_RW_DISCARD], [
+	AC_MSG_CHECKING([whether BIO_RW_DISCARD is defined])
+	ZFS_LINUX_TEST_RESULT([bio_rw_discard], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BIO_RW_DISCARD, 1, [BIO_RW_DISCARD is defined])
 	],[
Index: zfs-linux-0.8.2/config/kernel-bio_set_dev.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-bio_set_dev.m4
+++ zfs-linux-0.8.2/config/kernel-bio_set_dev.m4
@@ -4,50 +4,37 @@ dnl #
 dnl # The bio_set_dev() helper macro was introduced as part of the transition
 dnl # to have struct gendisk in struct bio. 
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BIO_SET_DEV_MACRO], [
-	AC_MSG_CHECKING([whether bio_set_dev() exists])
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/bio.h>
-		#include <linux/fs.h>
-	],[
-		struct block_device *bdev = NULL;
-		struct bio *bio = NULL;
-		bio_set_dev(bio, bdev);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_BIO_SET_DEV, 1, [bio_set_dev() exists])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
 dnl # Linux 5.0 API,
 dnl #
 dnl # The bio_set_dev() helper macro was updated to internally depend on
 dnl # bio_associate_blkg() symbol which is exported GPL-only.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BIO_SET_DEV_GPL_ONLY], [
-	AC_MSG_CHECKING([whether bio_set_dev() is GPL-only])
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/module.h>
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BIO_SET_DEV], [
+	ZFS_LINUX_TEST_SRC([bio_set_dev], [
 		#include <linux/bio.h>
 		#include <linux/fs.h>
-		MODULE_LICENSE("$ZFS_META_LICENSE");
 	],[
 		struct block_device *bdev = NULL;
 		struct bio *bio = NULL;
 		bio_set_dev(bio, bdev);
-	],[
-		AC_MSG_RESULT(no)
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_BIO_SET_DEV_GPL_ONLY, 1,
-		    [bio_set_dev() GPL-only])
-	])
+	], [], [$ZFS_META_LICENSE])
 ])
 
 AC_DEFUN([ZFS_AC_KERNEL_BIO_SET_DEV], [
-	ZFS_AC_KERNEL_BIO_SET_DEV_MACRO
-	ZFS_AC_KERNEL_BIO_SET_DEV_GPL_ONLY
+	AC_MSG_CHECKING([whether bio_set_dev() is available])
+	ZFS_LINUX_TEST_RESULT([bio_set_dev], [
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_BIO_SET_DEV, 1, [bio_set_dev() is available])
+
+		AC_MSG_CHECKING([whether bio_set_dev() is GPL-only])
+		ZFS_LINUX_TEST_RESULT([bio_set_dev_license], [
+			AC_MSG_RESULT(no)
+		],[
+			AC_MSG_RESULT(yes)
+			AC_DEFINE(HAVE_BIO_SET_DEV_GPL_ONLY, 1,
+			    [bio_set_dev() GPL-only])
+		])
+	],[
+		AC_MSG_RESULT(no)
+	])
 ])
Index: zfs-linux-0.8.2/config/kernel-blk-queue-bdi.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-blk-queue-bdi.m4
+++ zfs-linux-0.8.2/config/kernel-blk-queue-bdi.m4
@@ -2,15 +2,19 @@ dnl #
 dnl # 2.6.32 - 4.11, statically allocated bdi in request_queue
 dnl # 4.12 - x.y, dynamically allocated bdi in request_queue
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_BDI], [
-	AC_MSG_CHECKING([whether blk_queue bdi is dynamic])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_BDI], [
+	ZFS_LINUX_TEST_SRC([blk_queue_bdi], [
 		#include <linux/blkdev.h>
 	],[
 		struct request_queue q;
 		struct backing_dev_info bdi;
 		q.backing_dev_info = &bdi;
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_BDI], [
+	AC_MSG_CHECKING([whether blk_queue bdi is dynamic])
+	ZFS_LINUX_TEST_RESULT([blk_queue_bdi], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BLK_QUEUE_BDI_DYNAMIC, 1,
 		    [blk queue backing_dev_info is dynamic])
Index: zfs-linux-0.8.2/config/kernel-blk-queue-discard.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-blk-queue-discard.m4
+++ zfs-linux-0.8.2/config/kernel-blk-queue-discard.m4
@@ -2,16 +2,19 @@ dnl #
 dnl # 2.6.32 - 4.x API,
 dnl #   blk_queue_discard()
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_DISCARD], [
-	AC_MSG_CHECKING([whether blk_queue_discard() is available])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_DISCARD], [
+	ZFS_LINUX_TEST_SRC([blk_queue_discard], [
 		#include <linux/blkdev.h>
 	],[
 		struct request_queue *q __attribute__ ((unused)) = NULL;
 		int value __attribute__ ((unused));
-
 		value = blk_queue_discard(q);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_DISCARD], [
+	AC_MSG_CHECKING([whether blk_queue_discard() is available])
+	ZFS_LINUX_TEST_RESULT([blk_queue_discard], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BLK_QUEUE_DISCARD, 1,
 		    [blk_queue_discard() is available])
@@ -30,16 +33,27 @@ dnl #
 dnl # 2.6.x - 2.6.35 API,
 dnl #   Unsupported by kernel
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_SECURE_ERASE], [
-	AC_MSG_CHECKING([whether blk_queue_secure_erase() is available])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_SECURE_ERASE], [
+	ZFS_LINUX_TEST_SRC([blk_queue_secure_erase], [
 		#include <linux/blkdev.h>
 	],[
 		struct request_queue *q __attribute__ ((unused)) = NULL;
 		int value __attribute__ ((unused));
-
 		value = blk_queue_secure_erase(q);
+	])
+
+	ZFS_LINUX_TEST_SRC([blk_queue_secdiscard], [
+		#include <linux/blkdev.h>
 	],[
+		struct request_queue *q __attribute__ ((unused)) = NULL;
+		int value __attribute__ ((unused));
+		value = blk_queue_secdiscard(q);
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_SECURE_ERASE], [
+	AC_MSG_CHECKING([whether blk_queue_secure_erase() is available])
+	ZFS_LINUX_TEST_RESULT([blk_queue_secure_erase], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BLK_QUEUE_SECURE_ERASE, 1,
 		    [blk_queue_secure_erase() is available])
@@ -47,14 +61,7 @@ AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_SECURE
 		AC_MSG_RESULT(no)
 
 		AC_MSG_CHECKING([whether blk_queue_secdiscard() is available])
-		ZFS_LINUX_TRY_COMPILE([
-			#include <linux/blkdev.h>
-		],[
-			struct request_queue *q __attribute__ ((unused)) = NULL;
-			int value __attribute__ ((unused));
-
-			value = blk_queue_secdiscard(q);
-		],[
+		ZFS_LINUX_TEST_RESULT([blk_queue_secdiscard], [
 			AC_MSG_RESULT(yes)
 			AC_DEFINE(HAVE_BLK_QUEUE_SECDISCARD, 1,
 			    [blk_queue_secdiscard() is available])
Index: zfs-linux-0.8.2/config/kernel-blk-queue-flags.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-blk-queue-flags.m4
+++ zfs-linux-0.8.2/config/kernel-blk-queue-flags.m4
@@ -3,36 +3,54 @@ dnl # API change
 dnl # https://github.com/torvalds/linux/commit/8814ce8
 dnl # Introduction of blk_queue_flag_set and blk_queue_flag_clear
 dnl #
-
-AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_FLAG_SET], [
-	AC_MSG_CHECKING([whether blk_queue_flag_set() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_FLAG_SET], [
+	ZFS_LINUX_TEST_SRC([blk_queue_flag_set], [
 		#include <linux/kernel.h>
 		#include <linux/blkdev.h>
 	],[
 		struct request_queue *q = NULL;
 		blk_queue_flag_set(0, q);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_FLAG_SET], [
+	AC_MSG_CHECKING([whether blk_queue_flag_set() exists])
+	ZFS_LINUX_TEST_RESULT([blk_queue_flag_set], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_BLK_QUEUE_FLAG_SET, 1, [blk_queue_flag_set() exists])
+		AC_DEFINE(HAVE_BLK_QUEUE_FLAG_SET, 1,
+		    [blk_queue_flag_set() exists])
 	],[
 		AC_MSG_RESULT(no)
 	])
 ])
 
-AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_FLAG_CLEAR], [
-	AC_MSG_CHECKING([whether blk_queue_flag_clear() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_FLAG_CLEAR], [
+	ZFS_LINUX_TEST_SRC([blk_queue_flag_clear], [
 		#include <linux/kernel.h>
 		#include <linux/blkdev.h>
 	],[
 		struct request_queue *q = NULL;
 		blk_queue_flag_clear(0, q);
-	],[
+	])
+])
 
+AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_FLAG_CLEAR], [
+	AC_MSG_CHECKING([whether blk_queue_flag_clear() exists])
+	ZFS_LINUX_TEST_RESULT([blk_queue_flag_clear], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_BLK_QUEUE_FLAG_CLEAR, 1, [blk_queue_flag_clear() exists])
+		AC_DEFINE(HAVE_BLK_QUEUE_FLAG_CLEAR, 1,
+		    [blk_queue_flag_clear() exists])
 	],[
 		AC_MSG_RESULT(no)
 	])
 ])
+
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_FLAGS], [
+	ZFS_AC_KERNEL_SRC_BLK_QUEUE_FLAG_SET
+	ZFS_AC_KERNEL_SRC_BLK_QUEUE_FLAG_CLEAR
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_FLAGS], [
+	ZFS_AC_KERNEL_BLK_QUEUE_FLAG_SET
+	ZFS_AC_KERNEL_BLK_QUEUE_FLAG_CLEAR
+])
Index: zfs-linux-0.8.2/config/kernel-blk-queue-flush.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-blk-queue-flush.m4
+++ zfs-linux-0.8.2/config/kernel-blk-queue-flush.m4
@@ -9,35 +9,37 @@ dnl # there we implement our own compati
 dnl # we use the function.  The hope is that long term this function
 dnl # will be opened up.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_FLUSH], [
-	AC_MSG_CHECKING([whether blk_queue_flush() is available])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="${NO_UNUSED_BUT_SET_VARIABLE}"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_FLUSH], [
+	ZFS_LINUX_TEST_SRC([blk_queue_flush], [
 		#include <linux/blkdev.h>
-	],[
+	], [
 		struct request_queue *q = NULL;
 		(void) blk_queue_flush(q, REQ_FLUSH);
-	],[
+	], [$NO_UNUSED_BUT_SET_VARIABLE], [$ZFS_META_LICENSE])
+
+	ZFS_LINUX_TEST_SRC([blk_queue_write_cache], [
+		#include <linux/kernel.h>
+		#include <linux/blkdev.h>
+	], [
+		struct request_queue *q = NULL;
+		blk_queue_write_cache(q, true, true);
+	], [$NO_UNUSED_BUT_SET_VARIABLE], [$ZFS_META_LICENSE])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_FLUSH], [
+	AC_MSG_CHECKING([whether blk_queue_flush() is available])
+	ZFS_LINUX_TEST_RESULT([blk_queue_flush], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BLK_QUEUE_FLUSH, 1,
-		          [blk_queue_flush() is available])
+		    [blk_queue_flush() is available])
 
 		AC_MSG_CHECKING([whether blk_queue_flush() is GPL-only])
-		ZFS_LINUX_TRY_COMPILE([
-			#include <linux/module.h>
-			#include <linux/blkdev.h>
-
-			MODULE_LICENSE("$ZFS_META_LICENSE");
-		],[
-			struct request_queue *q = NULL;
-			(void) blk_queue_flush(q, REQ_FLUSH);
-		],[
+		ZFS_LINUX_TEST_RESULT([blk_queue_flush_license], [
 			AC_MSG_RESULT(no)
 		],[
 			AC_MSG_RESULT(yes)
 			AC_DEFINE(HAVE_BLK_QUEUE_FLUSH_GPL_ONLY, 1,
-				  [blk_queue_flush() is GPL-only])
+			    [blk_queue_flush() is GPL-only])
 		])
 	],[
 		AC_MSG_RESULT(no)
@@ -48,38 +50,20 @@ AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_FLUSH]
 	dnl # Replace blk_queue_flush with blk_queue_write_cache
 	dnl #
 	AC_MSG_CHECKING([whether blk_queue_write_cache() exists])
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/kernel.h>
-		#include <linux/blkdev.h>
-
-	],[
-		struct request_queue *q = NULL;
-		blk_queue_write_cache(q, true, true);
-	],[
+	ZFS_LINUX_TEST_RESULT([blk_queue_write_cache], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BLK_QUEUE_WRITE_CACHE, 1,
-			[blk_queue_write_cache() exists])
+		    [blk_queue_write_cache() exists])
 
 		AC_MSG_CHECKING([whether blk_queue_write_cache() is GPL-only])
-		ZFS_LINUX_TRY_COMPILE([
-			#include <linux/kernel.h>
-			#include <linux/module.h>
-			#include <linux/blkdev.h>
-
-			MODULE_LICENSE("$ZFS_META_LICENSE");
-		],[
-			struct request_queue *q = NULL;
-			blk_queue_write_cache(q, true, true);
-		],[
+		ZFS_LINUX_TEST_RESULT([blk_queue_write_cache_license], [
 			AC_MSG_RESULT(no)
 		],[
 			AC_MSG_RESULT(yes)
 			AC_DEFINE(HAVE_BLK_QUEUE_WRITE_CACHE_GPL_ONLY, 1,
-				  [blk_queue_write_cache() is GPL-only])
+			    [blk_queue_write_cache() is GPL-only])
 		])
 	],[
 		AC_MSG_RESULT(no)
 	])
-
-	EXTRA_KCFLAGS="$tmp_flags"
 ])
Index: zfs-linux-0.8.2/config/kernel-blk-queue-max-hw-sectors.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-blk-queue-max-hw-sectors.m4
+++ zfs-linux-0.8.2/config/kernel-blk-queue-max-hw-sectors.m4
@@ -2,21 +2,22 @@ dnl #
 dnl # 2.6.34 API change
 dnl # blk_queue_max_hw_sectors() replaces blk_queue_max_sectors().
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_MAX_HW_SECTORS], [
-	AC_MSG_CHECKING([whether blk_queue_max_hw_sectors() is available])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="${NO_UNUSED_BUT_SET_VARIABLE}"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_MAX_HW_SECTORS], [
+	ZFS_LINUX_TEST_SRC([blk_queue_max_hw_sectors], [
 		#include <linux/blkdev.h>
-	],[
+	], [
 		struct request_queue *q = NULL;
 		(void) blk_queue_max_hw_sectors(q, BLK_SAFE_MAX_SECTORS);
-	],[
+	], [$NO_UNUSED_BUT_SET_VARIABLE])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_MAX_HW_SECTORS], [
+	AC_MSG_CHECKING([whether blk_queue_max_hw_sectors() is available])
+	ZFS_LINUX_TEST_RESULT([blk_queue_max_hw_sectors], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BLK_QUEUE_MAX_HW_SECTORS, 1,
-		          [blk_queue_max_hw_sectors() is available])
+		    [blk_queue_max_hw_sectors() is available])
 	],[
 		AC_MSG_RESULT(no)
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
 ])
Index: zfs-linux-0.8.2/config/kernel-blk-queue-max-segments.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-blk-queue-max-segments.m4
+++ zfs-linux-0.8.2/config/kernel-blk-queue-max-segments.m4
@@ -3,21 +3,22 @@ dnl # 2.6.34 API change
 dnl # blk_queue_max_segments() consolidates blk_queue_max_hw_segments()
 dnl # and blk_queue_max_phys_segments().
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_MAX_SEGMENTS], [
-	AC_MSG_CHECKING([whether blk_queue_max_segments() is available])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="${NO_UNUSED_BUT_SET_VARIABLE}"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_MAX_SEGMENTS], [
+	ZFS_LINUX_TEST_SRC([blk_queue_max_segments], [
 		#include <linux/blkdev.h>
-	],[
+	], [
 		struct request_queue *q = NULL;
 		(void) blk_queue_max_segments(q, BLK_MAX_SEGMENTS);
-	],[
+	], [$NO_UNUSED_BUT_SET_VARIABLE])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_MAX_SEGMENTS], [
+	AC_MSG_CHECKING([whether blk_queue_max_segments() is available])
+	ZFS_LINUX_TEST_RESULT([blk_queue_max_segments], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BLK_QUEUE_MAX_SEGMENTS, 1,
-		          [blk_queue_max_segments() is available])
-	],[
+		    [blk_queue_max_segments() is available])
+	], [
 		AC_MSG_RESULT(no)
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
 ])
Index: zfs-linux-0.8.2/config/kernel-blk-queue-unplug.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-blk-queue-unplug.m4
+++ zfs-linux-0.8.2/config/kernel-blk-queue-unplug.m4
@@ -2,43 +2,53 @@ dnl #
 dnl # 2.6.32-2.6.35 API - The BIO_RW_UNPLUG enum can be used as a hint
 dnl # to unplug the queue.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_HAVE_BIO_RW_UNPLUG], [
-	AC_MSG_CHECKING([whether the BIO_RW_UNPLUG enum is available])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="${NO_UNUSED_BUT_SET_VARIABLE}"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BIO_RW_UNPLUG], [
+	ZFS_LINUX_TEST_SRC([blk_queue_bio_rw_unplug], [
 		#include <linux/blkdev.h>
 	],[
-		extern enum bio_rw_flags rw;
+		enum bio_rw_flags rw __attribute__ ((unused)) = BIO_RW_UNPLUG;
+	])
+])
 
-		rw = BIO_RW_UNPLUG;
-	],[
+AC_DEFUN([ZFS_AC_KERNEL_BIO_RW_UNPLUG], [
+	AC_MSG_CHECKING([whether the BIO_RW_UNPLUG enum is available])
+	ZFS_LINUX_TEST_RESULT([blk_queue_bio_rw_unplug], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BLK_QUEUE_HAVE_BIO_RW_UNPLUG, 1,
-		          [BIO_RW_UNPLUG is available])
+		    [BIO_RW_UNPLUG is available])
 	],[
 		AC_MSG_RESULT(no)
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
 ])
 
-AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_HAVE_BLK_PLUG], [
-	AC_MSG_CHECKING([whether struct blk_plug is available])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="${NO_UNUSED_BUT_SET_VARIABLE}"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_PLUG], [
+	ZFS_LINUX_TEST_SRC([blk_plug], [
 		#include <linux/blkdev.h>
 	],[
-		struct blk_plug plug;
+		struct blk_plug plug __attribute__ ((unused));
 
 		blk_start_plug(&plug);
 		blk_finish_plug(&plug);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BLK_PLUG], [
+	AC_MSG_CHECKING([whether struct blk_plug is available])
+	ZFS_LINUX_TEST_RESULT([blk_plug], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BLK_QUEUE_HAVE_BLK_PLUG, 1,
-		          [struct blk_plug is available])
+		    [struct blk_plug is available])
 	],[
 		AC_MSG_RESULT(no)
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BLK_QUEUE_PLUG], [
+	ZFS_AC_KERNEL_SRC_BIO_RW_UNPLUG
+	ZFS_AC_KERNEL_SRC_BLK_PLUG
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BLK_QUEUE_PLUG], [
+	ZFS_AC_KERNEL_BIO_RW_UNPLUG
+	ZFS_AC_KERNEL_BLK_PLUG
 ])
Index: zfs-linux-0.8.2/config/kernel-blkdev-get-by-path.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-blkdev-get-by-path.m4
+++ zfs-linux-0.8.2/config/kernel-blkdev-get-by-path.m4
@@ -3,16 +3,21 @@ dnl # 2.6.38 API change
 dnl # open_bdev_exclusive() changed to blkdev_get_by_path()
 dnl # close_bdev_exclusive() changed to blkdev_put()
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BLKDEV_GET_BY_PATH],
-	[AC_MSG_CHECKING([whether blkdev_get_by_path() is available])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BLKDEV_GET_BY_PATH], [
+	ZFS_LINUX_TEST_SRC([blkdev_get_by_path], [
 		#include <linux/fs.h>
 	], [
 		blkdev_get_by_path(NULL, 0, NULL);
-	], [blkdev_get_by_path], [fs/block_dev.c], [
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BLKDEV_GET_BY_PATH], [
+	AC_MSG_CHECKING([whether blkdev_get_by_path() is available])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([blkdev_get_by_path],
+	    [blkdev_get_by_path], [fs/block_dev.c], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BLKDEV_GET_BY_PATH, 1,
-		          [blkdev_get_by_path() is available])
+		    [blkdev_get_by_path() is available])
 	], [
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-blkdev-reread-part.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-blkdev-reread-part.m4
+++ zfs-linux-0.8.2/config/kernel-blkdev-reread-part.m4
@@ -2,16 +2,20 @@ dnl #
 dnl # 4.1 API, exported blkdev_reread_part() symbol, backported to the
 dnl # 3.10.0 CentOS 7.x enterprise kernels.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BLKDEV_REREAD_PART], [
-	AC_MSG_CHECKING([whether blkdev_reread_part() is available])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BLKDEV_REREAD_PART], [
+	ZFS_LINUX_TEST_SRC([blkdev_reread_part], [
 		#include <linux/fs.h>
 	], [
 		struct block_device *bdev = NULL;
 		int error;
 
 		error = blkdev_reread_part(bdev);
-	], [
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BLKDEV_REREAD_PART], [
+	AC_MSG_CHECKING([whether blkdev_reread_part() is available])
+	ZFS_LINUX_TEST_RESULT([blkdev_reread_part], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BLKDEV_REREAD_PART, 1,
 		    [blkdev_reread_part() is available])
Index: zfs-linux-0.8.2/config/kernel-block-device-operations.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-block-device-operations.m4
+++ zfs-linux-0.8.2/config/kernel-block-device-operations.m4
@@ -1,11 +1,8 @@
 dnl #
 dnl # 2.6.38 API change
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BLOCK_DEVICE_OPERATIONS_CHECK_EVENTS], [
-	AC_MSG_CHECKING([whether bops->check_events() exists])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="${NO_UNUSED_BUT_SET_VARIABLE}"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BLOCK_DEVICE_OPERATIONS_CHECK_EVENTS], [
+	ZFS_LINUX_TEST_SRC([block_device_operations_check_events], [
 		#include <linux/blkdev.h>
 
 		unsigned int blk_check_events(struct gendisk *disk,
@@ -15,25 +12,25 @@ AC_DEFUN([ZFS_AC_KERNEL_BLOCK_DEVICE_OPE
 		    bops __attribute__ ((unused)) = {
 			.check_events	= blk_check_events,
 		};
-	],[
-	],[
+	], [], [$NO_UNUSED_BUT_SET_VARIABLE])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BLOCK_DEVICE_OPERATIONS_CHECK_EVENTS], [
+	AC_MSG_CHECKING([whether bops->check_events() exists])
+	ZFS_LINUX_TEST_RESULT([block_device_operations_check_events], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BLOCK_DEVICE_OPERATIONS_CHECK_EVENTS, 1,
 		    [bops->check_events() exists])
 	],[
 		AC_MSG_RESULT(no)
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
 ])
 
 dnl #
 dnl # 3.10.x API change
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_BLOCK_DEVICE_OPERATIONS_RELEASE_VOID], [
-	AC_MSG_CHECKING([whether bops->release() is void])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="${NO_UNUSED_BUT_SET_VARIABLE}"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BLOCK_DEVICE_OPERATIONS_RELEASE_VOID], [
+	ZFS_LINUX_TEST_SRC([block_device_operations_release_void], [
 		#include <linux/blkdev.h>
 
 		void blk_release(struct gendisk *g, fmode_t mode) { return; }
@@ -45,13 +42,26 @@ AC_DEFUN([ZFS_AC_KERNEL_BLOCK_DEVICE_OPE
 			.ioctl		= NULL,
 			.compat_ioctl	= NULL,
 		};
-	],[
-	],[
-		AC_MSG_RESULT(void)
+	], [], [$NO_UNUSED_BUT_SET_VARIABLE])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BLOCK_DEVICE_OPERATIONS_RELEASE_VOID], [
+	AC_MSG_CHECKING([whether bops->release() is void])
+	ZFS_LINUX_TEST_RESULT([block_device_operations_release_void], [
+		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_BLOCK_DEVICE_OPERATIONS_RELEASE_VOID, 1,
 		          [bops->release() returns void])
 	],[
-		AC_MSG_RESULT(int)
+		AC_MSG_RESULT(no)
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BLOCK_DEVICE_OPERATIONS], [
+	ZFS_AC_KERNEL_SRC_BLOCK_DEVICE_OPERATIONS_CHECK_EVENTS
+	ZFS_AC_KERNEL_SRC_BLOCK_DEVICE_OPERATIONS_RELEASE_VOID
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BLOCK_DEVICE_OPERATIONS], [
+	ZFS_AC_KERNEL_BLOCK_DEVICE_OPERATIONS_CHECK_EVENTS
+	ZFS_AC_KERNEL_BLOCK_DEVICE_OPERATIONS_RELEASE_VOID
 ])
Index: zfs-linux-0.8.2/config/kernel-clear-inode.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-clear-inode.m4
+++ zfs-linux-0.8.2/config/kernel-clear-inode.m4
@@ -19,13 +19,18 @@ dnl # Therefore, to ensure we have the c
 dnl # clear_inode() compatibility code to be defined iff the evict_inode()
 dnl # functionality is also detected.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_CLEAR_INODE],
-	[AC_MSG_CHECKING([whether clear_inode() is available])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_CLEAR_INODE], [
+	ZFS_LINUX_TEST_SRC([clear_inode], [
 		#include <linux/fs.h>
 	], [
 		clear_inode(NULL);
-	], [clear_inode], [fs/inode.c], [
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_CLEAR_INODE], [
+	AC_MSG_CHECKING([whether clear_inode() is available])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([clear_inode],
+	    [clear_inode], [fs/inode.c], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_CLEAR_INODE, 1, [clear_inode() is available])
 	], [
Index: zfs-linux-0.8.2/config/kernel-commit-metadata.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-commit-metadata.m4
+++ zfs-linux-0.8.2/config/kernel-commit-metadata.m4
@@ -4,19 +4,22 @@ dnl # Added eops->commit_metadata() call
 dnl # filesystem to determine the most efficient way to commit the inode.
 dnl # Prior to this the nfs server would issue an explicit fsync().
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_COMMIT_METADATA], [
-	AC_MSG_CHECKING([whether eops->commit_metadata() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_COMMIT_METADATA], [
+	ZFS_LINUX_TEST_SRC([export_operations_commit_metadata], [
 		#include <linux/exportfs.h>
 		int commit_metadata(struct inode *inode) { return 0; }
 		static struct export_operations eops __attribute__ ((unused))={
 			.commit_metadata = commit_metadata,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_COMMIT_METADATA], [
+	AC_MSG_CHECKING([whether eops->commit_metadata() exists])
+	ZFS_LINUX_TEST_RESULT([export_operations_commit_metadata], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_COMMIT_METADATA, 1,
-		          [eops->commit_metadata() exists])
+		    [eops->commit_metadata() exists])
 	],[
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-config-defined.m4
===================================================================
--- /dev/null
+++ zfs-linux-0.8.2/config/kernel-config-defined.m4
@@ -0,0 +1,183 @@
+dnl #
+dnl # Certain kernel build options are not supported.  These must be
+dnl # detected at configure time and cause a build failure.  Otherwise
+dnl # modules may be successfully built that behave incorrectly.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_CONFIG_DEFINED], [
+	AS_IF([test "x$cross_compiling" != xyes], [
+		AC_RUN_IFELSE([
+			AC_LANG_PROGRAM([
+				#include "$LINUX/include/linux/license.h"
+			], [
+				return !license_is_gpl_compatible(
+				    "$ZFS_META_LICENSE");
+			])
+		], [
+			AC_DEFINE([ZFS_IS_GPL_COMPATIBLE], [1],
+			    [Define to 1 if GPL-only symbols can be used])
+		], [
+		])
+	])
+
+	ZFS_AC_KERNEL_SRC_CONFIG_THREAD_SIZE
+	ZFS_AC_KERNEL_SRC_CONFIG_DEBUG_LOCK_ALLOC
+	ZFS_AC_KERNEL_SRC_CONFIG_TRIM_UNUSED_KSYMS
+	ZFS_AC_KERNEL_SRC_CONFIG_ZLIB_INFLATE
+	ZFS_AC_KERNEL_SRC_CONFIG_ZLIB_DEFLATE
+
+	AC_MSG_CHECKING([for kernel config option compatibility])
+	ZFS_LINUX_TEST_COMPILE_ALL([config])
+	AC_MSG_RESULT([done])
+
+	ZFS_AC_KERNEL_CONFIG_THREAD_SIZE
+	ZFS_AC_KERNEL_CONFIG_DEBUG_LOCK_ALLOC
+	ZFS_AC_KERNEL_CONFIG_TRIM_UNUSED_KSYMS
+	ZFS_AC_KERNEL_CONFIG_ZLIB_INFLATE
+	ZFS_AC_KERNEL_CONFIG_ZLIB_DEFLATE
+])
+
+dnl #
+dnl # Check configured THREAD_SIZE
+dnl #
+dnl # The stack size will vary by architecture, but as of Linux 3.15 on x86_64
+dnl # the default thread stack size was increased to 16K from 8K.  Therefore,
+dnl # on newer kernels and some architectures stack usage optimizations can be
+dnl # conditionally applied to improve performance without negatively impacting
+dnl # stability.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_CONFIG_THREAD_SIZE], [
+	ZFS_LINUX_TEST_SRC([config_thread_size], [
+		#include <linux/module.h>
+	],[
+		#if (THREAD_SIZE < 16384)
+		#error "THREAD_SIZE is less than 16K"
+		#endif
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_CONFIG_THREAD_SIZE], [
+	AC_MSG_CHECKING([whether kernel was built with 16K or larger stacks])
+	ZFS_LINUX_TEST_RESULT([config_thread_size], [
+		AC_MSG_RESULT([yes])
+		AC_DEFINE(HAVE_LARGE_STACKS, 1, [kernel has large stacks])
+	],[
+		AC_MSG_RESULT([no])
+	])
+])
+
+dnl #
+dnl # Check CONFIG_DEBUG_LOCK_ALLOC
+dnl #
+dnl # This is typically only set for debug kernels because it comes with
+dnl # a performance penalty.  However, when it is set it maps the non-GPL
+dnl # symbol mutex_lock() to the GPL-only mutex_lock_nested() symbol.
+dnl # This will cause a failure at link time which we'd rather know about
+dnl # at compile time.
+dnl #
+dnl # Since we plan to pursue making mutex_lock_nested() a non-GPL symbol
+dnl # with the upstream community we add a check to detect this case.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_CONFIG_DEBUG_LOCK_ALLOC], [
+	ZFS_LINUX_TEST_SRC([config_debug_lock_alloc], [
+		#include <linux/mutex.h>
+	],[
+		struct mutex lock;
+
+		mutex_init(&lock);
+		mutex_lock(&lock);
+		mutex_unlock(&lock);
+	], [], [$ZFS_META_LICENSE])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_CONFIG_DEBUG_LOCK_ALLOC], [
+	AC_MSG_CHECKING([whether mutex_lock() is GPL-only])
+	ZFS_LINUX_TEST_RESULT([config_debug_lock_alloc], [
+		AC_MSG_RESULT(no)
+	],[
+		AC_MSG_RESULT(yes)
+		AC_MSG_ERROR([
+	*** Kernel built with CONFIG_DEBUG_LOCK_ALLOC which is incompatible
+	*** with the CDDL license and will prevent the module linking stage
+	*** from succeeding.  You must rebuild your kernel without this
+	*** option enabled.])
+	])
+])
+
+dnl #
+dnl # Check CONFIG_TRIM_UNUSED_KSYMS
+dnl #
+dnl # Verify the kernel has CONFIG_TRIM_UNUSED_KSYMS disabled.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_CONFIG_TRIM_UNUSED_KSYMS], [
+	ZFS_LINUX_TEST_SRC([config_trim_unusued_ksyms], [
+		#if defined(CONFIG_TRIM_UNUSED_KSYMS)
+		#error CONFIG_TRIM_UNUSED_KSYMS not defined
+		#endif
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_CONFIG_TRIM_UNUSED_KSYMS], [
+	AC_MSG_CHECKING([whether CONFIG_TRIM_UNUSED_KSYM is disabled])
+	ZFS_LINUX_TEST_RESULT([config_trim_unusued_ksyms], [
+		AC_MSG_RESULT([yes])
+	],[
+		AC_MSG_RESULT([no])
+		AS_IF([test "x$enable_linux_builtin" != xyes], [
+			AC_MSG_ERROR([
+	*** This kernel has unused symbols trimming enabled, please disable.
+	*** Rebuild the kernel with CONFIG_TRIM_UNUSED_KSYMS=n set.])
+		])
+	])
+])
+
+dnl #
+dnl # Check CONFIG_ZLIB_INFLATE
+dnl #
+dnl # Verify the kernel has CONFIG_ZLIB_INFLATE support enabled.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_CONFIG_ZLIB_INFLATE], [
+	ZFS_LINUX_TEST_SRC([config_zlib_inflate], [
+		#if !defined(CONFIG_ZLIB_INFLATE) && \
+		    !defined(CONFIG_ZLIB_INFLATE_MODULE)
+		#error CONFIG_ZLIB_INFLATE not defined
+		#endif
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_CONFIG_ZLIB_INFLATE], [
+	AC_MSG_CHECKING([whether CONFIG_ZLIB_INFLATE is defined])
+	ZFS_LINUX_TEST_RESULT([config_zlib_inflate], [
+		AC_MSG_RESULT([yes])
+	],[
+		AC_MSG_RESULT([no])
+		AC_MSG_ERROR([
+	*** This kernel does not include the required zlib inflate support.
+	*** Rebuild the kernel with CONFIG_ZLIB_INFLATE=y|m set.])
+	])
+])
+
+dnl #
+dnl # Check CONFIG_ZLIB_DEFLATE
+dnl #
+dnl # Verify the kernel has CONFIG_ZLIB_DEFLATE support enabled.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_CONFIG_ZLIB_DEFLATE], [
+	ZFS_LINUX_TEST_SRC([config_zlib_deflate], [
+		#if !defined(CONFIG_ZLIB_DEFLATE) && \
+		    !defined(CONFIG_ZLIB_DEFLATE_MODULE)
+		#error CONFIG_ZLIB_DEFLATE not defined
+		#endif
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_CONFIG_ZLIB_DEFLATE], [
+	AC_MSG_CHECKING([whether CONFIG_ZLIB_DEFLATE is defined])
+	ZFS_LINUX_TEST_RESULT([config_zlib_deflate], [
+		AC_MSG_RESULT([yes])
+	],[
+		AC_MSG_RESULT([no])
+		AC_MSG_ERROR([
+	*** This kernel does not include the required zlib deflate support.
+	*** Rebuild the kernel with CONFIG_ZLIB_DEFLATE=y|m set.])
+	])
+])
Index: zfs-linux-0.8.2/config/kernel-create-nameidata.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-create-nameidata.m4
+++ zfs-linux-0.8.2/config/kernel-create-nameidata.m4
@@ -1,9 +1,8 @@
 dnl #
 dnl # 3.6 API change
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_CREATE_NAMEIDATA], [
-	AC_MSG_CHECKING([whether iops->create() passes nameidata])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_CREATE_NAMEIDATA], [
+	ZFS_LINUX_TEST_SRC([create_nameidata], [
 		#include <linux/fs.h>
 		#include <linux/sched.h>
 
@@ -19,11 +18,15 @@ AC_DEFUN([ZFS_AC_KERNEL_CREATE_NAMEIDATA
 		    iops __attribute__ ((unused)) = {
 			.create		= inode_create,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_CREATE_NAMEIDATA], [
+	AC_MSG_CHECKING([whether iops->create() passes nameidata])
+	ZFS_LINUX_TEST_RESULT([create_nameidata], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_CREATE_NAMEIDATA, 1,
-		          [iops->create() passes nameidata])
+		    [iops->create() passes nameidata])
 	],[
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-ctl-table-name.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-ctl-table-name.m4
+++ zfs-linux-0.8.2/config/kernel-ctl-table-name.m4
@@ -2,14 +2,18 @@ dnl #
 dnl # 2.6.33 API change,
 dnl # Removed .ctl_name from struct ctl_table.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_CTL_NAME], [
-	AC_MSG_CHECKING([whether struct ctl_table has ctl_name])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_CTL_NAME], [
+	ZFS_LINUX_TEST_SRC([ctl_name], [
 		#include <linux/sysctl.h>
 	],[
 		struct ctl_table ctl __attribute__ ((unused));
 		ctl.ctl_name = 0;
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_CTL_NAME], [
+	AC_MSG_CHECKING([whether struct ctl_table has ctl_name])
+	ZFS_LINUX_TEST_RESULT([ctl_name], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_CTL_NAME, 1, [struct ctl_table has ctl_name])
 	],[
Index: zfs-linux-0.8.2/config/kernel-current-time.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-current-time.m4
+++ zfs-linux-0.8.2/config/kernel-current-time.m4
@@ -2,14 +2,19 @@ dnl #
 dnl # 4.9, current_time() added
 dnl # 4.18, return type changed from timespec to timespec64
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_CURRENT_TIME],
-	[AC_MSG_CHECKING([whether current_time() exists])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_CURRENT_TIME], [
+	ZFS_LINUX_TEST_SRC([current_time], [
 		#include <linux/fs.h>
 	], [
 		struct inode ip __attribute__ ((unused));
 		ip.i_atime = current_time(&ip);
-	], [current_time], [fs/inode.c], [
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_CURRENT_TIME], [
+	AC_MSG_CHECKING([whether current_time() exists])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([current_time],
+	    [current_time], [fs/inode.c], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_CURRENT_TIME, 1, [current_time() exists])
 	], [
Index: zfs-linux-0.8.2/config/kernel-current_bio_tail.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-current_bio_tail.m4
+++ zfs-linux-0.8.2/config/kernel-current_bio_tail.m4
@@ -4,30 +4,36 @@ dnl # current->bio_tail and current->bio
 dnl # Linux 2.6.34. They were refactored into a struct bio_list pointer called
 dnl # current->bio_list in Linux 2.6.34.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_CURRENT_BIO_TAIL], [
-	AC_MSG_CHECKING([whether current->bio_tail exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_CURRENT_BIO_TAIL], [
+	ZFS_LINUX_TEST_SRC([current_bio_tail], [
 		#include <linux/sched.h>
-	],[
+	], [
 		current->bio_tail = (struct bio **) NULL;
-	],[
+	])
+
+	ZFS_LINUX_TEST_SRC([current_bio_list], [
+		#include <linux/sched.h>
+	], [
+		current->bio_list = (struct bio_list *) NULL;
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_CURRENT_BIO_TAIL], [
+	AC_MSG_CHECKING([whether current->bio_tail exists])
+	ZFS_LINUX_TEST_RESULT([current_bio_tail], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_CURRENT_BIO_TAIL, 1,
 		    [current->bio_tail exists])
 	],[
 		AC_MSG_RESULT(no)
+
 		AC_MSG_CHECKING([whether current->bio_list exists])
-		ZFS_LINUX_TRY_COMPILE([
-			#include <linux/sched.h>
-		],[
-			current->bio_list = (struct bio_list *) NULL;
-		],[
+		ZFS_LINUX_TEST_RESULT([current_bio_list], [
 			AC_MSG_RESULT(yes)
 			AC_DEFINE(HAVE_CURRENT_BIO_LIST, 1,
 			    [current->bio_list exists])
 		],[
-			AC_MSG_ERROR(no - Please file a bug report at
-			    https://github.com/zfsonlinux/zfs/issues/new)
+			ZFS_LINUX_TEST_ERROR([bio_list])
 		])
 	])
 ])
Index: zfs-linux-0.8.2/config/kernel-d-make-root.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-d-make-root.m4
+++ /dev/null
@@ -1,17 +0,0 @@
-dnl #
-dnl # 3.4.0 API change
-dnl # Added d_make_root() to replace previous d_alloc_root() function.
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_D_MAKE_ROOT],
-	[AC_MSG_CHECKING([whether d_make_root() is available])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
-		#include <linux/dcache.h>
-	], [
-		d_make_root(NULL);
-	], [d_make_root], [fs/dcache.c], [
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_D_MAKE_ROOT, 1, [d_make_root() is available])
-	], [
-		AC_MSG_RESULT(no)
-	])
-])
Index: zfs-linux-0.8.2/config/kernel-d-obtain-alias.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-d-obtain-alias.m4
+++ /dev/null
@@ -1,18 +0,0 @@
-dnl #
-dnl # 2.6.28 API change
-dnl # Added d_obtain_alias() helper function.
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_D_OBTAIN_ALIAS],
-	[AC_MSG_CHECKING([whether d_obtain_alias() is available])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
-		#include <linux/dcache.h>
-	], [
-		d_obtain_alias(NULL);
-	], [d_obtain_alias], [fs/dcache.c], [
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_D_OBTAIN_ALIAS, 1,
-		          [d_obtain_alias() is available])
-	], [
-		AC_MSG_RESULT(no)
-	])
-])
Index: zfs-linux-0.8.2/config/kernel-d-prune-aliases.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-d-prune-aliases.m4
+++ /dev/null
@@ -1,19 +0,0 @@
-dnl #
-dnl # 2.6.12 API change
-dnl # d_prune_aliases() helper function available.
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_D_PRUNE_ALIASES],
-	[AC_MSG_CHECKING([whether d_prune_aliases() is available])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
-		#include <linux/dcache.h>
-	], [
-		struct inode *ip = NULL;
-		d_prune_aliases(ip);
-	], [d_prune_aliases], [fs/dcache.c], [
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_D_PRUNE_ALIASES, 1,
-		          [d_prune_aliases() is available])
-	], [
-		AC_MSG_RESULT(no)
-	])
-])
Index: zfs-linux-0.8.2/config/kernel-declare-event-class.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-declare-event-class.m4
+++ zfs-linux-0.8.2/config/kernel-declare-event-class.m4
@@ -2,13 +2,10 @@ dnl #
 dnl # Ensure the DECLARE_EVENT_CLASS macro is available to non-GPL modules.
 dnl #
 AC_DEFUN([ZFS_AC_KERNEL_DECLARE_EVENT_CLASS], [
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-I\$(src)"
-
 	AC_MSG_CHECKING([whether DECLARE_EVENT_CLASS() is available])
 	ZFS_LINUX_TRY_COMPILE_HEADER([
 		#include <linux/module.h>
-		MODULE_LICENSE(ZFS_META_LICENSE);
+		MODULE_LICENSE("$ZFS_META_LICENSE");
 
 		#define CREATE_TRACE_POINTS
 		#include "conftest.h"
@@ -18,7 +15,7 @@ AC_DEFUN([ZFS_AC_KERNEL_DECLARE_EVENT_CL
 	],[
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_DECLARE_EVENT_CLASS, 1,
-		          [DECLARE_EVENT_CLASS() is available])
+		    [DECLARE_EVENT_CLASS() is available])
 	],[
 		AC_MSG_RESULT(no)
 	],[
@@ -55,5 +52,4 @@ AC_DEFUN([ZFS_AC_KERNEL_DECLARE_EVENT_CL
 		#define TRACE_INCLUDE_FILE conftest
 		#include <trace/define_trace.h>
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
 ])
Index: zfs-linux-0.8.2/config/kernel-dentry-operations.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-dentry-operations.m4
+++ zfs-linux-0.8.2/config/kernel-dentry-operations.m4
@@ -1,9 +1,103 @@
 dnl #
+dnl # 3.4.0 API change
+dnl # Added d_make_root() to replace previous d_alloc_root() function.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_D_MAKE_ROOT], [
+	ZFS_LINUX_TEST_SRC([d_make_root], [
+		#include <linux/dcache.h>
+	], [
+		d_make_root(NULL);
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_D_MAKE_ROOT], [
+	AC_MSG_CHECKING([whether d_make_root() is available])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([d_make_root],
+	    [d_make_root], [fs/dcache.c], [
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_D_MAKE_ROOT, 1, [d_make_root() is available])
+	], [
+		AC_MSG_RESULT(no)
+	])
+])
+
+dnl #
+dnl # 2.6.28 API change
+dnl # Added d_obtain_alias() helper function.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_D_OBTAIN_ALIAS], [
+	ZFS_LINUX_TEST_SRC([d_obtain_alias], [
+		#include <linux/dcache.h>
+	], [
+		d_obtain_alias(NULL);
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_D_OBTAIN_ALIAS], [
+	AC_MSG_CHECKING([whether d_obtain_alias() is available])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([d_obtain_alias],
+	    [d_obtain_alias], [fs/dcache.c], [
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_D_OBTAIN_ALIAS, 1,
+		          [d_obtain_alias() is available])
+	], [
+		AC_MSG_RESULT(no)
+	])
+])
+
+dnl #
+dnl # 2.6.12 API change
+dnl # d_prune_aliases() helper function available.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_D_PRUNE_ALIASES], [
+	ZFS_LINUX_TEST_SRC([d_prune_aliases], [
+		#include <linux/dcache.h>
+	], [
+		struct inode *ip = NULL;
+		d_prune_aliases(ip);
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_D_PRUNE_ALIASES], [
+	AC_MSG_CHECKING([whether d_prune_aliases() is available])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([d_prune_aliases],
+	    [d_prune_aliases], [fs/dcache.c], [
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_D_PRUNE_ALIASES, 1,
+		    [d_prune_aliases() is available])
+	], [
+		AC_MSG_RESULT(no)
+	])
+])
+
+dnl #
+dnl # 2.6.38 API change
+dnl # Added d_set_d_op() helper function.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_D_SET_D_OP], [
+	ZFS_LINUX_TEST_SRC([d_set_d_op], [
+		#include <linux/dcache.h>
+	], [
+		d_set_d_op(NULL, NULL);
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_D_SET_D_OP], [
+	AC_MSG_CHECKING([whether d_set_d_op() is available])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([d_set_d_op],
+	    [d_set_d_op], [fs/dcache.c], [
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_D_SET_D_OP, 1, [d_set_d_op() is available])
+	], [
+		AC_MSG_RESULT(no)
+	])
+])
+
+dnl #
 dnl # 3.6 API change
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_D_REVALIDATE_NAMEIDATA], [
-	AC_MSG_CHECKING([whether dops->d_revalidate() takes struct nameidata])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_D_REVALIDATE_NAMEIDATA], [
+	ZFS_LINUX_TEST_SRC([dentry_operations_revalidate], [
 		#include <linux/dcache.h>
 		#include <linux/sched.h>
 
@@ -14,11 +108,15 @@ AC_DEFUN([ZFS_AC_KERNEL_D_REVALIDATE_NAM
 		    dops __attribute__ ((unused)) = {
 			.d_revalidate	= revalidate,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_D_REVALIDATE_NAMEIDATA], [
+	AC_MSG_CHECKING([whether dops->d_revalidate() takes struct nameidata])
+	ZFS_LINUX_TEST_RESULT([dentry_operations_revalidate], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_D_REVALIDATE_NAMEIDATA, 1,
-		          [dops->d_revalidate() operation takes nameidata])
+		    [dops->d_revalidate() operation takes nameidata])
 	],[
 		AC_MSG_RESULT(no)
 	])
@@ -28,9 +126,8 @@ dnl #
 dnl # 2.6.30 API change
 dnl # The 'struct dentry_operations' was constified in the dentry structure.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_CONST_DENTRY_OPERATIONS], [
-	AC_MSG_CHECKING([whether dentry uses const struct dentry_operations])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_CONST_DENTRY_OPERATIONS], [
+	ZFS_LINUX_TEST_SRC([dentry_operations_const], [
 		#include <linux/dcache.h>
 
 		const struct dentry_operations test_d_op = {
@@ -38,32 +135,17 @@ AC_DEFUN([ZFS_AC_KERNEL_CONST_DENTRY_OPE
 		};
 	],[
 		struct dentry d __attribute__ ((unused));
-
 		d.d_op = &test_d_op;
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_CONST_DENTRY_OPERATIONS, 1,
-		          [dentry uses const struct dentry_operations])
-	],[
-		AC_MSG_RESULT(no)
 	])
 ])
 
-dnl #
-dnl # 2.6.38 API change
-dnl # Added d_set_d_op() helper function.
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_D_SET_D_OP],
-	[AC_MSG_CHECKING([whether d_set_d_op() is available])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
-		#include <linux/dcache.h>
-	], [
-		d_set_d_op(NULL, NULL);
-	], [d_set_d_op], [fs/dcache.c], [
+AC_DEFUN([ZFS_AC_KERNEL_CONST_DENTRY_OPERATIONS], [
+	AC_MSG_CHECKING([whether dentry uses const struct dentry_operations])
+	ZFS_LINUX_TEST_RESULT([dentry_operations_const], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_D_SET_D_OP, 1,
-		          [d_set_d_op() is available])
-	], [
+		AC_DEFINE(HAVE_CONST_DENTRY_OPERATIONS, 1,
+		    [dentry uses const struct dentry_operations])
+	],[
 		AC_MSG_RESULT(no)
 	])
 ])
@@ -72,17 +154,41 @@ dnl #
 dnl # 2.6.38 API chage
 dnl # Added sb->s_d_op default dentry_operations member
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_S_D_OP],
-	[AC_MSG_CHECKING([whether super_block has s_d_op])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_S_D_OP], [
+	ZFS_LINUX_TEST_SRC([super_block_s_d_op], [
 		#include <linux/fs.h>
 	],[
 		struct super_block sb __attribute__ ((unused));
 		sb.s_d_op = NULL;
-	], [
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_S_D_OP], [
+	AC_MSG_CHECKING([whether super_block has s_d_op])
+	ZFS_LINUX_TEST_RESULT([super_block_s_d_op], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_S_D_OP, 1, [struct super_block has s_d_op])
 	], [
 		AC_MSG_RESULT(no)
 	])
 ])
+
+AC_DEFUN([ZFS_AC_KERNEL_SRC_DENTRY], [
+        ZFS_AC_KERNEL_SRC_D_MAKE_ROOT
+        ZFS_AC_KERNEL_SRC_D_OBTAIN_ALIAS
+        ZFS_AC_KERNEL_SRC_D_PRUNE_ALIASES
+        ZFS_AC_KERNEL_SRC_D_SET_D_OP
+        ZFS_AC_KERNEL_SRC_D_REVALIDATE_NAMEIDATA
+        ZFS_AC_KERNEL_SRC_CONST_DENTRY_OPERATIONS
+        ZFS_AC_KERNEL_SRC_S_D_OP
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_DENTRY], [
+        ZFS_AC_KERNEL_D_MAKE_ROOT
+        ZFS_AC_KERNEL_D_OBTAIN_ALIAS
+        ZFS_AC_KERNEL_D_PRUNE_ALIASES
+        ZFS_AC_KERNEL_D_SET_D_OP
+        ZFS_AC_KERNEL_D_REVALIDATE_NAMEIDATA
+        ZFS_AC_KERNEL_CONST_DENTRY_OPERATIONS
+        ZFS_AC_KERNEL_S_D_OP
+])
Index: zfs-linux-0.8.2/config/kernel-dirty-inode.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-dirty-inode.m4
+++ zfs-linux-0.8.2/config/kernel-dirty-inode.m4
@@ -4,9 +4,8 @@ dnl # The sops->dirty_inode() callbacks
 dnl # argument.  This allows the greater control over whether the
 dnl # filesystem needs to push out a transaction or not.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_DIRTY_INODE_WITH_FLAGS], [
-	AC_MSG_CHECKING([whether sops->dirty_inode() wants flags])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_DIRTY_INODE], [
+	ZFS_LINUX_TEST_SRC([dirty_inode_with_flags], [
 		#include <linux/fs.h>
 
 		void dirty_inode(struct inode *a, int b) { return; }
@@ -15,11 +14,15 @@ AC_DEFUN([ZFS_AC_KERNEL_DIRTY_INODE_WITH
 		    sops __attribute__ ((unused)) = {
 			.dirty_inode = dirty_inode,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_DIRTY_INODE], [
+	AC_MSG_CHECKING([whether sops->dirty_inode() wants flags])
+	ZFS_LINUX_TEST_RESULT([dirty_inode_with_flags], [
 		AC_MSG_RESULT([yes])
 		AC_DEFINE(HAVE_DIRTY_INODE_WITH_FLAGS, 1,
-			[sops->dirty_inode() wants flags])
+		    [sops->dirty_inode() wants flags])
 	],[
 		AC_MSG_RESULT([no])
 	])
Index: zfs-linux-0.8.2/config/kernel-discard-granularity.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-discard-granularity.m4
+++ zfs-linux-0.8.2/config/kernel-discard-granularity.m4
@@ -2,18 +2,21 @@ dnl #
 dnl # 2.6.33 API change
 dnl # Discard granularity and alignment restrictions may now be set.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_DISCARD_GRANULARITY], [
-	AC_MSG_CHECKING([whether ql->discard_granularity is available])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_DISCARD_GRANULARITY], [
+	ZFS_LINUX_TEST_SRC([discard_granularity], [
 		#include <linux/blkdev.h>
 	],[
 		struct queue_limits ql __attribute__ ((unused));
-
 		ql.discard_granularity = 0;
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_DISCARD_GRANULARITY], [
+	AC_MSG_CHECKING([whether ql->discard_granularity is available])
+	ZFS_LINUX_TEST_RESULT([discard_granularity], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_DISCARD_GRANULARITY, 1,
-		          [ql->discard_granularity is available])
+		    [ql->discard_granularity is available])
 	],[
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-elevator-change.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-elevator-change.m4
+++ zfs-linux-0.8.2/config/kernel-elevator-change.m4
@@ -2,24 +2,25 @@ dnl #
 dnl # 2.6.36 API, exported elevator_change() symbol
 dnl # 4.12 API, removed elevator_change() symbol
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_ELEVATOR_CHANGE], [
-	AC_MSG_CHECKING([whether elevator_change() is available])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="${NO_UNUSED_BUT_SET_VARIABLE}"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_ELEVATOR_CHANGE], [
+	ZFS_LINUX_TEST_SRC([elevator_change], [
 		#include <linux/blkdev.h>
 		#include <linux/elevator.h>
 	],[
-		int ret;
 		struct request_queue *q = NULL;
 		char *elevator = NULL;
-		ret = elevator_change(q, elevator);
-	],[
+		int error __attribute__ ((unused)) =
+		    elevator_change(q, elevator);
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_ELEVATOR_CHANGE], [
+	AC_MSG_CHECKING([whether elevator_change() is available])
+	ZFS_LINUX_TEST_RESULT([elevator_change], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_ELEVATOR_CHANGE, 1,
-			  [elevator_change() is available])
+		    [elevator_change() is available])
 	],[
 		AC_MSG_RESULT(no)
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
 ])
Index: zfs-linux-0.8.2/config/kernel-encode-fh-inode.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-encode-fh-inode.m4
+++ zfs-linux-0.8.2/config/kernel-encode-fh-inode.m4
@@ -4,20 +4,23 @@ dnl # torvalds/linux@b0b0382bb4904965a9e
 dnl # ->encode_fh() callback to pass the child inode and its parents inode
 dnl # rather than a dentry and a boolean saying whether we want the parent.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_ENCODE_FH_WITH_INODE], [
-	AC_MSG_CHECKING([whether eops->encode_fh() wants inode])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_ENCODE_FH_WITH_INODE], [
+	ZFS_LINUX_TEST_SRC([export_operations_encode_fh], [
 		#include <linux/exportfs.h>
 		int encode_fh(struct inode *inode, __u32 *fh, int *max_len,
 		              struct inode *parent) { return 0; }
 		static struct export_operations eops __attribute__ ((unused))={
 			.encode_fh = encode_fh,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_ENCODE_FH_WITH_INODE], [
+	AC_MSG_CHECKING([whether eops->encode_fh() wants inode])
+	ZFS_LINUX_TEST_RESULT([export_operations_encode_fh], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_ENCODE_FH_WITH_INODE, 1,
-		          [eops->encode_fh() wants child and parent inodes])
+		    [eops->encode_fh() wants child and parent inodes])
 	],[
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-evict-inode.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-evict-inode.m4
+++ zfs-linux-0.8.2/config/kernel-evict-inode.m4
@@ -3,16 +3,19 @@ dnl # 2.6.36 API change
 dnl # The sops->delete_inode() and sops->clear_inode() callbacks have
 dnl # replaced by a single sops->evict_inode() callback.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_EVICT_INODE], [
-	AC_MSG_CHECKING([whether sops->evict_inode() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_EVICT_INODE], [
+	ZFS_LINUX_TEST_SRC([evict_inode], [
 		#include <linux/fs.h>
 		void evict_inode (struct inode * t) { return; }
 		static struct super_operations sops __attribute__ ((unused)) = {
 			.evict_inode = evict_inode,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_EVICT_INODE], [
+	AC_MSG_CHECKING([whether sops->evict_inode() exists])
+	ZFS_LINUX_TEST_RESULT([evict_inode], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_EVICT_INODE, 1, [sops->evict_inode() exists])
 	],[
Index: zfs-linux-0.8.2/config/kernel-fallocate.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-fallocate.m4
+++ zfs-linux-0.8.2/config/kernel-fallocate.m4
@@ -1,9 +1,11 @@
 dnl #
-dnl # Linux 2.6.38 - 3.x API
+dnl # The fallocate callback was moved from the inode_operations
+dnl # structure to the file_operations structure.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_FILE_FALLOCATE], [
-	AC_MSG_CHECKING([whether fops->fallocate() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_FALLOCATE], [
+
+	dnl # Linux 2.6.38 - 3.x API
+	ZFS_LINUX_TEST_SRC([file_fallocate], [
 		#include <linux/fs.h>
 
 		long test_fallocate(struct file *file, int mode,
@@ -13,21 +15,10 @@ AC_DEFUN([ZFS_AC_KERNEL_FILE_FALLOCATE],
 		    fops __attribute__ ((unused)) = {
 			.fallocate = test_fallocate,
 		};
-	],[
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_FILE_FALLOCATE, 1, [fops->fallocate() exists])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
+	], [])
 
-dnl #
-dnl # Linux 2.6.x - 2.6.37 API
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_INODE_FALLOCATE], [
-	AC_MSG_CHECKING([whether iops->fallocate() exists])
-	ZFS_LINUX_TRY_COMPILE([
+	dnl # Linux 2.6.x - 2.6.37 API
+	ZFS_LINUX_TEST_SRC([inode_fallocate], [
 		#include <linux/fs.h>
 
 		long test_fallocate(struct inode *inode, int mode,
@@ -37,20 +28,23 @@ AC_DEFUN([ZFS_AC_KERNEL_INODE_FALLOCATE]
 		    fops __attribute__ ((unused)) = {
 			.fallocate = test_fallocate,
 		};
+	], [])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_FALLOCATE], [
+	AC_MSG_CHECKING([whether fops->fallocate() exists])
+	ZFS_LINUX_TEST_RESULT([file_fallocate], [
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_FILE_FALLOCATE, 1, [fops->fallocate() exists])
 	],[
-	],[
+		AC_MSG_RESULT(no)
+	])
+
+	AC_MSG_CHECKING([whether iops->fallocate() exists])
+	ZFS_LINUX_TEST_RESULT([inode_fallocate], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_INODE_FALLOCATE, 1, [fops->fallocate() exists])
 	],[
 		AC_MSG_RESULT(no)
 	])
 ])
-
-dnl #
-dnl # The fallocate callback was moved from the inode_operations
-dnl # structure to the file_operations structure.
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_FALLOCATE], [
-	ZFS_AC_KERNEL_FILE_FALLOCATE
-	ZFS_AC_KERNEL_INODE_FALLOCATE
-])
Index: zfs-linux-0.8.2/config/kernel-file-dentry.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-file-dentry.m4
+++ zfs-linux-0.8.2/config/kernel-file-dentry.m4
@@ -4,14 +4,18 @@ dnl # struct access file->f_path.dentry
 dnl # since fix torvalds/linux@4bacc9c9234c ("overlayfs: Make f_path always
 dnl # point to the overlay and f_inode to the underlay").
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_FILE_DENTRY], [
-	AC_MSG_CHECKING([whether file_dentry() is available])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_FILE_DENTRY], [
+	ZFS_LINUX_TEST_SRC([file_dentry], [
 		#include <linux/fs.h>
 	],[
 		struct file *f = NULL;
 		file_dentry(f);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_FILE_DENTRY], [
+	AC_MSG_CHECKING([whether file_dentry() is available])
+	ZFS_LINUX_TEST_RESULT([file_dentry], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_FILE_DENTRY, 1, [file_dentry() is available])
 	],[
Index: zfs-linux-0.8.2/config/kernel-file-inode.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-file-inode.m4
+++ zfs-linux-0.8.2/config/kernel-file-inode.m4
@@ -3,14 +3,18 @@ dnl # 3.19 API change
 dnl # struct access f->f_dentry->d_inode was replaced by accessor function
 dnl # file_inode(f)
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_FILE_INODE], [
-	AC_MSG_CHECKING([whether file_inode() is available])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_FILE_INODE], [
+	ZFS_LINUX_TEST_SRC([file_inode], [
 		#include <linux/fs.h>
 	],[
 		struct file *f = NULL;
 		file_inode(f);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_FILE_INODE], [
+	AC_MSG_CHECKING([whether file_inode() is available])
+	ZFS_LINUX_TEST_RESULT([file_inode], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_FILE_INODE, 1, [file_inode() is available])
 	],[
Index: zfs-linux-0.8.2/config/kernel-fmode-t.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-fmode-t.m4
+++ zfs-linux-0.8.2/config/kernel-fmode-t.m4
@@ -2,16 +2,19 @@ dnl #
 dnl # 2.6.28 API change,
 dnl # check if fmode_t typedef is defined
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_TYPE_FMODE_T],
-	[AC_MSG_CHECKING([whether kernel defines fmode_t])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_FMODE_T], [
+	ZFS_LINUX_TEST_SRC([type_fmode_t], [
 		#include <linux/types.h>
 	],[
 		fmode_t *ptr __attribute__ ((unused));
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_FMODE_T], [
+	AC_MSG_CHECKING([whether kernel defines fmode_t])
+	ZFS_LINUX_TEST_RESULT([type_fmode_t], [
 		AC_MSG_RESULT([yes])
-		AC_DEFINE(HAVE_FMODE_T, 1,
-		          [kernel defines fmode_t])
+		AC_DEFINE(HAVE_FMODE_T, 1, [kernel defines fmode_t])
 	],[
 		AC_MSG_RESULT([no])
 	])
Index: zfs-linux-0.8.2/config/kernel-follow-down-one.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-follow-down-one.m4
+++ zfs-linux-0.8.2/config/kernel-follow-down-one.m4
@@ -3,14 +3,18 @@ dnl # 2.6.38 API change
 dnl # follow_down() renamed follow_down_one().  The original follow_down()
 dnl # symbol still exists but will traverse down all the layers.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_FOLLOW_DOWN_ONE], [
-	AC_MSG_CHECKING([whether follow_down_one() is available])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_FOLLOW_DOWN_ONE], [
+	ZFS_LINUX_TEST_SRC([follow_down_one], [
 		#include <linux/namei.h>
 	],[
 		struct path *p = NULL;
 		follow_down_one(p);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_FOLLOW_DOWN_ONE], [
+	AC_MSG_CHECKING([whether follow_down_one() is available])
+	ZFS_LINUX_TEST_RESULT([follow_down_one], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_FOLLOW_DOWN_ONE, 1,
 		    [follow_down_one() is available])
Index: zfs-linux-0.8.2/config/kernel-fpu.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-fpu.m4
+++ zfs-linux-0.8.2/config/kernel-fpu.m4
@@ -18,8 +18,11 @@ dnl #
 dnl # Pre-4.2:	Use kernel_fpu_{begin,end}()
 dnl #		HAVE_KERNEL_FPU & KERNEL_EXPORTS_X86_FPU
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_FPU], [
-	AC_MSG_CHECKING([which kernel_fpu header to use])
+dnl # N.B. The header check is performed before all other checks since it
+dnl # depends on HAVE_KERNEL_FPU_API_HEADER being set in confdefs.h.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_FPU_HEADER], [
+	AC_MSG_CHECKING([whether fpu headers are available])
 	ZFS_LINUX_TRY_COMPILE([
 		#include <linux/module.h>
 		#include <asm/fpu/api.h>
@@ -31,66 +34,88 @@ AC_DEFUN([ZFS_AC_KERNEL_FPU], [
 	],[
 		AC_MSG_RESULT(i387.h & xcr.h)
 	])
+])
 
-	AC_MSG_CHECKING([which kernel_fpu function to use])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
-		#include <linux/module.h>
+AC_DEFUN([ZFS_AC_KERNEL_SRC_FPU], [
+	ZFS_LINUX_TEST_SRC([kernel_fpu], [
 		#ifdef HAVE_KERNEL_FPU_API_HEADER
 		#include <asm/fpu/api.h>
 		#else
 		#include <asm/i387.h>
 		#include <asm/xcr.h>
 		#endif
-		MODULE_LICENSE("$ZFS_META_LICENSE");
-	],[
+	], [
 		kernel_fpu_begin();
 		kernel_fpu_end();
-	], [kernel_fpu_begin], [arch/x86/kernel/fpu/core.c], [
+	], [], [$ZFS_META_LICENSE])
+
+	ZFS_LINUX_TEST_SRC([__kernel_fpu], [
+		#ifdef HAVE_KERNEL_FPU_API_HEADER
+		#include <asm/fpu/api.h>
+		#else
+		#include <asm/i387.h>
+		#include <asm/xcr.h>
+		#endif
+	], [
+		__kernel_fpu_begin();
+		__kernel_fpu_end();
+	], [], [$ZFS_META_LICENSE])
+
+	ZFS_LINUX_TEST_SRC([fpu_initialized], [
+		#include <linux/module.h>
+		#include <linux/sched.h>
+	],[
+		struct fpu *fpu = &current->thread.fpu;
+		if (fpu->initialized) { return (0); };
+	])
+
+	ZFS_LINUX_TEST_SRC([tif_need_fpu_load], [
+		#include <linux/module.h>
+		#include <asm/thread_info.h>
+
+		#if !defined(TIF_NEED_FPU_LOAD)
+		#error "TIF_NEED_FPU_LOAD undefined"
+		#endif
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_FPU], [
+	dnl #
+	dnl # Legacy kernel
+	dnl #
+	AC_MSG_CHECKING([whether kernel fpu is available])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([kernel_fpu_license],
+	    [kernel_fpu_begin], [arch/x86/kernel/fpu/core.c], [
 		AC_MSG_RESULT(kernel_fpu_*)
 		AC_DEFINE(HAVE_KERNEL_FPU, 1,
 		    [kernel has kernel_fpu_* functions])
 		AC_DEFINE(KERNEL_EXPORTS_X86_FPU, 1,
 		    [kernel exports FPU functions])
 	],[
-		ZFS_LINUX_TRY_COMPILE_SYMBOL([
-			#include <linux/module.h>
-			#ifdef HAVE_KERNEL_FPU_API_HEADER
-			#include <asm/fpu/api.h>
-			#else
-			#include <asm/i387.h>
-			#include <asm/xcr.h>
-			#endif
-			MODULE_LICENSE("$ZFS_META_LICENSE");
-		],[
-			__kernel_fpu_begin();
-			__kernel_fpu_end();
-		], [__kernel_fpu_begin], [arch/x86/kernel/fpu/core.c arch/x86/kernel/i387.c], [
+		dnl #
+		dnl # Linux 4.2 kernel
+		dnl #
+		ZFS_LINUX_TEST_RESULT_SYMBOL([__kernel_fpu_license],
+		    [__kernel_fpu_begin],
+		    [arch/x86/kernel/fpu/core.c arch/x86/kernel/i387.c], [
 			AC_MSG_RESULT(__kernel_fpu_*)
 			AC_DEFINE(HAVE_UNDERSCORE_KERNEL_FPU, 1,
 			    [kernel has __kernel_fpu_* functions])
 			AC_DEFINE(KERNEL_EXPORTS_X86_FPU, 1,
 			    [kernel exports FPU functions])
 		],[
-			ZFS_LINUX_TRY_COMPILE([
-				#include <linux/module.h>
-				#include <linux/sched.h>
-			],[
-				struct fpu *fpu = &current->thread.fpu;
-				if (fpu->initialized) { return (0); };
-			],[
+			dnl #
+			dnl # Linux 5.0 kernel
+			dnl #
+			ZFS_LINUX_TEST_RESULT([fpu_initialized], [
 				AC_MSG_RESULT(fpu.initialized)
 				AC_DEFINE(HAVE_KERNEL_FPU_INITIALIZED, 1,
 				    [kernel fpu.initialized exists])
 			],[
-				ZFS_LINUX_TRY_COMPILE([
-					#include <linux/module.h>
-					#include <asm/thread_info.h>
-
-					#if !defined(TIF_NEED_FPU_LOAD)
-					#error "TIF_NEED_FPU_LOAD undefined"
-					#endif
-				],[
-				],[
+				dnl #
+				dnl # Linux 5.2 kernel
+				dnl #
+				ZFS_LINUX_TEST_RESULT([tif_need_fpu_load], [
 					AC_MSG_RESULT(TIF_NEED_FPU_LOAD)
 					AC_DEFINE(
 					    HAVE_KERNEL_TIF_NEED_FPU_LOAD, 1,
Index: zfs-linux-0.8.2/config/kernel-fst-mount.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-fst-mount.m4
+++ zfs-linux-0.8.2/config/kernel-fst-mount.m4
@@ -3,9 +3,8 @@ dnl # 2.6.38 API change
 dnl # The .get_sb callback has been replaced by a .mount callback
 dnl # in the file_system_type structure.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_FST_MOUNT], [
-        AC_MSG_CHECKING([whether fst->mount() exists])
-        ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_FST_MOUNT], [
+        ZFS_LINUX_TEST_SRC([file_system_type_mount], [
                 #include <linux/fs.h>
 
                 static struct dentry *
@@ -18,8 +17,12 @@ AC_DEFUN([ZFS_AC_KERNEL_FST_MOUNT], [
                 static struct file_system_type fst __attribute__ ((unused)) = {
                         .mount = mount,
                 };
-        ],[
-        ],[
+        ],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_FST_MOUNT], [
+        AC_MSG_CHECKING([whether fst->mount() exists])
+        ZFS_LINUX_TEST_RESULT([file_system_type_mount], [
                 AC_MSG_RESULT(yes)
                 AC_DEFINE(HAVE_FST_MOUNT, 1, [fst->mount() exists])
         ],[
Index: zfs-linux-0.8.2/config/kernel-fsync.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-fsync.m4
+++ zfs-linux-0.8.2/config/kernel-fsync.m4
@@ -1,8 +1,8 @@
 dnl #
-dnl # Linux 2.6.x - 2.6.34 API
+dnl # Check file_operations->fsync interface.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_FSYNC_WITH_DENTRY], [
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_FSYNC], [
+	ZFS_LINUX_TEST_SRC([fsync_with_dentry], [
 		#include <linux/fs.h>
 
 		int test_fsync(struct file *f, struct dentry *dentry, int x)
@@ -12,20 +12,9 @@ AC_DEFUN([ZFS_AC_KERNEL_FSYNC_WITH_DENTR
 		    fops __attribute__ ((unused)) = {
 			.fsync = test_fsync,
 		};
-	],[
-	],[
-		AC_MSG_RESULT([dentry])
-		AC_DEFINE(HAVE_FSYNC_WITH_DENTRY, 1,
-			[fops->fsync() with dentry])
-	],[
-	])
-])
+	],[])
 
-dnl #
-dnl # Linux 2.6.35 - Linux 3.0 API
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_FSYNC_WITHOUT_DENTRY], [
-	ZFS_LINUX_TRY_COMPILE([
+	ZFS_LINUX_TEST_SRC([fsync_without_dentry], [
 		#include <linux/fs.h>
 
 		int test_fsync(struct file *f, int x) { return 0; }
@@ -34,20 +23,9 @@ AC_DEFUN([ZFS_AC_KERNEL_FSYNC_WITHOUT_DE
 		    fops __attribute__ ((unused)) = {
 			.fsync = test_fsync,
 		};
-	],[
-	],[
-		AC_MSG_RESULT([no dentry])
-		AC_DEFINE(HAVE_FSYNC_WITHOUT_DENTRY, 1,
-			[fops->fsync() without dentry])
-	],[
-	])
-])
+	],[])
 
-dnl #
-dnl # Linux 3.1 - 3.x API
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_FSYNC_RANGE], [
-	ZFS_LINUX_TRY_COMPILE([
+	ZFS_LINUX_TEST_SRC([fsync_range], [
 		#include <linux/fs.h>
 
 		int test_fsync(struct file *f, loff_t a, loff_t b, int c)
@@ -57,18 +35,43 @@ AC_DEFUN([ZFS_AC_KERNEL_FSYNC_RANGE], [
 		    fops __attribute__ ((unused)) = {
 			.fsync = test_fsync,
 		};
-	],[
-	],[
-		AC_MSG_RESULT([range])
-		AC_DEFINE(HAVE_FSYNC_RANGE, 1,
-			[fops->fsync() with range])
-	],[
-	])
+	],[])
 ])
 
 AC_DEFUN([ZFS_AC_KERNEL_FSYNC], [
-	AC_MSG_CHECKING([whether fops->fsync() wants])
-	ZFS_AC_KERNEL_FSYNC_WITH_DENTRY
-	ZFS_AC_KERNEL_FSYNC_WITHOUT_DENTRY
-	ZFS_AC_KERNEL_FSYNC_RANGE
+	dnl #
+	dnl # Linux 2.6.x - 2.6.34 API
+	dnl #
+	AC_MSG_CHECKING([whether fops->fsync() wants dentry])
+	ZFS_LINUX_TEST_RESULT([fsync_with_dentry], [
+		AC_MSG_RESULT([yes])
+		AC_DEFINE(HAVE_FSYNC_WITH_DENTRY, 1,
+		    [fops->fsync() with dentry])
+	],[
+		AC_MSG_RESULT([no])
+
+		dnl #
+		dnl # Linux 2.6.35 - Linux 3.0 API
+		dnl #
+		AC_MSG_CHECKING([whether fops->fsync() wants no dentry])
+		ZFS_LINUX_TEST_RESULT([fsync_without_dentry], [
+			AC_MSG_RESULT([yes])
+			AC_DEFINE(HAVE_FSYNC_WITHOUT_DENTRY, 1,
+			    [fops->fsync() without dentry])
+		],[
+			AC_MSG_RESULT([no])
+
+			dnl #
+			dnl # Linux 3.1 - 3.x API
+			dnl #
+			AC_MSG_CHECKING([whether fops->fsync() wants range])
+			ZFS_LINUX_TEST_RESULT([fsync_range], [
+				AC_MSG_RESULT([range])
+				AC_DEFINE(HAVE_FSYNC_RANGE, 1,
+				    [fops->fsync() with range])
+			],[
+				ZFS_LINUX_TEST_ERROR([fops->fsync])
+			])
+		])
+	])
 ])
Index: zfs-linux-0.8.2/config/kernel-generic_io_acct.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-generic_io_acct.m4
+++ zfs-linux-0.8.2/config/kernel-generic_io_acct.m4
@@ -1,12 +1,8 @@
 dnl #
-dnl # 3.19 API addition
+dnl # Check for generic io accounting interface.
 dnl #
-dnl # torvalds/linux@394ffa503bc40e32d7f54a9b817264e81ce131b4 allows us to
-dnl # increment iostat counters without generic_make_request().
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_GENERIC_IO_ACCT_3ARG], [
-	AC_MSG_CHECKING([whether 3 arg generic IO accounting symbols are available])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_GENERIC_IO_ACCT], [
+	ZFS_LINUX_TEST_SRC([generic_acct_3args], [
 		#include <linux/bio.h>
 
 		void (*generic_start_io_acct_f)(int, unsigned long,
@@ -16,24 +12,9 @@ AC_DEFUN([ZFS_AC_KERNEL_GENERIC_IO_ACCT_
 	], [
 		generic_start_io_acct(0, 0, NULL);
 		generic_end_io_acct(0, NULL, 0);
-	], [generic_start_io_acct], [block/bio.c], [
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_GENERIC_IO_ACCT_3ARG, 1,
-		    [generic_start_io_acct()/generic_end_io_acct() available])
-	], [
-		AC_MSG_RESULT(no)
 	])
-])
 
-dnl #
-dnl # Linux 4.14 API,
-dnl #
-dnl # generic_start_io_acct/generic_end_io_acct now require request_queue to be
-dnl # provided. No functional changes, but preparation for inflight accounting 
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_GENERIC_IO_ACCT_4ARG], [
-	AC_MSG_CHECKING([whether 4 arg generic IO accounting symbols are available])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
+	ZFS_LINUX_TEST_SRC([generic_acct_4args], [
 		#include <linux/bio.h>
 
 		void (*generic_start_io_acct_f)(struct request_queue *, int,
@@ -43,11 +24,41 @@ AC_DEFUN([ZFS_AC_KERNEL_GENERIC_IO_ACCT_
 	], [
 		generic_start_io_acct(NULL, 0, 0, NULL);
 		generic_end_io_acct(NULL, 0, NULL, 0);
-	], [generic_start_io_acct], [block/bio.c], [
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_GENERIC_IO_ACCT], [
+	dnl #
+	dnl # 3.19 API addition
+	dnl #
+	dnl # torvalds/linux@394ffa50 allows us to increment iostat
+	dnl # counters without generic_make_request().
+	dnl #
+	AC_MSG_CHECKING([whether generic IO accounting wants 3 args])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([generic_acct_3args],
+	    [generic_start_io_acct], [block/bio.c], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_GENERIC_IO_ACCT_4ARG, 1,
-		    [generic_start_io_acct()/generic_end_io_acct() 4 arg available])
+		AC_DEFINE(HAVE_GENERIC_IO_ACCT_3ARG, 1,
+		    [generic_start_io_acct()/generic_end_io_acct() available])
 	], [
 		AC_MSG_RESULT(no)
+
+		dnl #
+		dnl # Linux 4.14 API,
+		dnl #
+		dnl # generic_start_io_acct/generic_end_io_acct now require
+		dnl # request_queue to be provided. No functional changes,
+		dnl # but preparation for inflight accounting.
+		dnl #
+		AC_MSG_CHECKING([whether generic IO accounting wants 4 args])
+		ZFS_LINUX_TEST_RESULT_SYMBOL([generic_acct_4args],
+		    [generic_start_io_acct], [block/bio.c], [
+			AC_MSG_RESULT(yes)
+			AC_DEFINE(HAVE_GENERIC_IO_ACCT_4ARG, 1,
+			    [generic_start_io_acct()/generic_end_io_acct() ]
+			    [4 arg available])
+		], [
+			AC_MSG_RESULT(no)
+		])
 	])
 ])
Index: zfs-linux-0.8.2/config/kernel-generic_readlink.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-generic_readlink.m4
+++ zfs-linux-0.8.2/config/kernel-generic_readlink.m4
@@ -4,18 +4,21 @@ dnl #
 dnl # NULL inode_operations.readlink implies generic_readlink(), which
 dnl # has been made static.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_GENERIC_READLINK_GLOBAL], [
-	AC_MSG_CHECKING([whether generic_readlink is global])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_GENERIC_READLINK_GLOBAL], [
+	ZFS_LINUX_TEST_SRC([generic_readlink_global], [
 		#include <linux/fs.h>
 	],[
 		int i __attribute__ ((unused));
-
 		i = generic_readlink(NULL, NULL, 0);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_GENERIC_READLINK_GLOBAL], [
+	AC_MSG_CHECKING([whether generic_readlink is global])
+	ZFS_LINUX_TEST_RESULT([generic_readlink_global], [
 		AC_MSG_RESULT([yes])
 		AC_DEFINE(HAVE_GENERIC_READLINK, 1,
-		          [generic_readlink is global])
+		    [generic_readlink is global])
 	],[
 		AC_MSG_RESULT([no])
 	])
Index: zfs-linux-0.8.2/config/kernel-get-disk-and-module.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-get-disk-and-module.m4
+++ zfs-linux-0.8.2/config/kernel-get-disk-and-module.m4
@@ -2,14 +2,19 @@ dnl #
 dnl # 4.16 API change
 dnl # Verify if get_disk_and_module() symbol is available.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_GET_DISK_AND_MODULE],
-	[AC_MSG_CHECKING([whether get_disk_and_module() is available])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_GET_DISK_AND_MODULE], [
+	ZFS_LINUX_TEST_SRC([get_disk_and_module], [
 		#include <linux/genhd.h>
 	], [
 		struct gendisk *disk = NULL;
 		(void) get_disk_and_module(disk);
-	], [get_disk_and_module], [block/genhd.c], [
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_GET_DISK_AND_MODULE], [
+	AC_MSG_CHECKING([whether get_disk_and_module() is available])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([get_disk_and_module],
+	    [get_disk_and_module], [block/genhd.c], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_GET_DISK_AND_MODULE,
 		    1, [get_disk_and_module() is available])
Index: zfs-linux-0.8.2/config/kernel-get-disk-ro.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-get-disk-ro.m4
+++ zfs-linux-0.8.2/config/kernel-get-disk-ro.m4
@@ -1,21 +1,21 @@
 dnl #
 dnl # 2.6.x API change
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_GET_DISK_RO], [
-	AC_MSG_CHECKING([whether get_disk_ro() is available])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="${NO_UNUSED_BUT_SET_VARIABLE}"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_GET_DISK_RO], [
+	ZFS_LINUX_TEST_SRC([get_disk_ro], [
 		#include <linux/blkdev.h>
 	],[
 		struct gendisk *disk = NULL;
 		(void) get_disk_ro(disk);
-	],[
+	], [$NO_UNUSED_BUT_SET_VARIABLE])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_GET_DISK_RO], [
+	AC_MSG_CHECKING([whether get_disk_ro() is available])
+	ZFS_LINUX_TEST_RESULT([get_disk_ro], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_GET_DISK_RO, 1,
-		          [blk_disk_ro() is available])
+		AC_DEFINE(HAVE_GET_DISK_RO, 1, [blk_disk_ro() is available])
 	],[
 		AC_MSG_RESULT(no)
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
 ])
Index: zfs-linux-0.8.2/config/kernel-get-link.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-get-link.m4
+++ zfs-linux-0.8.2/config/kernel-get-link.m4
@@ -1,13 +1,29 @@
 dnl #
 dnl # Supported get_link() interfaces checked newest to oldest.
+dnl # Note this interface used to be named follow_link.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_FOLLOW_LINK], [
-	dnl #
-	dnl # 4.2 API change
-	dnl # - This kernel retired the nameidata structure.
-	dnl #
-	AC_MSG_CHECKING([whether iops->follow_link() passes cookie])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_GET_LINK], [
+	ZFS_LINUX_TEST_SRC([inode_operations_get_link], [
+		#include <linux/fs.h>
+		const char *get_link(struct dentry *de, struct inode *ip,
+		    struct delayed_call *done) { return "symlink"; }
+		static struct inode_operations
+		     iops __attribute__ ((unused)) = {
+			.get_link = get_link,
+		};
+	],[])
+
+	ZFS_LINUX_TEST_SRC([inode_operations_get_link_cookie], [
+		#include <linux/fs.h>
+		const char *get_link(struct dentry *de, struct
+		    inode *ip, void **cookie) { return "symlink"; }
+		static struct inode_operations
+		     iops __attribute__ ((unused)) = {
+			.get_link = get_link,
+		};
+	],[])
+
+	ZFS_LINUX_TEST_SRC([inode_operations_follow_link], [
 		#include <linux/fs.h>
 		const char *follow_link(struct dentry *de,
 		    void **cookie) { return "symlink"; }
@@ -15,35 +31,17 @@ AC_DEFUN([ZFS_AC_KERNEL_FOLLOW_LINK], [
 		    iops __attribute__ ((unused)) = {
 			.follow_link = follow_link,
 		};
-	],[
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_FOLLOW_LINK_COOKIE, 1,
-		    [iops->follow_link() cookie])
-	],[
-		dnl #
-		dnl # 2.6.32 API
-		dnl #
-		AC_MSG_RESULT(no)
-		AC_MSG_CHECKING(
-		   [whether iops->follow_link() passes nameidata])
-		ZFS_LINUX_TRY_COMPILE([
+	],[])
+
+	ZFS_LINUX_TEST_SRC([inode_operations_follow_link_nameidata], [
 		#include <linux/fs.h>
-			void *follow_link(struct dentry *de, struct
-			    nameidata *nd) { return (void *)NULL; }
-			static struct inode_operations
-			    iops __attribute__ ((unused)) = {
-				.follow_link = follow_link,
-			};
-		],[
-		],[
-			AC_MSG_RESULT(yes)
-			AC_DEFINE(HAVE_FOLLOW_LINK_NAMEIDATA, 1,
-			          [iops->follow_link() nameidata])
-		],[
-			AC_MSG_ERROR(no; please file a bug report)
-		])
-	])
+		void *follow_link(struct dentry *de, struct
+		    nameidata *nd) { return (void *)NULL; }
+		static struct inode_operations
+		    iops __attribute__ ((unused)) = {
+			.follow_link = follow_link,
+		};
+	],[])
 ])
 
 AC_DEFUN([ZFS_AC_KERNEL_GET_LINK], [
@@ -53,20 +51,12 @@ AC_DEFUN([ZFS_AC_KERNEL_GET_LINK], [
 	dnl # used it to retire the put_link() interface.
 	dnl #
 	AC_MSG_CHECKING([whether iops->get_link() passes delayed])
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/fs.h>
-		const char *get_link(struct dentry *de, struct inode *ip,
-		    struct delayed_call *done) { return "symlink"; }
-		static struct inode_operations
-		     iops __attribute__ ((unused)) = {
-			.get_link = get_link,
-		};
-	],[
-	],[
+	ZFS_LINUX_TEST_RESULT([inode_operations_get_link], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_GET_LINK_DELAYED, 1,
-		    [iops->get_link() delayed])
+		AC_DEFINE(HAVE_GET_LINK_DELAYED, 1, [iops->get_link() delayed])
 	],[
+		AC_MSG_RESULT(no)
+
 		dnl #
 		dnl # 4.5 API change
 		dnl # The follow_link() interface has been replaced by
@@ -74,27 +64,41 @@ AC_DEFUN([ZFS_AC_KERNEL_GET_LINK], [
 		dnl # - An inode is passed as a separate argument
 		dnl # - When called in RCU mode a NULL dentry is passed.
 		dnl #
-		AC_MSG_RESULT(no)
 		AC_MSG_CHECKING([whether iops->get_link() passes cookie])
-		ZFS_LINUX_TRY_COMPILE([
-			#include <linux/fs.h>
-			const char *get_link(struct dentry *de, struct
-			    inode *ip, void **cookie) { return "symlink"; }
-			static struct inode_operations
-			     iops __attribute__ ((unused)) = {
-				.get_link = get_link,
-			};
-		],[
-		],[
+		ZFS_LINUX_TEST_RESULT([inode_operations_get_link_cookie], [
 			AC_MSG_RESULT(yes)
 			AC_DEFINE(HAVE_GET_LINK_COOKIE, 1,
 			    [iops->get_link() cookie])
 		],[
+			AC_MSG_RESULT(no)
+
 			dnl #
-			dnl # Check for the follow_link APIs.
+			dnl # 4.2 API change
+			dnl # This kernel retired the nameidata structure.
 			dnl #
-			AC_MSG_RESULT(no)
-			ZFS_AC_KERNEL_FOLLOW_LINK
+			AC_MSG_CHECKING(
+			    [whether iops->follow_link() passes cookie])
+			ZFS_LINUX_TEST_RESULT([inode_operations_follow_link], [
+				AC_MSG_RESULT(yes)
+				AC_DEFINE(HAVE_FOLLOW_LINK_COOKIE, 1,
+				    [iops->follow_link() cookie])
+			],[
+				AC_MSG_RESULT(no)
+
+				dnl #
+				dnl # 2.6.32 API
+				dnl #
+				AC_MSG_CHECKING(
+				[whether iops->follow_link() passes nameidata])
+				ZFS_LINUX_TEST_RESULT(
+				    [inode_operations_follow_link_nameidata],[
+					AC_MSG_RESULT(yes)
+					AC_DEFINE(HAVE_FOLLOW_LINK_NAMEIDATA, 1,
+					    [iops->follow_link() nameidata])
+				],[
+					ZFS_LINUX_TEST_ERROR([get_link])
+				])
+			])
 		])
 	])
 ])
Index: zfs-linux-0.8.2/config/kernel-global_page_state.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-global_page_state.m4
+++ zfs-linux-0.8.2/config/kernel-global_page_state.m4
@@ -4,16 +4,21 @@ dnl #
 dnl # 75ef71840539 mm, vmstat: add infrastructure for per-node vmstats
 dnl # 599d0c954f91 mm, vmscan: move LRU lists to node
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_GLOBAL_NODE_PAGE_STATE], [
-	AC_MSG_CHECKING([whether global_node_page_state() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_GLOBAL_NODE_PAGE_STATE], [
+	ZFS_LINUX_TEST_SRC([global_node_page_state], [
 		#include <linux/mm.h>
 		#include <linux/vmstat.h>
 	],[
 		(void) global_node_page_state(0);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_GLOBAL_NODE_PAGE_STATE], [
+	AC_MSG_CHECKING([whether global_node_page_state() exists])
+	ZFS_LINUX_TEST_RESULT([global_node_page_state], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(ZFS_GLOBAL_NODE_PAGE_STATE, 1, [global_node_page_state() exists])
+		AC_DEFINE(ZFS_GLOBAL_NODE_PAGE_STATE, 1,
+		    [global_node_page_state() exists])
 	],[
 		AC_MSG_RESULT(no)
 	])
@@ -24,16 +29,21 @@ dnl # 4.14 API change
 dnl #
 dnl # c41f012ade0b mm: rename global_page_state to global_zone_page_state
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_GLOBAL_ZONE_PAGE_STATE], [
-	AC_MSG_CHECKING([whether global_zone_page_state() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_GLOBAL_ZONE_PAGE_STATE], [
+	ZFS_LINUX_TEST_SRC([global_zone_page_state], [
 		#include <linux/mm.h>
 		#include <linux/vmstat.h>
 	],[
 		(void) global_zone_page_state(0);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_GLOBAL_ZONE_PAGE_STATE], [
+	AC_MSG_CHECKING([whether global_zone_page_state() exists])
+	ZFS_LINUX_TEST_RESULT([global_zone_page_state], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(ZFS_GLOBAL_ZONE_PAGE_STATE, 1, [global_zone_page_state() exists])
+		AC_DEFINE(ZFS_GLOBAL_ZONE_PAGE_STATE, 1,
+		    [global_zone_page_state() exists])
 	],[
 		AC_MSG_RESULT(no)
 	])
@@ -44,9 +54,11 @@ dnl # Create a define and autoconf varia
 dnl #
 AC_DEFUN([ZFS_AC_KERNEL_ENUM_MEMBER], [
 	AC_MSG_CHECKING([whether enum $2 contains $1])
-	AS_IF([AC_TRY_COMMAND("${srcdir}/scripts/enum-extract.pl" "$2" "$3" | egrep -qx $1)],[
+	AS_IF([AC_TRY_COMMAND(
+	    "${srcdir}/scripts/enum-extract.pl" "$2" "$3" | egrep -qx $1)],[
 		AC_MSG_RESULT([yes])
-		AC_DEFINE(m4_join([_], [ZFS_ENUM], m4_toupper($2), $1), 1, [enum $2 contains $1])
+		AC_DEFINE(m4_join([_], [ZFS_ENUM], m4_toupper($2), $1), 1,
+		    [enum $2 contains $1])
 		m4_join([_], [ZFS_ENUM], m4_toupper($2), $1)=1
 	],[
 		AC_MSG_RESULT([no])
@@ -59,8 +71,7 @@ dnl #
 AC_DEFUN([ZFS_AC_KERNEL_GLOBAL_PAGE_STATE_ENUM_ERROR],[
 	AC_MSG_RESULT(no)
 	AC_MSG_RESULT([$1 in either node_stat_item or zone_stat_item: $2])
-	AC_MSG_RESULT([configure needs updating, see: config/kernel-global_page_state.m4])
-	AC_MSG_FAILURE([SHUT 'ER DOWN CLANCY, SHE'S PUMPIN' MUD!])
+	ZFS_LINUX_TEST_ERROR([global page state])
 ])
 
 AC_DEFUN([ZFS_AC_KERNEL_GLOBAL_PAGE_STATE_ENUM_CHECK], [
@@ -75,10 +86,10 @@ AC_DEFUN([ZFS_AC_KERNEL_GLOBAL_PAGE_STAT
 ])
 
 dnl #
-dnl # Ensure the config tests are finding one and only one of each enum of interest
+dnl # Ensure the config tests are finding one and only one of each enum.
 dnl #
 AC_DEFUN([ZFS_AC_KERNEL_GLOBAL_ZONE_PAGE_STATE_SANITY], [
-	AC_MSG_CHECKING([global_page_state enums are sane])
+	AC_MSG_CHECKING([whether global_page_state enums are sane])
 
 	ZFS_AC_KERNEL_GLOBAL_PAGE_STATE_ENUM_CHECK([NR_FILE_PAGES])
 	ZFS_AC_KERNEL_GLOBAL_PAGE_STATE_ENUM_CHECK([NR_INACTIVE_ANON])
@@ -88,6 +99,11 @@ AC_DEFUN([ZFS_AC_KERNEL_GLOBAL_ZONE_PAGE
 	AC_MSG_RESULT(yes)
 ])
 
+AC_DEFUN([ZFS_AC_KERNEL_SRC_GLOBAL_PAGE_STATE], [
+	ZFS_AC_KERNEL_SRC_GLOBAL_NODE_PAGE_STATE
+	ZFS_AC_KERNEL_SRC_GLOBAL_ZONE_PAGE_STATE
+])
+
 dnl #
 dnl # enum members in which we're interested
 dnl #
@@ -95,15 +111,23 @@ AC_DEFUN([ZFS_AC_KERNEL_GLOBAL_PAGE_STAT
 	ZFS_AC_KERNEL_GLOBAL_NODE_PAGE_STATE
 	ZFS_AC_KERNEL_GLOBAL_ZONE_PAGE_STATE
 
-	ZFS_AC_KERNEL_ENUM_MEMBER([NR_FILE_PAGES],		[node_stat_item], [$LINUX/include/linux/mmzone.h])
-	ZFS_AC_KERNEL_ENUM_MEMBER([NR_INACTIVE_ANON],		[node_stat_item], [$LINUX/include/linux/mmzone.h])
-	ZFS_AC_KERNEL_ENUM_MEMBER([NR_INACTIVE_FILE],		[node_stat_item], [$LINUX/include/linux/mmzone.h])
-	ZFS_AC_KERNEL_ENUM_MEMBER([NR_SLAB_RECLAIMABLE],	[node_stat_item], [$LINUX/include/linux/mmzone.h])
-
-	ZFS_AC_KERNEL_ENUM_MEMBER([NR_FILE_PAGES],		[zone_stat_item], [$LINUX/include/linux/mmzone.h])
-	ZFS_AC_KERNEL_ENUM_MEMBER([NR_INACTIVE_ANON],		[zone_stat_item], [$LINUX/include/linux/mmzone.h])
-	ZFS_AC_KERNEL_ENUM_MEMBER([NR_INACTIVE_FILE],		[zone_stat_item], [$LINUX/include/linux/mmzone.h])
-	ZFS_AC_KERNEL_ENUM_MEMBER([NR_SLAB_RECLAIMABLE],	[zone_stat_item], [$LINUX/include/linux/mmzone.h])
+	ZFS_AC_KERNEL_ENUM_MEMBER([NR_FILE_PAGES],
+	    [node_stat_item], [$LINUX/include/linux/mmzone.h])
+	ZFS_AC_KERNEL_ENUM_MEMBER([NR_INACTIVE_ANON],
+	    [node_stat_item], [$LINUX/include/linux/mmzone.h])
+	ZFS_AC_KERNEL_ENUM_MEMBER([NR_INACTIVE_FILE],
+	    [node_stat_item], [$LINUX/include/linux/mmzone.h])
+	ZFS_AC_KERNEL_ENUM_MEMBER([NR_SLAB_RECLAIMABLE],
+	    [node_stat_item], [$LINUX/include/linux/mmzone.h])
+
+	ZFS_AC_KERNEL_ENUM_MEMBER([NR_FILE_PAGES],
+	    [zone_stat_item], [$LINUX/include/linux/mmzone.h])
+	ZFS_AC_KERNEL_ENUM_MEMBER([NR_INACTIVE_ANON],
+	    [zone_stat_item], [$LINUX/include/linux/mmzone.h])
+	ZFS_AC_KERNEL_ENUM_MEMBER([NR_INACTIVE_FILE],
+	    [zone_stat_item], [$LINUX/include/linux/mmzone.h])
+	ZFS_AC_KERNEL_ENUM_MEMBER([NR_SLAB_RECLAIMABLE],
+	    [zone_stat_item], [$LINUX/include/linux/mmzone.h])
 
 	ZFS_AC_KERNEL_GLOBAL_ZONE_PAGE_STATE_SANITY
 ])
Index: zfs-linux-0.8.2/config/kernel-group-info.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-group-info.m4
+++ zfs-linux-0.8.2/config/kernel-group-info.m4
@@ -2,20 +2,21 @@ dnl #
 dnl # 4.9 API change
 dnl # group_info changed from 2d array via >blocks to 1d array via ->gid
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_GROUP_INFO_GID], [
-	AC_MSG_CHECKING([whether group_info->gid exists])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_GROUP_INFO_GID], [
+	ZFS_LINUX_TEST_SRC([group_info_gid], [
 		#include <linux/cred.h>
 	],[
 		struct group_info *gi = groups_alloc(1);
 		gi->gid[0] = KGIDT_INIT(0);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_GROUP_INFO_GID], [
+	AC_MSG_CHECKING([whether group_info->gid exists])
+	ZFS_LINUX_TEST_RESULT([group_info_gid], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_GROUP_INFO_GID, 1, [group_info->gid exists])
 	],[
 		AC_MSG_RESULT(no)
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
 ])
Index: zfs-linux-0.8.2/config/kernel-in-compat-syscall.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-in-compat-syscall.m4
+++ zfs-linux-0.8.2/config/kernel-in-compat-syscall.m4
@@ -4,13 +4,17 @@ dnl # Added in_compat_syscall() which ca
 dnl # architecture basis.  Prior to this is_compat_task() was the
 dnl # provided interface.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_IN_COMPAT_SYSCALL], [
-	AC_MSG_CHECKING([whether in_compat_syscall() is available])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_IN_COMPAT_SYSCALL], [
+	ZFS_LINUX_TEST_SRC([in_compat_syscall], [
 		#include <linux/compat.h>
 	],[
 		in_compat_syscall();
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_IN_COMPAT_SYSCALL], [
+	AC_MSG_CHECKING([whether in_compat_syscall() is available])
+	ZFS_LINUX_TEST_RESULT([in_compat_syscall], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_IN_COMPAT_SYSCALL, 1,
 		    [in_compat_syscall() is available])
Index: zfs-linux-0.8.2/config/kernel-inode-getattr.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-inode-getattr.m4
+++ zfs-linux-0.8.2/config/kernel-inode-getattr.m4
@@ -2,9 +2,8 @@ dnl #
 dnl # Linux 4.11 API
 dnl # See torvalds/linux@a528d35
 dnl #
-AC_DEFUN([ZFS_AC_PATH_KERNEL_IOPS_GETATTR], [
-	AC_MSG_CHECKING([whether iops->getattr() takes a path])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_INODE_GETATTR], [
+	ZFS_LINUX_TEST_SRC([inode_operations_getattr_path], [
 		#include <linux/fs.h>
 
 		int test_getattr(
@@ -16,24 +15,9 @@ AC_DEFUN([ZFS_AC_PATH_KERNEL_IOPS_GETATT
 		    iops __attribute__ ((unused)) = {
 			.getattr = test_getattr,
 		};
-	],[
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_PATH_IOPS_GETATTR, 1,
-		    [iops->getattr() takes a path])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
+	],[])
 
-
-dnl #
-dnl # Linux 3.9 - 4.10 API
-dnl #
-AC_DEFUN([ZFS_AC_VFSMOUNT_KERNEL_IOPS_GETATTR], [
-	AC_MSG_CHECKING([whether iops->getattr() takes a vfsmount])
-	ZFS_LINUX_TRY_COMPILE([
+	ZFS_LINUX_TEST_SRC([inode_operations_getattr_vfsmount], [
 		#include <linux/fs.h>
 
 		int test_getattr(
@@ -45,23 +29,25 @@ AC_DEFUN([ZFS_AC_VFSMOUNT_KERNEL_IOPS_GE
 		    iops __attribute__ ((unused)) = {
 			.getattr = test_getattr,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_INODE_GETATTR], [
+	AC_MSG_CHECKING([whether iops->getattr() takes a path])
+	ZFS_LINUX_TEST_RESULT([inode_operations_getattr_path], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_VFSMOUNT_IOPS_GETATTR, 1,
-		    [iops->getattr() takes a vfsmount])
+		AC_DEFINE(HAVE_PATH_IOPS_GETATTR, 1,
+		    [iops->getattr() takes a path])
 	],[
 		AC_MSG_RESULT(no)
-	])
-])
-
 
-dnl #
-dnl # The interface of the getattr callback from the inode_operations
-dnl # structure changed.  Also, the interface of the simple_getattr()
-dnl # function provided by the kernel changed.
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_INODE_OPERATIONS_GETATTR], [
-	ZFS_AC_PATH_KERNEL_IOPS_GETATTR
-	ZFS_AC_VFSMOUNT_KERNEL_IOPS_GETATTR
+		AC_MSG_CHECKING([whether iops->getattr() takes a vfsmount])
+		ZFS_LINUX_TEST_RESULT([inode_operations_getattr_vfsmount], [
+			AC_MSG_RESULT(yes)
+			AC_DEFINE(HAVE_VFSMOUNT_IOPS_GETATTR, 1,
+			    [iops->getattr() takes a vfsmount])
+		],[
+			AC_MSG_RESULT(no)
+		])
+	])
 ])
Index: zfs-linux-0.8.2/config/kernel-inode-lock.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-inode-lock.m4
+++ zfs-linux-0.8.2/config/kernel-inode-lock.m4
@@ -4,20 +4,21 @@ dnl # i_mutex is changed to i_rwsem. Ins
 dnl # i_mutex/i_rwsem, we should use inode_lock() and inode_lock_shared()
 dnl # We test inode_lock_shared because inode_lock is introduced earlier.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_INODE_LOCK], [
-	AC_MSG_CHECKING([whether inode_lock_shared() exists])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_INODE_LOCK], [
+	ZFS_LINUX_TEST_SRC([inode_lock], [
 		#include <linux/fs.h>
 	],[
 		struct inode *inode = NULL;
 		inode_lock_shared(inode);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_INODE_LOCK], [
+	AC_MSG_CHECKING([whether inode_lock_shared() exists])
+	ZFS_LINUX_TEST_RESULT([inode_lock], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_INODE_LOCK_SHARED, 1, [yes])
 	],[
 		AC_MSG_RESULT(no)
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
 ])
Index: zfs-linux-0.8.2/config/kernel-inode-set-flags.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-inode-set-flags.m4
+++ zfs-linux-0.8.2/config/kernel-inode-set-flags.m4
@@ -2,14 +2,18 @@ dnl #
 dnl # 3.15 API change
 dnl # inode_set_flags introduced to set i_flags
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_INODE_SET_FLAGS], [
-	AC_MSG_CHECKING([whether inode_set_flags() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_INODE_SET_FLAGS], [
+	ZFS_LINUX_TEST_SRC([inode_set_flags], [
 		#include <linux/fs.h>
 	],[
 		struct inode inode;
 		inode_set_flags(&inode, S_IMMUTABLE, S_IMMUTABLE);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_INODE_SET_FLAGS], [
+	AC_MSG_CHECKING([whether inode_set_flags() exists])
+	ZFS_LINUX_TEST_RESULT([inode_set_flags], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_INODE_SET_FLAGS, 1, [inode_set_flags() exists])
 	],[
Index: zfs-linux-0.8.2/config/kernel-inode-set-iversion.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-inode-set-iversion.m4
+++ zfs-linux-0.8.2/config/kernel-inode-set-iversion.m4
@@ -2,14 +2,18 @@ dnl #
 dnl # 4.16 API change
 dnl # inode_set_iversion introduced to set i_version
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_INODE_SET_IVERSION], [
-	AC_MSG_CHECKING([whether inode_set_iversion() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_INODE_SET_IVERSION], [
+	ZFS_LINUX_TEST_SRC([inode_set_iversion], [
 		#include <linux/iversion.h>
 	],[
 		struct inode inode;
 		inode_set_iversion(&inode, 1);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_INODE_SET_IVERSION], [
+	AC_MSG_CHECKING([whether inode_set_iversion() exists])
+	ZFS_LINUX_TEST_RESULT([inode_set_iversion], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_INODE_SET_IVERSION, 1,
 		    [inode_set_iversion() exists])
Index: zfs-linux-0.8.2/config/kernel-inode-times.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-inode-times.m4
+++ zfs-linux-0.8.2/config/kernel-inode-times.m4
@@ -2,11 +2,8 @@ dnl #
 dnl # 4.18 API change
 dnl # i_atime, i_mtime, and i_ctime changed from timespec to timespec64.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_INODE_TIMES], [
-	AC_MSG_CHECKING([whether inode->i_*time's are timespec64])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_INODE_TIMES], [
+	ZFS_LINUX_TEST_SRC([inode_times], [
 		#include <linux/fs.h>
 	],[
 		struct inode ip;
@@ -14,12 +11,16 @@ AC_DEFUN([ZFS_AC_KERNEL_INODE_TIMES], [
 
 		memset(&ip, 0, sizeof(ip));
 		ts = ip.i_mtime;
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_INODE_TIMES], [
+	AC_MSG_CHECKING([whether inode->i_*time's are timespec64])
+	ZFS_LINUX_TEST_RESULT([inode_times], [
 		AC_MSG_RESULT(no)
 	],[
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_INODE_TIMESPEC64_TIMES, 1,
 		    [inode->i_*time's are timespec64])
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
 ])
Index: zfs-linux-0.8.2/config/kernel-insert-inode-locked.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-insert-inode-locked.m4
+++ zfs-linux-0.8.2/config/kernel-insert-inode-locked.m4
@@ -2,16 +2,21 @@ dnl #
 dnl # 2.6.28 API change
 dnl # Added insert_inode_locked() helper function.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_INSERT_INODE_LOCKED],
-	[AC_MSG_CHECKING([whether insert_inode_locked() is available])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_INSERT_INODE_LOCKED], [
+	ZFS_LINUX_TEST_SRC([insert_inode_locked], [
 		#include <linux/fs.h>
 	], [
 		insert_inode_locked(NULL);
-	], [insert_inode_locked], [fs/inode.c], [
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_INSERT_INODE_LOCKED], [
+	AC_MSG_CHECKING([whether insert_inode_locked() is available])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([insert_inode_locked],
+	    [insert_inode_locked], [fs/inode.c], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_INSERT_INODE_LOCKED, 1,
-		          [insert_inode_locked() is available])
+		    [insert_inode_locked() is available])
 	], [
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-invalidate-bdev-args.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-invalidate-bdev-args.m4
+++ zfs-linux-0.8.2/config/kernel-invalidate-bdev-args.m4
@@ -2,17 +2,21 @@ dnl #
 dnl # 2.6.22 API change
 dnl # Unused destroy_dirty_buffers arg removed from prototype.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_INVALIDATE_BDEV_ARGS], [
-	AC_MSG_CHECKING([whether invalidate_bdev() wants 1 arg])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_INVALIDATE_BDEV], [
+	ZFS_LINUX_TEST_SRC([invalidate_bdev], [
 		#include <linux/buffer_head.h>
 	],[
 		struct block_device *bdev = NULL;
 		invalidate_bdev(bdev);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_INVALIDATE_BDEV], [
+	AC_MSG_CHECKING([whether invalidate_bdev() wants 1 arg])
+	ZFS_LINUX_TEST_RESULT([invalidate_bdev], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_1ARG_INVALIDATE_BDEV, 1,
-		          [invalidate_bdev() wants 1 arg])
+		    [invalidate_bdev() wants 1 arg])
 	],[
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-is_owner_or_cap.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-is_owner_or_cap.m4
+++ zfs-linux-0.8.2/config/kernel-is_owner_or_cap.m4
@@ -4,33 +4,40 @@ dnl # The is_owner_or_cap() macro was re
 dnl # This is used for permission checks in the xattr and file attribute call
 dnl # paths.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_INODE_OWNER_OR_CAPABLE], [
-	AC_MSG_CHECKING([whether inode_owner_or_capable() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_INODE_OWNER_OR_CAPABLE], [
+	ZFS_LINUX_TEST_SRC([inode_owner_or_capable], [
 		#include <linux/fs.h>
 	],[
 		struct inode *ip = NULL;
 		(void) inode_owner_or_capable(ip);
+	])
+
+
+	ZFS_LINUX_TEST_SRC([is_owner_or_cap], [
+		#include <linux/fs.h>
+		#include <linux/sched.h>
 	],[
+		struct inode *ip = NULL;
+		(void) is_owner_or_cap(ip);
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_INODE_OWNER_OR_CAPABLE], [
+	AC_MSG_CHECKING([whether inode_owner_or_capable() exists])
+	ZFS_LINUX_TEST_RESULT([inode_owner_or_capable], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_INODE_OWNER_OR_CAPABLE, 1,
 		    [inode_owner_or_capable() exists])
 	],[
 		AC_MSG_RESULT(no)
 		AC_MSG_CHECKING([whether is_owner_or_cap() exists])
-		ZFS_LINUX_TRY_COMPILE([
-			#include <linux/fs.h>
-			#include <linux/sched.h>
-		],[
-			struct inode *ip = NULL;
-			(void) is_owner_or_cap(ip);
-		],[
+
+		ZFS_LINUX_TEST_RESULT([is_owner_or_cap], [
 			AC_MSG_RESULT(yes)
 			AC_DEFINE(HAVE_IS_OWNER_OR_CAP, 1,
 			    [is_owner_or_cap() exists])
 		],[
-			AC_MSG_ERROR(no - Please file a bug report at
-			    https://github.com/zfsonlinux/zfs/issues/new)
+			ZFS_LINUX_TEST_ERROR([capability])
 		])
 	])
 ])
Index: zfs-linux-0.8.2/config/kernel-kmap-atomic-args.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-kmap-atomic-args.m4
+++ zfs-linux-0.8.2/config/kernel-kmap-atomic-args.m4
@@ -3,17 +3,21 @@ dnl # 2.6.37 API change
 dnl # kmap_atomic changed from assigning hard-coded named slot to using
 dnl # push/pop based dynamical allocation.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_KMAP_ATOMIC_ARGS], [
-	AC_MSG_CHECKING([whether kmap_atomic wants 1 args])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_KMAP_ATOMIC_ARGS], [
+	ZFS_LINUX_TEST_SRC([kmap_atomic], [
 		#include <linux/pagemap.h>
 	],[
 		struct page page;
 		kmap_atomic(&page);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_KMAP_ATOMIC_ARGS], [
+	AC_MSG_CHECKING([whether kmap_atomic wants 1 args])
+	ZFS_LINUX_TEST_RESULT([kmap_atomic], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_1ARG_KMAP_ATOMIC, 1,
-		          [kmap_atomic wants 1 args])
+		    [kmap_atomic wants 1 args])
 	],[
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-kmem-cache.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-kmem-cache.m4
+++ zfs-linux-0.8.2/config/kernel-kmem-cache.m4
@@ -5,30 +5,36 @@ dnl # private allocation flags which are
 dnl # in kmem_getpages().  Unfortunately there is no public API for setting
 dnl # non-default flags.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_KMEM_CACHE_ALLOCFLAGS], [
-	AC_MSG_CHECKING([whether struct kmem_cache has allocflags])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_KMEM_CACHE_ALLOCFLAGS], [
+	ZFS_LINUX_TEST_SRC([kmem_cache_allocflags], [
 		#include <linux/slab.h>
 	],[
 		struct kmem_cache cachep __attribute__ ((unused));
 		cachep.allocflags = GFP_KERNEL;
+	])
+
+	ZFS_LINUX_TEST_SRC([kmem_cache_gfpflags], [
+		#include <linux/slab.h>
 	],[
+		struct kmem_cache cachep __attribute__ ((unused));
+		cachep.gfpflags = GFP_KERNEL;
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_KMEM_CACHE_ALLOCFLAGS], [
+	AC_MSG_CHECKING([whether struct kmem_cache has allocflags])
+	ZFS_LINUX_TEST_RESULT([kmem_cache_allocflags], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_KMEM_CACHE_ALLOCFLAGS, 1,
-			[struct kmem_cache has allocflags])
+		    [struct kmem_cache has allocflags])
 	],[
 		AC_MSG_RESULT(no)
 
 		AC_MSG_CHECKING([whether struct kmem_cache has gfpflags])
-		ZFS_LINUX_TRY_COMPILE([
-			#include <linux/slab.h>
-		],[
-			struct kmem_cache cachep __attribute__ ((unused));
-			cachep.gfpflags = GFP_KERNEL;
-		],[
+		ZFS_LINUX_TEST_RESULT([kmem_cache_gfpflags], [
 			AC_MSG_RESULT(yes)
 			AC_DEFINE(HAVE_KMEM_CACHE_GFPFLAGS, 1,
-				[struct kmem_cache has gfpflags])
+			    [struct kmem_cache has gfpflags])
 		],[
 			AC_MSG_RESULT(no)
 		])
@@ -40,16 +46,10 @@ dnl # grsecurity API change,
 dnl # kmem_cache_create() with SLAB_USERCOPY flag replaced by
 dnl # kmem_cache_create_usercopy().
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_KMEM_CACHE_CREATE_USERCOPY], [
-	AC_MSG_CHECKING([whether kmem_cache_create_usercopy() exists])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_KMEM_CACHE_CREATE_USERCOPY], [
+	ZFS_LINUX_TEST_SRC([kmem_cache_create_usercopy], [
 		#include <linux/slab.h>
-		static void ctor(void *foo)
-		{
-			// fake ctor
-		}
+		static void ctor(void *foo) { /* fake ctor */ }
 	],[
 		struct kmem_cache *skc_linux_cache;
 		const char *name = "test";
@@ -60,13 +60,27 @@ AC_DEFUN([ZFS_AC_KERNEL_KMEM_CACHE_CREAT
 		size_t usersize = size - useroffset;
 
 		skc_linux_cache = kmem_cache_create_usercopy(
-			name, size, align, flags, useroffset, usersize, ctor);
-	],[
+		    name, size, align, flags, useroffset, usersize, ctor);
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_KMEM_CACHE_CREATE_USERCOPY], [
+	AC_MSG_CHECKING([whether kmem_cache_create_usercopy() exists])
+	ZFS_LINUX_TEST_RESULT([kmem_cache_create_usercopy], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_KMEM_CACHE_CREATE_USERCOPY, 1,
-				[kmem_cache_create_usercopy() exists])
+		    [kmem_cache_create_usercopy() exists])
 	],[
 		AC_MSG_RESULT(no)
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SRC_KMEM_CACHE], [
+	ZFS_AC_KERNEL_SRC_KMEM_CACHE_ALLOCFLAGS
+	ZFS_AC_KERNEL_SRC_KMEM_CACHE_CREATE_USERCOPY
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_KMEM_CACHE], [
+	ZFS_AC_KERNEL_KMEM_CACHE_ALLOCFLAGS
+	ZFS_AC_KERNEL_KMEM_CACHE_CREATE_USERCOPY
 ])
Index: zfs-linux-0.8.2/config/kernel-kstrtoul.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-kstrtoul.m4
+++ zfs-linux-0.8.2/config/kernel-kstrtoul.m4
@@ -1,18 +1,20 @@
 dnl #
 dnl # 2.6.39 API change
 dnl #
-dnl # 33ee3b2e2eb9 kstrto*: converting strings to integers done (hopefully) right
-dnl #
 dnl # If kstrtoul() doesn't exist, fallback to use strict_strtoul() which has
 dnl # existed since 2.6.25.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_KSTRTOUL], [
-	AC_MSG_CHECKING([whether kstrtoul() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_KSTRTOUL], [
+	ZFS_LINUX_TEST_SRC([kstrtoul], [
 		#include <linux/kernel.h>
 	],[
 		int ret __attribute__ ((unused)) = kstrtoul(NULL, 10, NULL);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_KSTRTOUL], [
+	AC_MSG_CHECKING([whether kstrtoul() exists])
+	ZFS_LINUX_TEST_RESULT([kstrtoul], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_KSTRTOUL, 1, [kstrtoul() exists])
 	],[
Index: zfs-linux-0.8.2/config/kernel-ktime_get_coarse_real_ts64.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-ktime_get_coarse_real_ts64.m4
+++ zfs-linux-0.8.2/config/kernel-ktime_get_coarse_real_ts64.m4
@@ -2,16 +2,21 @@ dnl #
 dnl # 4.18: ktime_get_coarse_real_ts64() added.  Use it in place of
 dnl # current_kernel_time64().
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_KTIME_GET_COARSE_REAL_TS64],
-	[AC_MSG_CHECKING([whether ktime_get_coarse_real_ts64() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_KTIME_GET_COARSE_REAL_TS64], [
+	ZFS_LINUX_TEST_SRC([ktime_get_coarse_real_ts64], [
 		#include <linux/mm.h>
 	], [
 		struct timespec64 ts;
 		ktime_get_coarse_real_ts64(&ts);
-	], [
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_KTIME_GET_COARSE_REAL_TS64], [
+	AC_MSG_CHECKING([whether ktime_get_coarse_real_ts64() exists])
+	ZFS_LINUX_TEST_RESULT([ktime_get_coarse_real_ts64], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_KTIME_GET_COARSE_REAL_TS64, 1, [ktime_get_coarse_real_ts64() exists])
+		AC_DEFINE(HAVE_KTIME_GET_COARSE_REAL_TS64, 1,
+		    [ktime_get_coarse_real_ts64() exists])
 	], [
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-kuid-helpers.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-kuid-helpers.m4
+++ zfs-linux-0.8.2/config/kernel-kuid-helpers.m4
@@ -5,14 +5,18 @@ dnl # became necessary to go through one
 dnl # when dealing with uid/gid - namely the kuid type.
 dnl #
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_KUID_HELPERS], [
-	AC_MSG_CHECKING([whether i_(uid|gid)_(read|write) exist])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_KUID_HELPERS], [
+	ZFS_LINUX_TEST_SRC([i_uid_read], [
 		#include <linux/fs.h>
 	],[
 		struct inode *ip = NULL;
 		(void) i_uid_read(ip);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_KUID_HELPERS], [
+	AC_MSG_CHECKING([whether i_(uid|gid)_(read|write) exist])
+	ZFS_LINUX_TEST_RESULT([i_uid_read], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_KUID_HELPERS, 1,
 		    [i_(uid|gid)_(read|write) exist])
Index: zfs-linux-0.8.2/config/kernel-kuidgid.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-kuidgid.m4
+++ zfs-linux-0.8.2/config/kernel-kuidgid.m4
@@ -3,20 +3,26 @@ dnl # User namespaces, use kuid_t in pla
 dnl # where available. Not strictly a user namespaces thing
 dnl # but it should prevent surprises
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_KUIDGID_T], [
-	AC_MSG_CHECKING([whether kuid_t/kgid_t is available])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_KUIDGID_T], [
+	ZFS_LINUX_TEST_SRC([kuidgid_t_init], [
 		#include <linux/uidgid.h>
 	], [
 		kuid_t userid __attribute__ ((unused)) = KUIDT_INIT(0);
 		kgid_t groupid __attribute__ ((unused)) = KGIDT_INIT(0);
-	],[
-		ZFS_LINUX_TRY_COMPILE([
-			#include <linux/uidgid.h>
-		], [
-			kuid_t userid __attribute__ ((unused)) = 0;
-			kgid_t groupid __attribute__ ((unused)) = 0;
-		],[
+	])
+
+	ZFS_LINUX_TEST_SRC([kuidgid_t], [
+		#include <linux/uidgid.h>
+	], [
+		kuid_t userid __attribute__ ((unused)) = 0;
+		kgid_t groupid __attribute__ ((unused)) = 0;
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_KUIDGID_T], [
+	AC_MSG_CHECKING([whether kuid_t/kgid_t is available])
+	ZFS_LINUX_TEST_RESULT([kuidgid_t_init], [
+		ZFS_LINUX_TEST_RESULT([kuidgid_t], [
 			AC_MSG_RESULT(yes; optional)
 		],[
 			AC_MSG_RESULT(yes; mandatory)
Index: zfs-linux-0.8.2/config/kernel-lookup-bdev.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-lookup-bdev.m4
+++ zfs-linux-0.8.2/config/kernel-lookup-bdev.m4
@@ -2,23 +2,33 @@ dnl #
 dnl # 2.6.27, lookup_bdev() was exported.
 dnl # 4.4.0-6.21 - x.y on Ubuntu, lookup_bdev() takes 2 arguments.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_LOOKUP_BDEV],
-	[AC_MSG_CHECKING([whether lookup_bdev() wants 1 arg])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_LOOKUP_BDEV], [
+	ZFS_LINUX_TEST_SRC([lookup_bdev_1arg], [
 		#include <linux/fs.h>
 	], [
 		lookup_bdev(NULL);
-	], [lookup_bdev], [fs/block_dev.c], [
+	])
+
+	ZFS_LINUX_TEST_SRC([lookup_bdev_2args], [
+		#include <linux/fs.h>
+	], [
+		lookup_bdev(NULL, FMODE_READ);
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_LOOKUP_BDEV], [
+	AC_MSG_CHECKING([whether lookup_bdev() wants 1 arg])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([lookup_bdev_1arg],
+	    [lookup_bdev], [fs/block_dev.c], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_1ARG_LOOKUP_BDEV, 1, [lookup_bdev() wants 1 arg])
+		AC_DEFINE(HAVE_1ARG_LOOKUP_BDEV, 1,
+		    [lookup_bdev() wants 1 arg])
 	], [
 		AC_MSG_RESULT(no)
+
 		AC_MSG_CHECKING([whether lookup_bdev() wants 2 args])
-		ZFS_LINUX_TRY_COMPILE_SYMBOL([
-			#include <linux/fs.h>
-		], [
-			lookup_bdev(NULL, FMODE_READ);
-		], [lookup_bdev], [fs/block_dev.c], [
+		ZFS_LINUX_TEST_RESULT_SYMBOL([lookup_bdev_2args],
+		    [lookup_bdev], [fs/block_dev.c], [
 			AC_MSG_RESULT(yes)
 			AC_DEFINE(HAVE_2ARGS_LOOKUP_BDEV, 1,
 			    [lookup_bdev() wants 2 args])
@@ -26,4 +36,4 @@ AC_DEFUN([ZFS_AC_KERNEL_LOOKUP_BDEV],
 			AC_MSG_RESULT(no)
 		])
 	])
-])
\ No newline at end of file
+])
Index: zfs-linux-0.8.2/config/kernel-lookup-nameidata.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-lookup-nameidata.m4
+++ zfs-linux-0.8.2/config/kernel-lookup-nameidata.m4
@@ -1,9 +1,8 @@
 dnl #
 dnl # 3.6 API change
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_LOOKUP_NAMEIDATA], [
-	AC_MSG_CHECKING([whether iops->lookup() passes nameidata])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_LOOKUP_NAMEIDATA], [
+	ZFS_LINUX_TEST_SRC([lookup_nameidata], [
 		#include <linux/fs.h>
 		#include <linux/sched.h>
 
@@ -15,11 +14,15 @@ AC_DEFUN([ZFS_AC_KERNEL_LOOKUP_NAMEIDATA
 		    __attribute__ ((unused)) = {
 			.lookup	= inode_lookup,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_LOOKUP_NAMEIDATA], [
+	AC_MSG_CHECKING([whether iops->lookup() passes nameidata])
+	ZFS_LINUX_TEST_RESULT([lookup_nameidata], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_LOOKUP_NAMEIDATA, 1,
-		          [iops->lookup() passes nameidata])
+		    [iops->lookup() passes nameidata])
 	],[
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-lseek-execute.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-lseek-execute.m4
+++ zfs-linux-0.8.2/config/kernel-lseek-execute.m4
@@ -2,9 +2,8 @@ dnl #
 dnl # 3.11 API change
 dnl # lseek_execute helper exported
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_LSEEK_EXECUTE],
-	[AC_MSG_CHECKING([whether lseek_execute() is available])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_LSEEK_EXECUTE], [
+	ZFS_LINUX_TEST_SRC([lseek_execute], [
 		#include <linux/fs.h>
 	], [
 		struct file *fp __attribute__ ((unused)) = NULL;
@@ -13,10 +12,15 @@ AC_DEFUN([ZFS_AC_KERNEL_LSEEK_EXECUTE],
 		loff_t maxsize __attribute__ ((unused)) = 0;
 
 		lseek_execute(fp, ip, offset, maxsize);
-	], [lseek_exclusive], [fs/read_write.c], [
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_LSEEK_EXECUTE], [
+	AC_MSG_CHECKING([whether lseek_execute() is available])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([lseek_execute],
+	    [lseek_exclusive], [fs/read_write.c], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_LSEEK_EXECUTE, 1,
-		          [lseek_execute() is available])
+		AC_DEFINE(HAVE_LSEEK_EXECUTE, 1, [lseek_execute() is available])
 	], [
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-make-request-fn.m4
===================================================================
--- /dev/null
+++ zfs-linux-0.8.2/config/kernel-make-request-fn.m4
@@ -0,0 +1,77 @@
+dnl #
+dnl # Check for make_request_fn interface.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_MAKE_REQUEST_FN], [
+	ZFS_LINUX_TEST_SRC([make_request_fn_int], [
+		#include <linux/blkdev.h>
+		int make_request(struct request_queue *q,
+		    struct bio *bio) { return (0); }
+	],[
+		blk_queue_make_request(NULL, &make_request);
+	])
+
+	ZFS_LINUX_TEST_SRC([make_request_fn_void], [
+		#include <linux/blkdev.h>
+		void make_request(struct request_queue *q,
+		    struct bio *bio) { return; }
+	],[
+		blk_queue_make_request(NULL, &make_request);
+	])
+
+	ZFS_LINUX_TEST_SRC([make_request_fn_blk_qc_t], [
+		#include <linux/blkdev.h>
+		blk_qc_t make_request(struct request_queue *q,
+		    struct bio *bio) { return (BLK_QC_T_NONE); }
+	],[
+		blk_queue_make_request(NULL, &make_request);
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_MAKE_REQUEST_FN], [
+	dnl #
+	dnl # Legacy API
+	dnl # make_request_fn returns int.
+	dnl #
+	AC_MSG_CHECKING([whether make_request_fn() returns int])
+	ZFS_LINUX_TEST_RESULT([make_request_fn_int], [
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(MAKE_REQUEST_FN_RET, int,
+		    [make_request_fn() return type])
+		AC_DEFINE(HAVE_MAKE_REQUEST_FN_RET_INT, 1,
+		    [Noting that make_request_fn() returns int])
+	],[
+		AC_MSG_RESULT(no)
+
+		dnl #
+		dnl # Linux 3.2 API Change
+		dnl # make_request_fn returns void.
+		dnl #
+		AC_MSG_CHECKING([whether make_request_fn() returns void])
+		ZFS_LINUX_TEST_RESULT([make_request_fn_void], [
+			AC_MSG_RESULT(yes)
+			AC_DEFINE(MAKE_REQUEST_FN_RET, void,
+			    [make_request_fn() return type])
+			AC_DEFINE(HAVE_MAKE_REQUEST_FN_RET_VOID, 1,
+			    [Noting that make_request_fn() returns void])
+		],[
+			AC_MSG_RESULT(no)
+
+			dnl #
+			dnl # Linux 4.4 API Change
+			dnl # make_request_fn returns blk_qc_t.
+			dnl #
+			AC_MSG_CHECKING(
+			    [whether make_request_fn() returns blk_qc_t])
+			ZFS_LINUX_TEST_RESULT([make_request_fn_blk_qc_t], [
+				AC_MSG_RESULT(yes)
+				AC_DEFINE(MAKE_REQUEST_FN_RET, blk_qc_t,
+				    [make_request_fn() return type])
+				AC_DEFINE(HAVE_MAKE_REQUEST_FN_RET_QC, 1,
+				    [Noting that make_request_fn() ]
+				    [returns blk_qc_t])
+			],[
+				ZFS_LINUX_TEST_ERROR([make_request_fn])
+			])
+		])
+	])
+])
Index: zfs-linux-0.8.2/config/kernel-misc-minor.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-misc-minor.m4
+++ zfs-linux-0.8.2/config/kernel-misc-minor.m4
@@ -6,7 +6,7 @@ dnl # number.  Start with a large known
 dnl # our way down to lower value if a collision is detected.
 dnl #
 AC_DEFUN([ZFS_AC_KERNEL_MISC_MINOR], [
-	AC_MSG_CHECKING([for available /dev/zfs minor])
+	AC_MSG_CHECKING([whether /dev/zfs minor is available])
 
 	for i in $(seq 249 -1 200); do
 		if ! grep -q "^#define\s\+.*_MINOR\s\+.*$i" \
Index: zfs-linux-0.8.2/config/kernel-mk-request-fn.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-mk-request-fn.m4
+++ /dev/null
@@ -1,65 +0,0 @@
-dnl #
-dnl # Linux 3.2 API Change
-dnl # make_request_fn returns void instead of int.
-dnl #
-dnl # Linux 4.4 API Change
-dnl # make_request_fn returns blk_qc_t.
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_MAKE_REQUEST_FN], [
-	AC_MSG_CHECKING([whether make_request_fn() returns int])
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/blkdev.h>
-
-		int make_request(struct request_queue *q, struct bio *bio)
-		{
-			return (0);
-		}
-	],[
-		blk_queue_make_request(NULL, &make_request);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(MAKE_REQUEST_FN_RET, int,
-		    [make_request_fn() returns int])
-		AC_DEFINE(HAVE_MAKE_REQUEST_FN_RET_INT, 1,
-		    [Noting that make_request_fn() returns int])
-	],[
-		AC_MSG_RESULT(no)
-		AC_MSG_CHECKING([whether make_request_fn() returns void])
-		ZFS_LINUX_TRY_COMPILE([
-			#include <linux/blkdev.h>
-
-			void make_request(struct request_queue *q, struct bio *bio)
-			{
-				return;
-			}
-		],[
-			blk_queue_make_request(NULL, &make_request);
-		],[
-			AC_MSG_RESULT(yes)
-			AC_DEFINE(MAKE_REQUEST_FN_RET, void,
-			    [make_request_fn() returns void])
-		],[
-			AC_MSG_RESULT(no)
-			AC_MSG_CHECKING([whether make_request_fn() returns blk_qc_t])
-			ZFS_LINUX_TRY_COMPILE([
-				#include <linux/blkdev.h>
-
-				blk_qc_t make_request(struct request_queue *q, struct bio *bio)
-				{
-					return (BLK_QC_T_NONE);
-				}
-			],[
-				blk_queue_make_request(NULL, &make_request);
-			],[
-				AC_MSG_RESULT(yes)
-				AC_DEFINE(MAKE_REQUEST_FN_RET, blk_qc_t,
-				    [make_request_fn() returns blk_qc_t])
-				AC_DEFINE(HAVE_MAKE_REQUEST_FN_RET_QC, 1,
-				    [Noting that make_request_fn() returns blk_qc_t])
-			],[
-				AC_MSG_ERROR(no - Please file a bug report at
-				    https://github.com/zfsonlinux/zfs/issues/new)
-			])
-		])
-	])
-])
Index: zfs-linux-0.8.2/config/kernel-mkdir-umode-t.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-mkdir-umode-t.m4
+++ zfs-linux-0.8.2/config/kernel-mkdir-umode-t.m4
@@ -6,9 +6,8 @@ dnl # would also change all three protot
 dnl # some distribution doesn't backport the whole thing this could be
 dnl # broken apart in to three separate checks.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_MKDIR_UMODE_T], [
-	AC_MSG_CHECKING([whether iops->create()/mkdir()/mknod() take umode_t])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_MKDIR_UMODE_T], [
+	ZFS_LINUX_TEST_SRC([inode_operations_mkdir], [
 		#include <linux/fs.h>
 
 		int mkdir(struct inode *inode, struct dentry *dentry,
@@ -18,8 +17,12 @@ AC_DEFUN([ZFS_AC_KERNEL_MKDIR_UMODE_T],
 		    iops __attribute__ ((unused)) = {
 			.mkdir = mkdir,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_MKDIR_UMODE_T], [
+	AC_MSG_CHECKING([whether iops->create()/mkdir()/mknod() take umode_t])
+	ZFS_LINUX_TEST_RESULT([inode_operations_mkdir], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_MKDIR_UMODE_T, 1,
 		    [iops->create()/mkdir()/mknod() take umode_t])
Index: zfs-linux-0.8.2/config/kernel-mod-param.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-mod-param.m4
+++ zfs-linux-0.8.2/config/kernel-mod-param.m4
@@ -2,9 +2,8 @@ dnl #
 dnl # Grsecurity kernel API change
 dnl # constified parameters of module_param_call() methods
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_MODULE_PARAM_CALL_CONST], [
-	AC_MSG_CHECKING([whether module_param_call() is hardened])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_MODULE_PARAM_CALL_CONST], [
+	ZFS_LINUX_TEST_SRC([module_param_call], [
 		#include <linux/module.h>
 		#include <linux/moduleparam.h>
 
@@ -19,8 +18,12 @@ AC_DEFUN([ZFS_AC_KERNEL_MODULE_PARAM_CAL
 		}
 
 		module_param_call(p, param_set, param_get, NULL, 0644);
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_MODULE_PARAM_CALL_CONST], [
+	AC_MSG_CHECKING([whether module_param_call() is hardened])
+	ZFS_LINUX_TEST_RESULT([module_param_call], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(MODULE_PARAM_CALL_CONST, 1,
 		    [hardened module_param_call])
Index: zfs-linux-0.8.2/config/kernel-objtool.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-objtool.m4
+++ zfs-linux-0.8.2/config/kernel-objtool.m4
@@ -1,41 +1,44 @@
 dnl #
-dnl # 4.6 API for compile-time stack validation
+dnl # Check for objtool support.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_OBJTOOL], [
-	AC_MSG_CHECKING([for compile-time stack validation (objtool)])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_OBJTOOL], [
+
+	dnl # 4.6 API for compile-time stack validation
+	ZFS_LINUX_TEST_SRC([objtool], [
 		#undef __ASSEMBLY__
 		#include <asm/frame.h>
 	],[
 		#if !defined(FRAME_BEGIN)
 		CTASSERT(1);
 		#endif
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_KERNEL_OBJTOOL, 1,
-		    [kernel does stack verification])
-
-		ZFS_AC_KERNEL_STACK_FRAME_NON_STANDARD
-	],[
-		AC_MSG_RESULT(no)
 	])
-])
 
-dnl #
-dnl # 4.6 API added STACK_FRAME_NON_STANDARD macro
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_STACK_FRAME_NON_STANDARD], [
-	AC_MSG_CHECKING([whether STACK_FRAME_NON_STANDARD is defined])
-	ZFS_LINUX_TRY_COMPILE([
+	dnl # 4.6 API added STACK_FRAME_NON_STANDARD macro
+	ZFS_LINUX_TEST_SRC([stack_frame_non_standard], [
 		#include <linux/frame.h>
 	],[
 		#if !defined(STACK_FRAME_NON_STANDARD)
 		CTASSERT(1);
 		#endif
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_OBJTOOL], [
+	AC_MSG_CHECKING(
+	    [whether compile-time stack validation (objtool) is available])
+	ZFS_LINUX_TEST_RESULT([objtool], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_STACK_FRAME_NON_STANDARD, 1,
-		   [STACK_FRAME_NON_STANDARD is defined])
+		AC_DEFINE(HAVE_KERNEL_OBJTOOL, 1,
+		    [kernel does stack verification])
+
+		AC_MSG_CHECKING([whether STACK_FRAME_NON_STANDARD is defined])
+		ZFS_LINUX_TEST_RESULT([stack_frame_non_standard], [
+			AC_MSG_RESULT(yes)
+			AC_DEFINE(HAVE_STACK_FRAME_NON_STANDARD, 1,
+			   [STACK_FRAME_NON_STANDARD is defined])
+		],[
+			AC_MSG_RESULT(no)
+		])
 	],[
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-open-bdev-exclusive.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-open-bdev-exclusive.m4
+++ zfs-linux-0.8.2/config/kernel-open-bdev-exclusive.m4
@@ -2,16 +2,21 @@ dnl #
 dnl # 2.6.28 API change
 dnl # open/close_bdev_excl() renamed to open/close_bdev_exclusive()
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_OPEN_BDEV_EXCLUSIVE],
-	[AC_MSG_CHECKING([whether open_bdev_exclusive() is available])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_BDEV_OPEN_EXCLUSIVE], [
+	ZFS_LINUX_TEST_SRC([open_bdev_exclusive], [
 		#include <linux/fs.h>
 	], [
 		open_bdev_exclusive(NULL, 0, NULL);
-	], [open_bdev_exclusive], [fs/block_dev.c], [
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_BDEV_OPEN_EXCLUSIVE], [
+	AC_MSG_CHECKING([whether open_bdev_exclusive() is available])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([open_bdev_exclusive],
+	    [open_bdev_exclusive], [fs/block_dev.c], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_OPEN_BDEV_EXCLUSIVE, 1,
-		          [open_bdev_exclusive() is available])
+		    [open_bdev_exclusive() is available])
 	], [
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-pde-data.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-pde-data.m4
+++ zfs-linux-0.8.2/config/kernel-pde-data.m4
@@ -2,15 +2,19 @@ dnl #
 dnl # 3.10 API change,
 dnl # PDE is replaced by PDE_DATA
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_PDE_DATA], [
-	AC_MSG_CHECKING([whether PDE_DATA() is available])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_PDE_DATA], [
+	ZFS_LINUX_TEST_SRC([pde_data], [
 		#include <linux/proc_fs.h>
 	], [
 		PDE_DATA(NULL);
-	], [PDE_DATA], [], [
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_PDE_DATA], [
+	AC_MSG_CHECKING([whether PDE_DATA() is available])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([pde_data], [PDE_DATA], [], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_PDE_DATA, 1, [yes])
+		AC_DEFINE(HAVE_PDE_DATA, 1, [PDE_DATA is available])
 	],[
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-put-link.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-put-link.m4
+++ zfs-linux-0.8.2/config/kernel-put-link.m4
@@ -1,17 +1,35 @@
 dnl #
 dnl # Supported symlink APIs
 dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_PUT_LINK], [
+	ZFS_LINUX_TEST_SRC([put_link_cookie], [
+		#include <linux/fs.h>
+		void put_link(struct inode *ip, void *cookie)
+		    { return; }
+		static struct inode_operations
+		    iops __attribute__ ((unused)) = {
+			.put_link = put_link,
+		};
+	],[])
+
+	ZFS_LINUX_TEST_SRC([put_link_nameidata], [
+		#include <linux/fs.h>
+		void put_link(struct dentry *de, struct
+		    nameidata *nd, void *ptr) { return; }
+		static struct inode_operations
+		    iops __attribute__ ((unused)) = {
+			.put_link = put_link,
+		};
+	],[])
+])
+
 AC_DEFUN([ZFS_AC_KERNEL_PUT_LINK], [
 	dnl #
 	dnl # 4.5 API change
 	dnl # get_link() uses delayed done, there is no put_link() interface.
+	dnl # This check intially uses the inode_operations_get_link result
 	dnl #
-	ZFS_LINUX_TRY_COMPILE([
-		#if !defined(HAVE_GET_LINK_DELAYED)
-		#error "Expecting get_link() delayed done"
-		#endif
-	],[
-	],[
+	ZFS_LINUX_TEST_RESULT([inode_operations_get_link], [
 		AC_DEFINE(HAVE_PUT_LINK_DELAYED, 1, [iops->put_link() delayed])
 	],[
 		dnl #
@@ -19,41 +37,24 @@ AC_DEFUN([ZFS_AC_KERNEL_PUT_LINK], [
 		dnl # This kernel retired the nameidata structure.
 		dnl #
 		AC_MSG_CHECKING([whether iops->put_link() passes cookie])
-		ZFS_LINUX_TRY_COMPILE([
-			#include <linux/fs.h>
-			void put_link(struct inode *ip, void *cookie)
-			    { return; }
-			static struct inode_operations
-			    iops __attribute__ ((unused)) = {
-				.put_link = put_link,
-			};
-		],[
-		],[
+		ZFS_LINUX_TEST_RESULT([put_link_cookie], [
 			AC_MSG_RESULT(yes)
 			AC_DEFINE(HAVE_PUT_LINK_COOKIE, 1,
 			    [iops->put_link() cookie])
 		],[
+			AC_MSG_RESULT(no)
+
 			dnl #
 			dnl # 2.6.32 API
 			dnl #
-			AC_MSG_RESULT(no)
 			AC_MSG_CHECKING(
 			    [whether iops->put_link() passes nameidata])
-			ZFS_LINUX_TRY_COMPILE([
-				#include <linux/fs.h>
-				void put_link(struct dentry *de, struct
-				    nameidata *nd, void *ptr) { return; }
-				static struct inode_operations
-				    iops __attribute__ ((unused)) = {
-					.put_link = put_link,
-				};
-			],[
-			],[
+			ZFS_LINUX_TEST_RESULT([put_link_nameidata], [
 				AC_MSG_RESULT(yes)
 				AC_DEFINE(HAVE_PUT_LINK_NAMEIDATA, 1,
 				    [iops->put_link() nameidata])
 			],[
-				AC_MSG_ERROR(no; please file a bug report)
+				ZFS_LINUX_TEST_ERROR([put_link])
 			])
 		])
 	])
Index: zfs-linux-0.8.2/config/kernel-rename.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-rename.m4
+++ zfs-linux-0.8.2/config/kernel-rename.m4
@@ -3,9 +3,8 @@ dnl # 4.9 API change,
 dnl # iops->rename2() merged into iops->rename(), and iops->rename() now wants
 dnl # flags.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_RENAME_WANTS_FLAGS], [
-	AC_MSG_CHECKING([whether iops->rename() wants flags])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_RENAME_WANTS_FLAGS], [
+	ZFS_LINUX_TEST_SRC([inode_operations_rename], [
 		#include <linux/fs.h>
 		int rename_fn(struct inode *sip, struct dentry *sdp,
 			struct inode *tip, struct dentry *tdp,
@@ -15,10 +14,15 @@ AC_DEFUN([ZFS_AC_KERNEL_RENAME_WANTS_FLA
 		    iops __attribute__ ((unused)) = {
 			.rename = rename_fn,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_RENAME_WANTS_FLAGS], [
+	AC_MSG_CHECKING([whether iops->rename() wants flags])
+	ZFS_LINUX_TEST_RESULT([inode_operations_rename], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_RENAME_WANTS_FLAGS, 1, [iops->rename() wants flags])
+		AC_DEFINE(HAVE_RENAME_WANTS_FLAGS, 1,
+		    [iops->rename() wants flags])
 	],[
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-rw.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-rw.m4
+++ zfs-linux-0.8.2/config/kernel-rw.m4
@@ -3,11 +3,8 @@ dnl # 4.14 API change
 dnl # kernel_write() which was introduced in 3.9 was updated to take
 dnl # the offset as a pointer which is needed by vn_rdwr().
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_WRITE], [
-	AC_MSG_CHECKING([whether kernel_write() takes loff_t pointer])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_WRITE], [
+	ZFS_LINUX_TEST_SRC([kernel_write], [
 		#include <linux/fs.h>
 	],[
 		struct file *file = NULL;
@@ -17,14 +14,18 @@ AC_DEFUN([ZFS_AC_KERNEL_WRITE], [
 		ssize_t ret;
 
 		ret = kernel_write(file, buf, count, pos);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_WRITE], [
+	AC_MSG_CHECKING([whether kernel_write() takes loff_t pointer])
+	ZFS_LINUX_TEST_RESULT([kernel_write], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_KERNEL_WRITE_PPOS, 1,
 		    [kernel_write() take loff_t pointer])
 	],[
 		AC_MSG_RESULT(no)
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
 ])
 
 dnl #
@@ -32,11 +33,8 @@ dnl # 4.14 API change
 dnl # kernel_read() which has existed for forever was updated to take
 dnl # the offset as a pointer which is needed by vn_rdwr().
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_READ], [
-	AC_MSG_CHECKING([whether kernel_read() takes loff_t pointer])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_READ], [
+	ZFS_LINUX_TEST_SRC([kernel_read], [
 		#include <linux/fs.h>
 	],[
 		struct file *file = NULL;
@@ -46,12 +44,26 @@ AC_DEFUN([ZFS_AC_KERNEL_READ], [
 		ssize_t ret;
 
 		ret = kernel_read(file, buf, count, pos);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_READ], [
+	AC_MSG_CHECKING([whether kernel_read() takes loff_t pointer])
+	ZFS_LINUX_TEST_RESULT([kernel_read], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_KERNEL_READ_PPOS, 1,
 		    [kernel_read() take loff_t pointer])
 	],[
 		AC_MSG_RESULT(no)
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SRC_RW], [
+	ZFS_AC_KERNEL_SRC_WRITE
+	ZFS_AC_KERNEL_SRC_READ
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_RW], [
+	ZFS_AC_KERNEL_WRITE
+	ZFS_AC_KERNEL_READ
 ])
Index: zfs-linux-0.8.2/config/kernel-rwsem.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-rwsem.m4
+++ zfs-linux-0.8.2/config/kernel-rwsem.m4
@@ -4,25 +4,26 @@ dnl #
 dnl # The rw_semaphore.wait_lock member was changed from spinlock_t to
 dnl # raw_spinlock_t at commit ddb6c9b58a19edcfac93ac670b066c836ff729f1.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_RWSEM_SPINLOCK_IS_RAW], [
-	AC_MSG_CHECKING([whether struct rw_semaphore member wait_lock is raw])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_RWSEM_SPINLOCK_IS_RAW], [
+	ZFS_LINUX_TEST_SRC([rwsem_spinlock_is_raw], [
 		#include <linux/rwsem.h>
 	],[
 		struct rw_semaphore dummy_semaphore __attribute__ ((unused));
 		raw_spinlock_t dummy_lock __attribute__ ((unused)) =
 		    __RAW_SPIN_LOCK_INITIALIZER(dummy_lock);
 		dummy_semaphore.wait_lock = dummy_lock;
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_RWSEM_SPINLOCK_IS_RAW], [
+	AC_MSG_CHECKING([whether struct rw_semaphore member wait_lock is raw])
+	ZFS_LINUX_TEST_RESULT([rwsem_spinlock_is_raw], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(RWSEM_SPINLOCK_IS_RAW, 1,
-		[struct rw_semaphore member wait_lock is raw_spinlock_t])
+		    [struct rw_semaphore member wait_lock is raw_spinlock_t])
 	],[
 		AC_MSG_RESULT(no)
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
 ])
 
 dnl #
@@ -30,23 +31,24 @@ dnl # 3.16 API Change
 dnl #
 dnl # rwsem-spinlock "->activity" changed to "->count"
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_RWSEM_ACTIVITY], [
-	AC_MSG_CHECKING([whether struct rw_semaphore has member activity])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_RWSEM_ACTIVITY], [
+	ZFS_LINUX_TEST_SRC([rwsem_activity], [
 		#include <linux/rwsem.h>
 	],[
 		struct rw_semaphore dummy_semaphore __attribute__ ((unused));
 		dummy_semaphore.activity = 0;
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_RWSEM_ACTIVITY], [
+	AC_MSG_CHECKING([whether struct rw_semaphore has member activity])
+	ZFS_LINUX_TEST_RESULT([rwsem_activity], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_RWSEM_ACTIVITY, 1,
-		[struct rw_semaphore has member activity])
+		    [struct rw_semaphore has member activity])
 	],[
 		AC_MSG_RESULT(no)
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
 ])
 
 dnl #
@@ -54,22 +56,35 @@ dnl # 4.8 API Change
 dnl #
 dnl # rwsem "->count" changed to atomic_long_t type
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_RWSEM_ATOMIC_LONG_COUNT], [
-	AC_MSG_CHECKING(
-	[whether struct rw_semaphore has atomic_long_t member count])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_RWSEM_ATOMIC_LONG_COUNT], [
+	ZFS_LINUX_TEST_SRC([rwsem_atomic_long_count], [
 		#include <linux/rwsem.h>
 	],[
 		DECLARE_RWSEM(dummy_semaphore);
 		(void) atomic_long_read(&dummy_semaphore.count);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_RWSEM_ATOMIC_LONG_COUNT], [
+	AC_MSG_CHECKING(
+	    [whether struct rw_semaphore has atomic_long_t member count])
+	ZFS_LINUX_TEST_RESULT([rwsem_atomic_long_count], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_RWSEM_ATOMIC_LONG_COUNT, 1,
-		[struct rw_semaphore has atomic_long_t member count])
+		    [struct rw_semaphore has atomic_long_t member count])
 	],[
 		AC_MSG_RESULT(no)
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SRC_RWSEM], [
+	ZFS_AC_KERNEL_SRC_RWSEM_SPINLOCK_IS_RAW
+	ZFS_AC_KERNEL_SRC_RWSEM_ACTIVITY
+	ZFS_AC_KERNEL_SRC_RWSEM_ATOMIC_LONG_COUNT
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_RWSEM], [
+	ZFS_AC_KERNEL_RWSEM_SPINLOCK_IS_RAW
+	ZFS_AC_KERNEL_RWSEM_ACTIVITY
+	ZFS_AC_KERNEL_RWSEM_ATOMIC_LONG_COUNT
 ])
Index: zfs-linux-0.8.2/config/kernel-sched.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-sched.m4
+++ zfs-linux-0.8.2/config/kernel-sched.m4
@@ -2,14 +2,18 @@ dnl #
 dnl # 3.9 API change,
 dnl # Moved things from linux/sched.h to linux/sched/rt.h
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_SCHED_RT_HEADER],
-	[AC_MSG_CHECKING([whether header linux/sched/rt.h exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SCHED_RT_HEADER], [
+	ZFS_LINUX_TEST_SRC([sched_rt_header], [
 		#include <linux/sched.h>
 		#include <linux/sched/rt.h>
 	],[
 		return 0;
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SCHED_RT_HEADER], [
+	AC_MSG_CHECKING([whether header linux/sched/rt.h exists])
+	ZFS_LINUX_TEST_RESULT([sched_rt_header], [
 		AC_DEFINE(HAVE_SCHED_RT_HEADER, 1, [linux/sched/rt.h exists])
 		AC_MSG_RESULT(yes)
 	],[
@@ -21,36 +25,59 @@ dnl #
 dnl # 4.11 API change,
 dnl # Moved things from linux/sched.h to linux/sched/signal.h
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_SCHED_SIGNAL_HEADER],
-	[AC_MSG_CHECKING([whether header linux/sched/signal.h exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SCHED_SIGNAL_HEADER], [
+	ZFS_LINUX_TEST_SRC([sched_signal_header], [
 		#include <linux/sched.h>
 		#include <linux/sched/signal.h>
 	],[
 		return 0;
-	],[
-		AC_DEFINE(HAVE_SCHED_SIGNAL_HEADER, 1, [linux/sched/signal.h exists])
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SCHED_SIGNAL_HEADER], [
+	AC_MSG_CHECKING([whether header linux/sched/signal.h exists])
+	ZFS_LINUX_TEST_RESULT([sched_signal_header], [
+		AC_DEFINE(HAVE_SCHED_SIGNAL_HEADER, 1,
+		    [linux/sched/signal.h exists])
 		AC_MSG_RESULT(yes)
 	],[
 		AC_MSG_RESULT(no)
 	])
 ])
+
 dnl #
 dnl # 3.19 API change
 dnl # The io_schedule_timeout() function is present in all 2.6.32 kernels
 dnl # but it was not exported until Linux 3.19.  The RHEL 7.x kernels which
 dnl # are based on a 3.10 kernel do export this symbol.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_IO_SCHEDULE_TIMEOUT], [
-	AC_MSG_CHECKING([whether io_schedule_timeout() is available])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_IO_SCHEDULE_TIMEOUT], [
+	ZFS_LINUX_TEST_SRC([io_schedule_timeout], [
 		#include <linux/sched.h>
 	], [
 		(void) io_schedule_timeout(1);
-	], [io_schedule_timeout], [], [
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_IO_SCHEDULE_TIMEOUT], [
+	AC_MSG_CHECKING([whether io_schedule_timeout() is available])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([io_schedule_timeout],
+	[io_schedule_timeout], [], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_IO_SCHEDULE_TIMEOUT, 1, [yes])
 	],[
 		AC_MSG_RESULT(no)
 	])
 ])
+
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SCHED], [
+	ZFS_AC_KERNEL_SRC_SCHED_RT_HEADER
+	ZFS_AC_KERNEL_SRC_SCHED_SIGNAL_HEADER
+	ZFS_AC_KERNEL_SRC_IO_SCHEDULE_TIMEOUT
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SCHED], [
+	ZFS_AC_KERNEL_SCHED_RT_HEADER
+	ZFS_AC_KERNEL_SCHED_SIGNAL_HEADER
+	ZFS_AC_KERNEL_IO_SCHEDULE_TIMEOUT
+])
Index: zfs-linux-0.8.2/config/kernel-security-inode-init.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-security-inode-init.m4
+++ zfs-linux-0.8.2/config/kernel-security-inode-init.m4
@@ -5,9 +5,8 @@ dnl # qstr argument which must be passed
 dnl # Passing a NULL is safe when no qstr is available the relevant
 dnl # security checks will just be skipped.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_6ARGS_SECURITY_INODE_INIT_SECURITY], [
-	AC_MSG_CHECKING([whether security_inode_init_security wants 6 args])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SECURITY_INODE_INIT_SECURITY_6ARGS], [
+	ZFS_LINUX_TEST_SRC([security_inode_init_security_6args], [
 		#include <linux/security.h>
 	],[
 		struct inode *ip __attribute__ ((unused)) = NULL;
@@ -18,10 +17,15 @@ AC_DEFUN([ZFS_AC_KERNEL_6ARGS_SECURITY_I
 		size_t len __attribute__ ((unused)) = 0;
 
 		security_inode_init_security(ip, dip, str, &name, &value, &len);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SECURITY_INODE_INIT_SECURITY_6ARGS], [
+	AC_MSG_CHECKING([whether security_inode_init_security wants 6 args])
+	ZFS_LINUX_TEST_RESULT([security_inode_init_security_6args], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_6ARGS_SECURITY_INODE_INIT_SECURITY, 1,
-		          [security_inode_init_security wants 6 args])
+		    [security_inode_init_security wants 6 args])
 	],[
 		AC_MSG_RESULT(no)
 	])
@@ -34,9 +38,8 @@ dnl # a filesystem specific callback to
 dnl # This was done to support the initialization of multiple LSM xattrs
 dnl # and the EVM xattr.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_CALLBACK_SECURITY_INODE_INIT_SECURITY], [
-	AC_MSG_CHECKING([whether security_inode_init_security wants callback])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SECURITY_INODE_INIT_SECURITY_CALLBACK], [
+	ZFS_LINUX_TEST_SRC([security_inode_init_security], [
 		#include <linux/security.h>
 	],[
 		struct inode *ip __attribute__ ((unused)) = NULL;
@@ -45,11 +48,26 @@ AC_DEFUN([ZFS_AC_KERNEL_CALLBACK_SECURIT
 		initxattrs func __attribute__ ((unused)) = NULL;
 
 		security_inode_init_security(ip, dip, str, func, NULL);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SECURITY_INODE_INIT_SECURITY_CALLBACK], [
+	AC_MSG_CHECKING([whether security_inode_init_security wants callback])
+	ZFS_LINUX_TEST_RESULT([security_inode_init_security], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_CALLBACK_SECURITY_INODE_INIT_SECURITY, 1,
-		          [security_inode_init_security wants callback])
+		    [security_inode_init_security wants callback])
 	],[
 		AC_MSG_RESULT(no)
 	])
 ])
+
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SECURITY_INODE], [
+	ZFS_AC_KERNEL_SRC_SECURITY_INODE_INIT_SECURITY_6ARGS
+	ZFS_AC_KERNEL_SRC_SECURITY_INODE_INIT_SECURITY_CALLBACK
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SECURITY_INODE], [
+	ZFS_AC_KERNEL_SECURITY_INODE_INIT_SECURITY_6ARGS
+	ZFS_AC_KERNEL_SECURITY_INODE_INIT_SECURITY_CALLBACK
+])
Index: zfs-linux-0.8.2/config/kernel-set-nlink.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-set-nlink.m4
+++ zfs-linux-0.8.2/config/kernel-set-nlink.m4
@@ -2,18 +2,21 @@ dnl #
 dnl # Linux v3.2-rc1 API change
 dnl # SHA: bfe8684869601dacfcb2cd69ef8cfd9045f62170
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_SET_NLINK], [
-	AC_MSG_CHECKING([whether set_nlink() is available])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SET_NLINK], [
+	ZFS_LINUX_TEST_SRC([set_nlink], [
 		#include <linux/fs.h>
 	],[
 		struct inode node;
 		unsigned int link = 0;
 		(void) set_nlink(&node, link);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SET_NLINK], [
+	AC_MSG_CHECKING([whether set_nlink() is available])
+	ZFS_LINUX_TEST_RESULT([set_nlink], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_SET_NLINK, 1,
-		          [set_nlink() is available])
+		AC_DEFINE(HAVE_SET_NLINK, 1, [set_nlink() is available])
 	],[
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-setattr-prepare.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-setattr-prepare.m4
+++ zfs-linux-0.8.2/config/kernel-setattr-prepare.m4
@@ -3,17 +3,21 @@ dnl # 4.9 API change
 dnl # The inode_change_ok() function has been renamed setattr_prepare()
 dnl # and updated to take a dentry rather than an inode.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_SETATTR_PREPARE],
-	[AC_MSG_CHECKING([whether setattr_prepare() is available])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SETATTR_PREPARE], [
+	ZFS_LINUX_TEST_SRC([setattr_prepare], [
 		#include <linux/fs.h>
 	], [
 		struct dentry *dentry = NULL;
 		struct iattr *attr = NULL;
-		int error;
+		int error __attribute__ ((unused)) =
+		    setattr_prepare(dentry, attr);
+	])
+])
 
-		error = setattr_prepare(dentry, attr);
-	], [setattr_prepare], [fs/attr.c], [
+AC_DEFUN([ZFS_AC_KERNEL_SETATTR_PREPARE], [
+	AC_MSG_CHECKING([whether setattr_prepare() is available])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([setattr_prepare],
+	    [setattr_prepare], [fs/attr.c], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_SETATTR_PREPARE, 1,
 		    [setattr_prepare() is available])
Index: zfs-linux-0.8.2/config/kernel-sget-args.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-sget-args.m4
+++ zfs-linux-0.8.2/config/kernel-sget-args.m4
@@ -2,9 +2,8 @@ dnl #
 dnl # 3.6 API change,
 dnl # 'sget' now takes the mount flags as an argument.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_5ARG_SGET],
-	[AC_MSG_CHECKING([whether sget() wants 5 args])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SGET], [
+	ZFS_LINUX_TEST_SRC([sget_5args], [
 		#include <linux/fs.h>
 	],[
 		struct file_system_type *type = NULL;
@@ -13,11 +12,15 @@ AC_DEFUN([ZFS_AC_KERNEL_5ARG_SGET],
 		int flags = 0;
 		void *data = NULL;
 		(void) sget(type, test, set, flags, data);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SGET], [
+	AC_MSG_CHECKING([whether sget() wants 5 args])
+	ZFS_LINUX_TEST_RESULT([sget_5args], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_5ARG_SGET, 1, [sget() wants 5 args])
 	],[
 		AC_MSG_RESULT(no)
 	])
 ])
-
Index: zfs-linux-0.8.2/config/kernel-show-options.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-show-options.m4
+++ zfs-linux-0.8.2/config/kernel-show-options.m4
@@ -1,21 +1,26 @@
 dnl #
 dnl # Linux 3.3 API
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_SHOW_OPTIONS], [
-	AC_MSG_CHECKING([whether sops->show_options() wants dentry])
-
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SHOW_OPTIONS], [
+	ZFS_LINUX_TEST_SRC([super_operations_show_options], [
 		#include <linux/fs.h>
 
-		int show_options (struct seq_file * x, struct dentry * y) { return 0; };
+		int show_options(struct seq_file * x, struct dentry * y) {
+			return 0;
+		};
+
 		static struct super_operations sops __attribute__ ((unused)) = {
 			.show_options = show_options,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SHOW_OPTIONS], [
+	AC_MSG_CHECKING([whether sops->show_options() wants dentry])
+	ZFS_LINUX_TEST_RESULT([super_operations_show_options], [
 		AC_MSG_RESULT([yes])
 		AC_DEFINE(HAVE_SHOW_OPTIONS_WITH_DENTRY, 1,
-			[sops->show_options() with dentry])
+		    [sops->show_options() with dentry])
 	],[
 		AC_MSG_RESULT([no])
 	])
Index: zfs-linux-0.8.2/config/kernel-shrink.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-shrink.m4
+++ zfs-linux-0.8.2/config/kernel-shrink.m4
@@ -4,9 +4,8 @@ dnl # The super_block structure now stor
 dnl # This interface is preferable because it can be used to specifically
 dnl # target only the zfs filesystem for pruning.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_SHRINK], [
-	AC_MSG_CHECKING([whether super_block has s_shrink])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SUPER_BLOCK_S_SHRINK], [
+	ZFS_LINUX_TEST_SRC([super_block_s_shrink], [
 		#include <linux/fs.h>
 
 		int shrink(struct shrinker *s, struct shrink_control *sc)
@@ -18,8 +17,12 @@ AC_DEFUN([ZFS_AC_KERNEL_SHRINK], [
 			.s_shrink.seeks = DEFAULT_SEEKS,
 			.s_shrink.batch = 0,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SUPER_BLOCK_S_SHRINK], [
+	AC_MSG_CHECKING([whether super_block has s_shrink])
+	ZFS_LINUX_TEST_RESULT([super_block_s_shrink], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_SHRINK, 1, [struct super_block has s_shrink])
 
@@ -50,15 +53,18 @@ dnl # a list_head is used.  Then to prev
 dnl # the .next pointer is set to the fs_supers list_head which ensures
 dnl # the iterate_supers_type() function will always terminate.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_S_INSTANCES_LIST_HEAD], [
-	AC_MSG_CHECKING([whether super_block has s_instances list_head])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SUPER_BLOCK_S_INSTANCES_LIST_HEAD], [
+	ZFS_LINUX_TEST_SRC([super_block_s_instances_list_head], [
 		#include <linux/fs.h>
 	],[
 		struct super_block sb __attribute__ ((unused));
-
 		INIT_LIST_HEAD(&sb.s_instances);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SUPER_BLOCK_S_INSTANCES_LIST_HEAD], [
+	AC_MSG_CHECKING([whether super_block has s_instances list_head])
+	ZFS_LINUX_TEST_RESULT([super_block_s_instances_list_head], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_S_INSTANCES_LIST_HEAD, 1,
 		    [struct super_block has s_instances list_head])
@@ -67,9 +73,8 @@ AC_DEFUN([ZFS_AC_KERNEL_S_INSTANCES_LIST
 	])
 ])
 
-AC_DEFUN([ZFS_AC_KERNEL_NR_CACHED_OBJECTS], [
-	AC_MSG_CHECKING([whether sops->nr_cached_objects() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_NR_CACHED_OBJECTS], [
+	ZFS_LINUX_TEST_SRC([nr_cached_objects], [
 		#include <linux/fs.h>
 
 		int nr_cached_objects(struct super_block *sb) { return 0; }
@@ -78,19 +83,22 @@ AC_DEFUN([ZFS_AC_KERNEL_NR_CACHED_OBJECT
 		    sops __attribute__ ((unused)) = {
 			.nr_cached_objects = nr_cached_objects,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_NR_CACHED_OBJECTS], [
+	AC_MSG_CHECKING([whether sops->nr_cached_objects() exists])
+	ZFS_LINUX_TEST_RESULT([nr_cached_objects], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_NR_CACHED_OBJECTS, 1,
-			[sops->nr_cached_objects() exists])
+		    [sops->nr_cached_objects() exists])
 	],[
 		AC_MSG_RESULT(no)
 	])
 ])
 
-AC_DEFUN([ZFS_AC_KERNEL_FREE_CACHED_OBJECTS], [
-	AC_MSG_CHECKING([whether sops->free_cached_objects() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_FREE_CACHED_OBJECTS], [
+	ZFS_LINUX_TEST_SRC([free_cached_objects], [
 		#include <linux/fs.h>
 
 		void free_cached_objects(struct super_block *sb, int x)
@@ -100,11 +108,15 @@ AC_DEFUN([ZFS_AC_KERNEL_FREE_CACHED_OBJE
 		    sops __attribute__ ((unused)) = {
 			.free_cached_objects = free_cached_objects,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_FREE_CACHED_OBJECTS], [
+	AC_MSG_CHECKING([whether sops->free_cached_objects() exists])
+	ZFS_LINUX_TEST_RESULT([free_cached_objects], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_FREE_CACHED_OBJECTS, 1,
-			[sops->free_cached_objects() exists])
+		    [sops->free_cached_objects() exists])
 	],[
 		AC_MSG_RESULT(no)
 	])
@@ -115,15 +127,19 @@ dnl # 3.12 API change
 dnl # The nid member was added to struct shrink_control to support
 dnl # NUMA-aware shrinkers.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_SHRINK_CONTROL_HAS_NID], [
-	AC_MSG_CHECKING([whether shrink_control has nid])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SHRINK_CONTROL_HAS_NID], [
+	ZFS_LINUX_TEST_SRC([shrink_control_nid], [
 		#include <linux/fs.h>
 	],[
 		struct shrink_control sc __attribute__ ((unused));
 		unsigned long scnidsize __attribute__ ((unused)) =
 		    sizeof(sc.nid);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SHRINK_CONTROL_HAS_NID], [
+	AC_MSG_CHECKING([whether shrink_control has nid])
+	ZFS_LINUX_TEST_RESULT([shrink_control_nid], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(SHRINK_CONTROL_HAS_NID, 1,
 		    [struct shrink_control has nid])
@@ -132,84 +148,96 @@ AC_DEFUN([ZFS_AC_KERNEL_SHRINK_CONTROL_H
 	])
 ])
 
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SHRINKER_CALLBACK], [
+	ZFS_LINUX_TEST_SRC([shrinker_cb_2arg], [
+		#include <linux/mm.h>
+		int shrinker_cb(int nr_to_scan, gfp_t gfp_mask) { return 0; }
+	],[
+		struct shrinker cache_shrinker = {
+			.shrink = shrinker_cb,
+			.seeks = DEFAULT_SEEKS,
+		};
+		register_shrinker(&cache_shrinker);
+	])
 
-AC_DEFUN([ZFS_AC_KERNEL_SHRINKER_CALLBACK],[
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	dnl #
-	dnl # 2.6.23 to 2.6.34 API change
-	dnl # ->shrink(int nr_to_scan, gfp_t gfp_mask)
-	dnl #
-	AC_MSG_CHECKING([whether old 2-argument shrinker exists])
-	ZFS_LINUX_TRY_COMPILE([
+	ZFS_LINUX_TEST_SRC([shrinker_cb_3arg], [
 		#include <linux/mm.h>
+		int shrinker_cb(struct shrinker *shrink, int nr_to_scan,
+		    gfp_t gfp_mask) { return 0; }
+	],[
+		struct shrinker cache_shrinker = {
+			.shrink = shrinker_cb,
+			.seeks = DEFAULT_SEEKS,
+		};
+		register_shrinker(&cache_shrinker);
+	])
 
-		int shrinker_cb(int nr_to_scan, gfp_t gfp_mask) {
-			return 0;
-		}
+	ZFS_LINUX_TEST_SRC([shrinker_cb_shrink_control], [
+		#include <linux/mm.h>
+		int shrinker_cb(struct shrinker *shrink,
+		    struct shrink_control *sc) { return 0; }
 	],[
 		struct shrinker cache_shrinker = {
 			.shrink = shrinker_cb,
 			.seeks = DEFAULT_SEEKS,
 		};
 		register_shrinker(&cache_shrinker);
+	])
+
+	ZFS_LINUX_TEST_SRC([shrinker_cb_shrink_control_split], [
+		#include <linux/mm.h>
+		unsigned long shrinker_cb(struct shrinker *shrink,
+		    struct shrink_control *sc) { return 0; }
 	],[
+		struct shrinker cache_shrinker = {
+			.count_objects = shrinker_cb,
+			.scan_objects = shrinker_cb,
+			.seeks = DEFAULT_SEEKS,
+		};
+		register_shrinker(&cache_shrinker);
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SHRINKER_CALLBACK],[
+	dnl #
+	dnl # 2.6.23 to 2.6.34 API change
+	dnl # ->shrink(int nr_to_scan, gfp_t gfp_mask)
+	dnl #
+	AC_MSG_CHECKING([whether old 2-argument shrinker exists])
+	ZFS_LINUX_TEST_RESULT([shrinker_cb_2arg], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_2ARGS_OLD_SHRINKER_CALLBACK, 1,
-			[old shrinker callback wants 2 args])
+		    [old shrinker callback wants 2 args])
 	],[
 		AC_MSG_RESULT(no)
+
 		dnl #
 		dnl # 2.6.35 - 2.6.39 API change
 		dnl # ->shrink(struct shrinker *,
 		dnl #          int nr_to_scan, gfp_t gfp_mask)
 		dnl #
 		AC_MSG_CHECKING([whether old 3-argument shrinker exists])
-		ZFS_LINUX_TRY_COMPILE([
-			#include <linux/mm.h>
-
-			int shrinker_cb(struct shrinker *shrink, int nr_to_scan,
-					gfp_t gfp_mask) {
-				return 0;
-			}
-		],[
-			struct shrinker cache_shrinker = {
-				.shrink = shrinker_cb,
-				.seeks = DEFAULT_SEEKS,
-			};
-			register_shrinker(&cache_shrinker);
-		],[
+		ZFS_LINUX_TEST_RESULT([shrinker_cb_3arg], [
 			AC_MSG_RESULT(yes)
 			AC_DEFINE(HAVE_3ARGS_SHRINKER_CALLBACK, 1,
 				[old shrinker callback wants 3 args])
 		],[
 			AC_MSG_RESULT(no)
+
 			dnl #
 			dnl # 3.0 - 3.11 API change
 			dnl # ->shrink(struct shrinker *,
 			dnl #          struct shrink_control *sc)
 			dnl #
 			AC_MSG_CHECKING(
-				[whether new 2-argument shrinker exists])
-			ZFS_LINUX_TRY_COMPILE([
-				#include <linux/mm.h>
-
-				int shrinker_cb(struct shrinker *shrink,
-						struct shrink_control *sc) {
-					return 0;
-				}
-			],[
-				struct shrinker cache_shrinker = {
-					.shrink = shrinker_cb,
-					.seeks = DEFAULT_SEEKS,
-				};
-				register_shrinker(&cache_shrinker);
-			],[
+			    [whether new 2-argument shrinker exists])
+			ZFS_LINUX_TEST_RESULT([shrinker_cb_shrink_control], [
 				AC_MSG_RESULT(yes)
 				AC_DEFINE(HAVE_2ARGS_NEW_SHRINKER_CALLBACK, 1,
 					[new shrinker callback wants 2 args])
 			],[
 				AC_MSG_RESULT(no)
+
 				dnl #
 				dnl # 3.12 API change,
 				dnl # ->shrink() is logically split in to
@@ -217,52 +245,61 @@ AC_DEFUN([ZFS_AC_KERNEL_SHRINKER_CALLBAC
 				dnl #
 				AC_MSG_CHECKING(
 				    [whether ->count_objects callback exists])
-				ZFS_LINUX_TRY_COMPILE([
-					#include <linux/mm.h>
-
-					unsigned long shrinker_cb(
-						struct shrinker *shrink,
-						struct shrink_control *sc) {
-						return 0;
-					}
-				],[
-					struct shrinker cache_shrinker = {
-						.count_objects = shrinker_cb,
-						.scan_objects = shrinker_cb,
-						.seeks = DEFAULT_SEEKS,
-					};
-					register_shrinker(&cache_shrinker);
-				],[
+				ZFS_LINUX_TEST_RESULT(
+				    [shrinker_cb_shrink_control_split], [
 					AC_MSG_RESULT(yes)
 					AC_DEFINE(HAVE_SPLIT_SHRINKER_CALLBACK,
 						1, [->count_objects exists])
 				],[
-					AC_MSG_ERROR(error)
+					ZFS_LINUX_TEST_ERROR([shrinker])
 				])
 			])
 		])
 	])
-	EXTRA_KCFLAGS="$tmp_flags"
 ])
 
 dnl #
 dnl # 2.6.39 API change,
 dnl # Shrinker adjust to use common shrink_control structure.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_SHRINK_CONTROL_STRUCT], [
-	AC_MSG_CHECKING([whether struct shrink_control exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SHRINK_CONTROL_STRUCT], [
+	ZFS_LINUX_TEST_SRC([shrink_control_struct], [
 		#include <linux/mm.h>
 	],[
 		struct shrink_control sc __attribute__ ((unused));
 
 		sc.nr_to_scan = 0;
 		sc.gfp_mask = GFP_KERNEL;
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SHRINK_CONTROL_STRUCT], [
+	AC_MSG_CHECKING([whether struct shrink_control exists])
+	ZFS_LINUX_TEST_RESULT([shrink_control_struct], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_SHRINK_CONTROL_STRUCT, 1,
-			[struct shrink_control exists])
+		    [struct shrink_control exists])
 	],[
 		AC_MSG_RESULT(no)
 	])
 ])
+
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SHRINKER], [
+	ZFS_AC_KERNEL_SRC_SUPER_BLOCK_S_SHRINK
+	ZFS_AC_KERNEL_SRC_SUPER_BLOCK_S_INSTANCES_LIST_HEAD
+	ZFS_AC_KERNEL_SRC_NR_CACHED_OBJECTS
+	ZFS_AC_KERNEL_SRC_FREE_CACHED_OBJECTS
+	ZFS_AC_KERNEL_SRC_SHRINK_CONTROL_HAS_NID
+	ZFS_AC_KERNEL_SRC_SHRINKER_CALLBACK
+	ZFS_AC_KERNEL_SRC_SHRINK_CONTROL_STRUCT
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SHRINKER], [
+	ZFS_AC_KERNEL_SUPER_BLOCK_S_SHRINK
+	ZFS_AC_KERNEL_SUPER_BLOCK_S_INSTANCES_LIST_HEAD
+	ZFS_AC_KERNEL_NR_CACHED_OBJECTS
+	ZFS_AC_KERNEL_FREE_CACHED_OBJECTS
+	ZFS_AC_KERNEL_SHRINK_CONTROL_HAS_NID
+	ZFS_AC_KERNEL_SHRINKER_CALLBACK
+	ZFS_AC_KERNEL_SHRINK_CONTROL_STRUCT
+])
Index: zfs-linux-0.8.2/config/kernel-submit_bio.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-submit_bio.m4
+++ zfs-linux-0.8.2/config/kernel-submit_bio.m4
@@ -3,15 +3,19 @@ dnl # 4.8 API change
 dnl # The rw argument has been removed from submit_bio/submit_bio_wait.
 dnl # Callers are now expected to set bio->bi_rw instead of passing it in.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_SUBMIT_BIO], [
-	AC_MSG_CHECKING([whether submit_bio() wants 1 arg])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SUBMIT_BIO], [
+	ZFS_LINUX_TEST_SRC([submit_bio], [
 		#include <linux/bio.h>
 	],[
 		blk_qc_t blk_qc;
 		struct bio *bio = NULL;
 		blk_qc = submit_bio(bio);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SUBMIT_BIO], [
+	AC_MSG_CHECKING([whether submit_bio() wants 1 arg])
+	ZFS_LINUX_TEST_RESULT([submit_bio], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_1ARG_SUBMIT_BIO, 1, [submit_bio() wants 1 arg])
 	],[
Index: zfs-linux-0.8.2/config/kernel-super-userns.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-super-userns.m4
+++ zfs-linux-0.8.2/config/kernel-super-userns.m4
@@ -3,15 +3,19 @@ dnl # 4.8 API change
 dnl # struct user_namespace was added to struct super_block as
 dnl # super->s_user_ns member
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_SUPER_USER_NS], [
-	AC_MSG_CHECKING([whether super_block->s_user_ns exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_SUPER_USER_NS], [
+	ZFS_LINUX_TEST_SRC([super_user_ns], [
 		#include <linux/fs.h>
 		#include <linux/user_namespace.h>
-	],[
+	], [
 		struct super_block super;
 		super.s_user_ns = (struct user_namespace *)NULL;
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SUPER_USER_NS], [
+	AC_MSG_CHECKING([whether super_block->s_user_ns exists])
+	ZFS_LINUX_TEST_RESULT([super_user_ns], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_SUPER_USER_NS, 1,
 		    [super_block->s_user_ns exists])
Index: zfs-linux-0.8.2/config/kernel-timer.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-timer.m4
+++ zfs-linux-0.8.2/config/kernel-timer.m4
@@ -8,13 +8,9 @@ dnl # kernels that support the new timer
 dnl #
 dnl # Also check for the existance of flags in struct timer_list, they were
 dnl # added in 4.1-rc8 via 0eeda71bc30d.
-
-AC_DEFUN([ZFS_AC_KERNEL_TIMER_SETUP], [
-	AC_MSG_CHECKING([whether timer_setup() is available])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-
-	ZFS_LINUX_TRY_COMPILE([
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_TIMER_SETUP], [
+	ZFS_LINUX_TEST_SRC([timer_setup], [
 		#include <linux/timer.h>
 
 		struct my_task_timer {
@@ -24,13 +20,34 @@ AC_DEFUN([ZFS_AC_KERNEL_TIMER_SETUP], [
 
 		void task_expire(struct timer_list *tl)
 		{
-			struct my_task_timer *task_timer = from_timer(task_timer, tl, timer);
+			struct my_task_timer *task_timer =
+			    from_timer(task_timer, tl, timer);
 			task_timer->data = 42;
 		}
 	],[
 		struct my_task_timer task_timer;
 		timer_setup(&task_timer.timer, task_expire, 0);
+	])
+
+	ZFS_LINUX_TEST_SRC([timer_list_function], [
+		#include <linux/timer.h>
+		void task_expire(struct timer_list *tl) {}
 	],[
+		struct timer_list tl;
+		tl.function = task_expire;
+	])
+
+	ZFS_LINUX_TEST_SRC([timer_list_flags], [
+		#include <linux/timer.h>
+	],[
+		struct timer_list tl;
+		tl.flags = 2;
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_TIMER_SETUP], [
+	AC_MSG_CHECKING([whether timer_setup() is available])
+	ZFS_LINUX_TEST_RESULT([timer_setup], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_KERNEL_TIMER_SETUP, 1,
 		    [timer_setup() is available])
@@ -39,14 +56,7 @@ AC_DEFUN([ZFS_AC_KERNEL_TIMER_SETUP], [
 	])
 
 	AC_MSG_CHECKING([whether timer function expects timer_list])
-
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/timer.h>
-		void task_expire(struct timer_list *tl) {}
-	],[
-		struct timer_list tl;
-		tl.function = task_expire;
-	],[
+	ZFS_LINUX_TEST_RESULT([timer_list_function], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_KERNEL_TIMER_FUNCTION_TIMER_LIST, 1,
 		    [timer_list.function gets a timer_list])
@@ -55,19 +65,11 @@ AC_DEFUN([ZFS_AC_KERNEL_TIMER_SETUP], [
 	])
 
 	AC_MSG_CHECKING([whether struct timer_list has flags])
-
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/timer.h>
-	],[
-		struct timer_list tl;
-		tl.flags = 2;
-	],[
+	ZFS_LINUX_TEST_RESULT([timer_list_flags], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_KERNEL_TIMER_LIST_FLAGS, 1,
 		    [struct timer_list has a flags member])
 	],[
 		AC_MSG_RESULT(no)
 	])
-
-	EXTRA_KCFLAGS="$tmp_flags"
 ])
Index: zfs-linux-0.8.2/config/kernel-tmpfile.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-tmpfile.m4
+++ zfs-linux-0.8.2/config/kernel-tmpfile.m4
@@ -2,9 +2,8 @@ dnl #
 dnl # 3.11 API change
 dnl # Add support for i_op->tmpfile
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_TMPFILE], [
-	AC_MSG_CHECKING([whether i_op->tmpfile() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_TMPFILE], [
+	ZFS_LINUX_TEST_SRC([inode_operations_tmpfile], [
 		#include <linux/fs.h>
 		int tmpfile(struct inode *inode, struct dentry *dentry,
 		    umode_t mode) { return 0; }
@@ -12,11 +11,14 @@ AC_DEFUN([ZFS_AC_KERNEL_TMPFILE], [
 		    iops __attribute__ ((unused)) = {
 			.tmpfile = tmpfile,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_TMPFILE], [
+	AC_MSG_CHECKING([whether i_op->tmpfile() exists])
+	ZFS_LINUX_TEST_RESULT([inode_operations_tmpfile], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_TMPFILE, 1,
-		    [i_op->tmpfile() exists])
+		AC_DEFINE(HAVE_TMPFILE, 1, [i_op->tmpfile() exists])
 	],[
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-totalhigh_pages.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-totalhigh_pages.m4
+++ zfs-linux-0.8.2/config/kernel-totalhigh_pages.m4
@@ -1,16 +1,18 @@
 dnl #
 dnl # 5.0 API change
 dnl #
-dnl # ca79b0c211af mm: convert totalram_pages and totalhigh_pages variables to atomic
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_TOTALHIGH_PAGES], [
-	AC_MSG_CHECKING([whether totalhigh_pages() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_TOTALHIGH_PAGES], [
+	ZFS_LINUX_TEST_SRC([totalhigh_pages], [
 		#include <linux/highmem.h>
 	],[
 		unsigned long pages __attribute__ ((unused));
 		pages = totalhigh_pages();
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_TOTALHIGH_PAGES], [
+	AC_MSG_CHECKING([whether totalhigh_pages() exists])
+	ZFS_LINUX_TEST_RESULT([totalhigh_pages], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_TOTALHIGH_PAGES, 1, [totalhigh_pages() exists])
 	],[
Index: zfs-linux-0.8.2/config/kernel-totalram-pages-func.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-totalram-pages-func.m4
+++ zfs-linux-0.8.2/config/kernel-totalram-pages-func.m4
@@ -2,16 +2,21 @@ dnl #
 dnl # Linux 5.0: totalram_pages is no longer a global variable, and must be
 dnl # read via the totalram_pages() helper function.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_TOTALRAM_PAGES_FUNC], [
-	AC_MSG_CHECKING([whether totalram_pages() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_TOTALRAM_PAGES_FUNC], [
+	ZFS_LINUX_TEST_SRC([totalram_pages], [
 		#include <linux/mm.h>
 	],[
 		unsigned long pages __attribute__ ((unused));
 		pages = totalram_pages();
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_TOTALRAM_PAGES_FUNC], [
+	AC_MSG_CHECKING([whether totalram_pages() exists])
+	ZFS_LINUX_TEST_RESULT([totalram_pages], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_TOTALRAM_PAGES_FUNC, 1, [kernel has totalram_pages()])
+		AC_DEFINE(HAVE_TOTALRAM_PAGES_FUNC, 1,
+		    [kernel has totalram_pages()])
 	],[
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-truncate-range.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-truncate-range.m4
+++ zfs-linux-0.8.2/config/kernel-truncate-range.m4
@@ -4,17 +4,20 @@ dnl # torvalds/linux@17cf28afea2a1112f24
 dnl # truncate_range(). The file hole punching functionality is now
 dnl # provided by fallocate()
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_TRUNCATE_RANGE], [
-	AC_MSG_CHECKING([whether iops->truncate_range() exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_TRUNCATE_RANGE], [
+	ZFS_LINUX_TEST_SRC([inode_operations_truncate_range], [
 		#include <linux/fs.h>
 		void truncate_range(struct inode *inode, loff_t start,
 		                    loff_t end) { return; }
 		static struct inode_operations iops __attribute__ ((unused)) = {
 			.truncate_range	= truncate_range,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_TRUNCATE_RANGE], [
+	AC_MSG_CHECKING([whether iops->truncate_range() exists])
+	ZFS_LINUX_TEST_RESULT([inode_operations_truncate_range], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_INODE_TRUNCATE_RANGE, 1,
 		          [iops->truncate_range() exists])
Index: zfs-linux-0.8.2/config/kernel-truncate-setsize.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-truncate-setsize.m4
+++ zfs-linux-0.8.2/config/kernel-truncate-setsize.m4
@@ -2,16 +2,21 @@ dnl #
 dnl # 2.6.35 API change
 dnl # Added truncate_setsize() helper function.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_TRUNCATE_SETSIZE],
-	[AC_MSG_CHECKING([whether truncate_setsize() is available])
-	ZFS_LINUX_TRY_COMPILE_SYMBOL([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_TRUNCATE_SETSIZE], [
+	ZFS_LINUX_TEST_SRC([truncate_setsize], [
 		#include <linux/mm.h>
 	], [
 		truncate_setsize(NULL, 0);
-	], [truncate_setsize], [mm/truncate.c], [
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_TRUNCATE_SETSIZE], [
+	AC_MSG_CHECKING([whether truncate_setsize() is available])
+	ZFS_LINUX_TEST_RESULT_SYMBOL([truncate_setsize],
+	    [truncate_setsize], [mm/truncate.c], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_TRUNCATE_SETSIZE, 1,
-		          [truncate_setsize() is available])
+		    [truncate_setsize() is available])
 	], [
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-userns-capabilities.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-userns-capabilities.m4
+++ zfs-linux-0.8.2/config/kernel-userns-capabilities.m4
@@ -2,16 +2,19 @@ dnl #
 dnl # 2.6.38 API change
 dnl # ns_capable() was introduced
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_NS_CAPABLE], [
-	AC_MSG_CHECKING([whether ns_capable exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_NS_CAPABLE], [
+	ZFS_LINUX_TEST_SRC([ns_capable], [
 		#include <linux/capability.h>
 	],[
 		ns_capable((struct user_namespace *)NULL, CAP_SYS_ADMIN);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_NS_CAPABLE], [
+	AC_MSG_CHECKING([whether ns_capable exists])
+	ZFS_LINUX_TEST_RESULT([ns_capable], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_NS_CAPABLE, 1,
-		    [ns_capable exists])
+		AC_DEFINE(HAVE_NS_CAPABLE, 1, [ns_capable exists])
 	],[
 		AC_MSG_RESULT(no)
 	])
@@ -23,17 +26,20 @@ dnl # struct user_namespace was added to
 dnl # cred->user_ns member
 dnl # Note that current_user_ns() was added in 2.6.28.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_CRED_USER_NS], [
-	AC_MSG_CHECKING([whether cred_t->user_ns exists])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_CRED_USER_NS], [
+	ZFS_LINUX_TEST_SRC([cred_user_ns], [
 		#include <linux/cred.h>
 	],[
 		struct cred cr;
 		cr.user_ns = (struct user_namespace *)NULL;
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_CRED_USER_NS], [
+	AC_MSG_CHECKING([whether cred_t->user_ns exists])
+	ZFS_LINUX_TEST_RESULT([cred_user_ns], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_CRED_USER_NS, 1,
-		    [cred_t->user_ns exists])
+		AC_DEFINE(HAVE_CRED_USER_NS, 1, [cred_t->user_ns exists])
 	],[
 		AC_MSG_RESULT(no)
 	])
@@ -44,14 +50,18 @@ dnl # 3.4 API change
 dnl # kuid_has_mapping() and kgid_has_mapping() were added to distinguish
 dnl # between internal kernel uids/gids and user namespace uids/gids.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_KUID_HAS_MAPPING], [
-	AC_MSG_CHECKING([whether kuid_has_mapping/kgid_has_mapping exist])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_KUID_HAS_MAPPING], [
+	ZFS_LINUX_TEST_SRC([kuid_has_mapping], [
 		#include <linux/uidgid.h>
 	],[
 		kuid_has_mapping((struct user_namespace *)NULL, KUIDT_INIT(0));
 		kgid_has_mapping((struct user_namespace *)NULL, KGIDT_INIT(0));
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_KUID_HAS_MAPPING], [
+	AC_MSG_CHECKING([whether kuid_has_mapping/kgid_has_mapping exist])
+	ZFS_LINUX_TEST_RESULT([kuid_has_mapping], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_KUID_HAS_MAPPING, 1,
 		    [kuid_has_mapping/kgid_has_mapping exist])
@@ -60,6 +70,12 @@ AC_DEFUN([ZFS_AC_KERNEL_KUID_HAS_MAPPING
 	])
 ])
 
+AC_DEFUN([ZFS_AC_KERNEL_SRC_USERNS_CAPABILITIES], [
+	ZFS_AC_KERNEL_SRC_NS_CAPABLE
+	ZFS_AC_KERNEL_SRC_CRED_USER_NS
+	ZFS_AC_KERNEL_SRC_KUID_HAS_MAPPING
+])
+
 AC_DEFUN([ZFS_AC_KERNEL_USERNS_CAPABILITIES], [
 	ZFS_AC_KERNEL_NS_CAPABLE
 	ZFS_AC_KERNEL_CRED_USER_NS
Index: zfs-linux-0.8.2/config/kernel-urange-sleep.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-urange-sleep.m4
+++ /dev/null
@@ -1,21 +0,0 @@
-dnl #
-dnl # 2.6.36 API compatibility.
-dnl # Added usleep_range timer.
-dnl # usleep_range is a finer precision implementation of msleep
-dnl # designed to be a drop-in replacement for udelay where a precise
-dnl # sleep / busy-wait is unnecessary.
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_USLEEP_RANGE], [
-	AC_MSG_CHECKING([whether usleep_range() is available])
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/delay.h>
-	],[
-		usleep_range(0, 0);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_USLEEP_RANGE, 1,
-		          [usleep_range is available])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
Index: zfs-linux-0.8.2/config/kernel-usleep_range.m4
===================================================================
--- /dev/null
+++ zfs-linux-0.8.2/config/kernel-usleep_range.m4
@@ -0,0 +1,24 @@
+dnl #
+dnl # 2.6.36 API compatibility- Added usleep_range timer.
+dnl #
+dnl # usleep_range is a finer precision implementation of msleep
+dnl # designed to be a drop-in replacement for udelay where a precise
+dnl # sleep / busy-wait is unnecessary.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_USLEEP_RANGE], [
+	ZFS_LINUX_TEST_SRC([usleep_range], [
+		#include <linux/delay.h>
+	],[
+		usleep_range(0, 0);
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_USLEEP_RANGE], [
+	AC_MSG_CHECKING([whether usleep_range() is available])
+	ZFS_LINUX_TEST_RESULT([usleep_range], [
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_USLEEP_RANGE, 1, [usleep_range is available])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
Index: zfs-linux-0.8.2/config/kernel-vfs-direct_IO.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-vfs-direct_IO.m4
+++ zfs-linux-0.8.2/config/kernel-vfs-direct_IO.m4
@@ -1,9 +1,8 @@
 dnl #
-dnl # Linux 4.6.x API change
+dnl # Check for direct IO interfaces.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_VFS_DIRECT_IO_ITER], [
-	AC_MSG_CHECKING([whether aops->direct_IO() uses iov_iter])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_VFS_DIRECT_IO], [
+	ZFS_LINUX_TEST_SRC([direct_io_iter], [
 		#include <linux/fs.h>
 
 		ssize_t test_direct_IO(struct kiocb *kiocb,
@@ -13,24 +12,9 @@ AC_DEFUN([ZFS_AC_KERNEL_VFS_DIRECT_IO_IT
 		    aops __attribute__ ((unused)) = {
 			.direct_IO = test_direct_IO,
 		};
-	],[
-	],[
-		AC_MSG_RESULT([yes])
-		AC_DEFINE(HAVE_VFS_DIRECT_IO_ITER, 1,
-		    [aops->direct_IO() uses iov_iter without rw])
-		zfs_ac_direct_io="yes"
-	],[
-		AC_MSG_RESULT([no])
-	])
-])
+	],[])
 
-dnl #
-dnl # Linux 4.1.x API change
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_VFS_DIRECT_IO_ITER_OFFSET], [
-	AC_MSG_CHECKING(
-	    [whether aops->direct_IO() uses iov_iter with offset])
-	ZFS_LINUX_TRY_COMPILE([
+	ZFS_LINUX_TEST_SRC([direct_io_iter_offset], [
 		#include <linux/fs.h>
 
 		ssize_t test_direct_IO(struct kiocb *kiocb,
@@ -40,24 +24,9 @@ AC_DEFUN([ZFS_AC_KERNEL_VFS_DIRECT_IO_IT
 		    aops __attribute__ ((unused)) = {
 			.direct_IO = test_direct_IO,
 		};
-	],[
-	],[
-		AC_MSG_RESULT([yes])
-		AC_DEFINE(HAVE_VFS_DIRECT_IO_ITER_OFFSET, 1,
-		    [aops->direct_IO() uses iov_iter with offset])
-		zfs_ac_direct_io="yes"
-	],[
-		AC_MSG_RESULT([no])
-	])
-])
+	],[])
 
-dnl #
-dnl # Linux 3.16.x API change
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_VFS_DIRECT_IO_ITER_RW_OFFSET], [
-	AC_MSG_CHECKING(
-	    [whether aops->direct_IO() uses iov_iter with rw and offset])
-	ZFS_LINUX_TRY_COMPILE([
+	ZFS_LINUX_TEST_SRC([direct_io_iter_rw_offset], [
 		#include <linux/fs.h>
 
 		ssize_t test_direct_IO(int rw, struct kiocb *kiocb,
@@ -67,23 +36,9 @@ AC_DEFUN([ZFS_AC_KERNEL_VFS_DIRECT_IO_IT
 		    aops __attribute__ ((unused)) = {
 		    .direct_IO = test_direct_IO,
 		};
-	],[
-	],[
-		AC_MSG_RESULT([yes])
-		AC_DEFINE(HAVE_VFS_DIRECT_IO_ITER_RW_OFFSET, 1,
-		    [aops->direct_IO() uses iov_iter with rw and offset])
-		zfs_ac_direct_io="yes"
-	],[
-		AC_MSG_RESULT([no])
-	])
-])
+	],[])
 
-dnl #
-dnl # Ancient Linux API (predates git)
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_VFS_DIRECT_IO_IOVEC], [
-	AC_MSG_CHECKING([whether aops->direct_IO() uses iovec])
-	ZFS_LINUX_TRY_COMPILE([
+	ZFS_LINUX_TEST_SRC([direct_io_iovec], [
 		#include <linux/fs.h>
 
 		ssize_t test_direct_IO(int rw, struct kiocb *kiocb,
@@ -94,37 +49,61 @@ AC_DEFUN([ZFS_AC_KERNEL_VFS_DIRECT_IO_IO
 		    aops __attribute__ ((unused)) = {
 		    .direct_IO = test_direct_IO,
 		};
-	],[
-	],[
-		AC_MSG_RESULT([yes])
-		AC_DEFINE(HAVE_VFS_DIRECT_IO_IOVEC, 1,
-		    [aops->direct_IO() uses iovec])
-		zfs_ac_direct_io="yes"
-	],[
-		AC_MSG_RESULT([no])
-	])
+	],[])
 ])
 
 AC_DEFUN([ZFS_AC_KERNEL_VFS_DIRECT_IO], [
-	zfs_ac_direct_io="no"
+	dnl #
+	dnl # Linux 4.6.x API change
+	dnl #
+	AC_MSG_CHECKING([whether aops->direct_IO() uses iov_iter])
+	ZFS_LINUX_TEST_RESULT([direct_io_iter], [
+		AC_MSG_RESULT([yes])
+		AC_DEFINE(HAVE_VFS_DIRECT_IO_ITER, 1,
+		    [aops->direct_IO() uses iov_iter without rw])
+	],[
+		AC_MSG_RESULT([no])
 
-	if test "$zfs_ac_direct_io" = "no"; then
-		ZFS_AC_KERNEL_VFS_DIRECT_IO_ITER
-	fi
-
-	if test "$zfs_ac_direct_io" = "no"; then
-		ZFS_AC_KERNEL_VFS_DIRECT_IO_ITER_OFFSET
-	fi
-
-	if test "$zfs_ac_direct_io" = "no"; then
-		ZFS_AC_KERNEL_VFS_DIRECT_IO_ITER_RW_OFFSET
-	fi
-
-	if test "$zfs_ac_direct_io" = "no"; then
-		ZFS_AC_KERNEL_VFS_DIRECT_IO_IOVEC
-	fi
-
-	if test "$zfs_ac_direct_io" = "no"; then
-		AC_MSG_ERROR([no; unknown direct IO interface])
-	fi
+		dnl #
+		dnl # Linux 4.1.x API change
+		dnl #
+		AC_MSG_CHECKING(
+		    [whether aops->direct_IO() uses offset])
+		ZFS_LINUX_TEST_RESULT([direct_io_iter_offset], [
+			AC_MSG_RESULT([yes])
+			AC_DEFINE(HAVE_VFS_DIRECT_IO_ITER_OFFSET, 1,
+			    [aops->direct_IO() uses iov_iter with offset])
+
+		],[
+			AC_MSG_RESULT([no])
+
+			dnl #
+			dnl # Linux 3.16.x API change
+			dnl #
+			AC_MSG_CHECKING(
+			    [whether aops->direct_IO() uses rw and offset])
+			ZFS_LINUX_TEST_RESULT([direct_io_iter_rw_offset], [
+				AC_MSG_RESULT([yes])
+				AC_DEFINE(HAVE_VFS_DIRECT_IO_ITER_RW_OFFSET, 1,
+				    [aops->direct_IO() uses iov_iter with ]
+				    [rw and offset])
+			],[
+				AC_MSG_RESULT([no])
+
+				dnl #
+				dnl # Ancient Linux API (predates git)
+				dnl #
+				AC_MSG_CHECKING(
+				    [whether aops->direct_IO() uses iovec])
+				ZFS_LINUX_TEST_RESULT([direct_io_iovec], [
+					AC_MSG_RESULT([yes])
+					AC_DEFINE(HAVE_VFS_DIRECT_IO_IOVEC, 1,
+					    [aops->direct_IO() uses iovec])
+				],[
+					ZFS_LINUX_TEST_ERROR([direct IO])
+					AC_MSG_RESULT([no])
+				])
+			])
+		])
+	])
 ])
Index: zfs-linux-0.8.2/config/kernel-vfs-fsync.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-vfs-fsync.m4
+++ zfs-linux-0.8.2/config/kernel-vfs-fsync.m4
@@ -2,13 +2,17 @@ dnl #
 dnl # 2.6.35 API change,
 dnl # Unused 'struct dentry *' removed from vfs_fsync() prototype.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_2ARGS_VFS_FSYNC], [
-	AC_MSG_CHECKING([whether vfs_fsync() wants 2 args])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_VFS_FSYNC_2ARGS], [
+	ZFS_LINUX_TEST_SRC([vfs_fsync_2args], [
 		#include <linux/fs.h>
 	],[
 		vfs_fsync(NULL, 0);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_VFS_FSYNC_2ARGS], [
+	AC_MSG_CHECKING([whether vfs_fsync() wants 2 args])
+	ZFS_LINUX_TEST_RESULT([vfs_fsync_2args], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_2ARGS_VFS_FSYNC, 1, [vfs_fsync() wants 2 args])
 	],[
Index: zfs-linux-0.8.2/config/kernel-vfs-getattr.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-vfs-getattr.m4
+++ zfs-linux-0.8.2/config/kernel-vfs-getattr.m4
@@ -2,19 +2,23 @@ dnl #
 dnl # 4.11 API, a528d35e@torvalds/linux
 dnl # vfs_getattr(const struct path *p, struct kstat *s, u32 m, unsigned int f)
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_4ARGS_VFS_GETATTR], [
-	AC_MSG_CHECKING([whether vfs_getattr() wants 4 args])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_VFS_GETATTR_4ARGS], [
+	ZFS_LINUX_TEST_SRC([vfs_getattr_4args], [
 		#include <linux/fs.h>
 	],[
 		vfs_getattr((const struct path *)NULL,
 			(struct kstat *)NULL,
 			(u32)0,
 			(unsigned int)0);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_VFS_GETATTR_4ARGS], [
+	AC_MSG_CHECKING([whether vfs_getattr() wants 4 args])
+	ZFS_LINUX_TEST_RESULT([vfs_getattr_4args], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_4ARGS_VFS_GETATTR, 1,
-		  [vfs_getattr wants 4 args])
+		    [vfs_getattr wants 4 args])
 	],[
 		AC_MSG_RESULT(no)
 	])
@@ -24,17 +28,21 @@ dnl #
 dnl # 3.9 API
 dnl # vfs_getattr(struct path *p, struct kstat *s)
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_2ARGS_VFS_GETATTR], [
-	AC_MSG_CHECKING([whether vfs_getattr() wants 2 args])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_VFS_GETATTR_2ARGS], [
+	ZFS_LINUX_TEST_SRC([vfs_getattr_2args], [
 		#include <linux/fs.h>
 	],[
 		vfs_getattr((struct path *) NULL,
 			(struct kstat *)NULL);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_VFS_GETATTR_2ARGS], [
+	AC_MSG_CHECKING([whether vfs_getattr() wants 2 args])
+	ZFS_LINUX_TEST_RESULT([vfs_getattr_2args], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_2ARGS_VFS_GETATTR, 1,
-			  [vfs_getattr wants 2 args])
+		    [vfs_getattr wants 2 args])
 	],[
 		AC_MSG_RESULT(no)
 	])
@@ -44,19 +52,35 @@ dnl #
 dnl # <3.9 API
 dnl # vfs_getattr(struct vfsmount *v, struct dentry *d, struct kstat *k)
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_3ARGS_VFS_GETATTR], [
-	AC_MSG_CHECKING([whether vfs_getattr() wants 3 args])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_VFS_GETATTR_3ARGS], [
+	ZFS_LINUX_TEST_SRC([vfs_getattr_3args], [
 		#include <linux/fs.h>
 	],[
 		vfs_getattr((struct vfsmount *)NULL,
 			(struct dentry *)NULL,
 			(struct kstat *)NULL);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_VFS_GETATTR_3ARGS], [
+	AC_MSG_CHECKING([whether vfs_getattr() wants 3 args])
+	ZFS_LINUX_TEST_RESULT([vfs_getattr_3args], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_3ARGS_VFS_GETATTR, 1,
-		  [vfs_getattr wants 3 args])
+		    [vfs_getattr wants 3 args])
 	],[
 		AC_MSG_RESULT(no)
 	])
 ])
+
+AC_DEFUN([ZFS_AC_KERNEL_SRC_VFS_GETATTR], [
+	ZFS_AC_KERNEL_SRC_VFS_GETATTR_4ARGS
+	ZFS_AC_KERNEL_SRC_VFS_GETATTR_2ARGS
+	ZFS_AC_KERNEL_SRC_VFS_GETATTR_3ARGS
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_VFS_GETATTR], [
+	ZFS_AC_KERNEL_VFS_GETATTR_4ARGS
+	ZFS_AC_KERNEL_VFS_GETATTR_2ARGS
+	ZFS_AC_KERNEL_VFS_GETATTR_3ARGS
+])
Index: zfs-linux-0.8.2/config/kernel-vfs-iterate.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-vfs-iterate.m4
+++ zfs-linux-0.8.2/config/kernel-vfs-iterate.m4
@@ -1,9 +1,5 @@
-AC_DEFUN([ZFS_AC_KERNEL_VFS_ITERATE], [
-	dnl #
-	dnl # 4.7 API change
-	dnl #
-	AC_MSG_CHECKING([whether fops->iterate_shared() is available])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_VFS_ITERATE], [
+	ZFS_LINUX_TEST_SRC([file_operations_iterate_shared], [
 		#include <linux/fs.h>
 		int iterate(struct file *filp, struct dir_context * context)
 		    { return 0; }
@@ -12,11 +8,44 @@ AC_DEFUN([ZFS_AC_KERNEL_VFS_ITERATE], [
 		    __attribute__ ((unused)) = {
 			.iterate_shared	 = iterate,
 		};
-	],[
-	],[
+	],[])
+
+	ZFS_LINUX_TEST_SRC([file_operations_iterate], [
+		#include <linux/fs.h>
+		int iterate(struct file *filp,
+		    struct dir_context *context) { return 0; }
+
+		static const struct file_operations fops
+		    __attribute__ ((unused)) = {
+			.iterate	 = iterate,
+		};
+
+		#if defined(FMODE_KABI_ITERATE)
+		#error "RHEL 7.5, FMODE_KABI_ITERATE interface"
+		#endif
+	],[])
+
+	ZFS_LINUX_TEST_SRC([file_operations_readdir], [
+		#include <linux/fs.h>
+		int readdir(struct file *filp, void *entry,
+		    filldir_t func) { return 0; }
+
+		static const struct file_operations fops
+		    __attribute__ ((unused)) = {
+			.readdir = readdir,
+		};
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_VFS_ITERATE], [
+	dnl #
+	dnl # 4.7 API change
+	dnl #
+	AC_MSG_CHECKING([whether fops->iterate_shared() is available])
+	ZFS_LINUX_TEST_RESULT([file_operations_iterate_shared], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_VFS_ITERATE_SHARED, 1,
-		          [fops->iterate_shared() is available])
+		    [fops->iterate_shared() is available])
 	],[
 		AC_MSG_RESULT(no)
 
@@ -31,44 +60,23 @@ AC_DEFUN([ZFS_AC_KERNEL_VFS_ITERATE], [
 		dnl # to using fops.readdir() to retain KABI compatibility.
 		dnl #
 		AC_MSG_CHECKING([whether fops->iterate() is available])
-		ZFS_LINUX_TRY_COMPILE([
-			#include <linux/fs.h>
-			int iterate(struct file *filp,
-			    struct dir_context *context) { return 0; }
-
-			static const struct file_operations fops
-			    __attribute__ ((unused)) = {
-				.iterate	 = iterate,
-			};
-
-			#if defined(FMODE_KABI_ITERATE)
-			#error "RHEL 7.5, FMODE_KABI_ITERATE interface"
-			#endif
-		],[
-		],[
+		ZFS_LINUX_TEST_RESULT([file_operations_iterate], [
 			AC_MSG_RESULT(yes)
 			AC_DEFINE(HAVE_VFS_ITERATE, 1,
-				  [fops->iterate() is available])
+			    [fops->iterate() is available])
 		],[
 			AC_MSG_RESULT(no)
 
+			dnl #
+			dnl # readdir interface introduced
+			dnl #
 			AC_MSG_CHECKING([whether fops->readdir() is available])
-			ZFS_LINUX_TRY_COMPILE([
-				#include <linux/fs.h>
-				int readdir(struct file *filp, void *entry,
-				    filldir_t func) { return 0; }
-
-				static const struct file_operations fops
-				    __attribute__ ((unused)) = {
-					.readdir = readdir,
-				};
-			],[
-			],[
+			ZFS_LINUX_TEST_RESULT([file_operations_readdir], [
 				AC_MSG_RESULT(yes)
 				AC_DEFINE(HAVE_VFS_READDIR, 1,
-					  [fops->readdir() is available])
+				    [fops->readdir() is available])
 			],[
-				AC_MSG_ERROR(no; file a bug report with ZoL)
+				ZFS_LINUX_TEST_ERROR([vfs_iterate])
 			])
 		])
 	])
Index: zfs-linux-0.8.2/config/kernel-vfs-rw-iterate.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-vfs-rw-iterate.m4
+++ zfs-linux-0.8.2/config/kernel-vfs-rw-iterate.m4
@@ -1,9 +1,8 @@
 dnl #
 dnl # Linux 3.16 API
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_VFS_RW_ITERATE],
-	[AC_MSG_CHECKING([whether fops->read/write_iter() are available])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_VFS_RW_ITERATE], [
+	ZFS_LINUX_TEST_SRC([file_operations_rw], [
 		#include <linux/fs.h>
 
 		ssize_t test_read(struct kiocb *kiocb, struct iov_iter *to)
@@ -16,39 +15,41 @@ AC_DEFUN([ZFS_AC_KERNEL_VFS_RW_ITERATE],
 		    .read_iter = test_read,
 		    .write_iter = test_write,
 		};
-	],[
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_VFS_RW_ITERATE, 1,
-			[fops->read/write_iter() are available])
+	],[])
 
-		ZFS_AC_KERNEL_NEW_SYNC_READ
+	ZFS_LINUX_TEST_SRC([new_sync_rw], [
+		#include <linux/fs.h>
 	],[
-		AC_MSG_RESULT(no)
+	        ssize_t ret __attribute__ ((unused));
+		struct file *filp = NULL;
+		char __user *rbuf = NULL;
+		const char __user *wbuf = NULL;
+		size_t len = 0;
+		loff_t ppos;
+
+		ret = new_sync_read(filp, rbuf, len, &ppos);
+		ret = new_sync_write(filp, wbuf, len, &ppos);
 	])
 ])
 
-dnl #
-dnl # Linux 4.1 API
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_NEW_SYNC_READ],
-	[AC_MSG_CHECKING([whether new_sync_read/write() are available])
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/fs.h>
-	],[
-		        ssize_t ret __attribute__ ((unused));
-			struct file *filp = NULL;
-			char __user *rbuf = NULL;
-			const char __user *wbuf = NULL;
-			size_t len = 0;
-			loff_t ppos;
-
-			ret = new_sync_read(filp, rbuf, len, &ppos);
-			ret = new_sync_write(filp, wbuf, len, &ppos);
-	],[
+AC_DEFUN([ZFS_AC_KERNEL_VFS_RW_ITERATE], [
+	AC_MSG_CHECKING([whether fops->read/write_iter() are available])
+	ZFS_LINUX_TEST_RESULT([file_operations_rw], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_NEW_SYNC_READ, 1,
-			[new_sync_read()/new_sync_write() are available])
+		AC_DEFINE(HAVE_VFS_RW_ITERATE, 1,
+		    [fops->read/write_iter() are available])
+
+		dnl #
+		dnl # Linux 4.1 API
+		dnl #
+		AC_MSG_CHECKING([whether new_sync_read/write() are available])
+		ZFS_LINUX_TEST_RESULT([new_sync_rw], [
+			AC_MSG_RESULT(yes)
+			AC_DEFINE(HAVE_NEW_SYNC_READ, 1,
+			    [new_sync_read()/new_sync_write() are available])
+		],[
+			AC_MSG_RESULT(no)
+		])
 	],[
 		AC_MSG_RESULT(no)
 	])
@@ -57,19 +58,22 @@ AC_DEFUN([ZFS_AC_KERNEL_NEW_SYNC_READ],
 dnl #
 dnl # Linux 4.1.x API
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_GENERIC_WRITE_CHECKS],
-	[AC_MSG_CHECKING([whether generic_write_checks() takes kiocb])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_VFS_GENERIC_WRITE_CHECKS], [
+	ZFS_LINUX_TEST_SRC([generic_write_checks], [
 		#include <linux/fs.h>
-
 	],[
 		struct kiocb *iocb = NULL;
 		struct iov_iter *iov = NULL;
 		generic_write_checks(iocb, iov);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_VFS_GENERIC_WRITE_CHECKS], [
+	AC_MSG_CHECKING([whether generic_write_checks() takes kiocb])
+	ZFS_LINUX_TEST_RESULT([generic_write_checks], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_GENERIC_WRITE_CHECKS_KIOCB, 1,
-			[generic_write_checks() takes kiocb])
+		    [generic_write_checks() takes kiocb])
 	],[
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel-wait.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-wait.m4
+++ zfs-linux-0.8.2/config/kernel-wait.m4
@@ -1,4 +1,27 @@
 dnl #
+dnl # 4.13 API change
+dnl # Renamed struct wait_queue -> struct wait_queue_entry.
+dnl #
+dnl # N.B. The type check is performed before all other checks
+dnl # since ZFS_AC_KERNEL_SRC_WAIT_QUEUE_HEAD_ENTRY depends on
+dnl # HAVE_WAIT_QUEUE_ENTRY_T being set in confdefs.h.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_WAIT_QUEUE_ENTRY_T], [
+	AC_MSG_CHECKING([whether wait_queue_entry_t exists])
+	ZFS_LINUX_TRY_COMPILE([
+		#include <linux/wait.h>
+	],[
+		wait_queue_entry_t *entry __attribute__ ((unused));
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_WAIT_QUEUE_ENTRY_T, 1,
+		    [wait_queue_entry_t exists])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
+
+dnl #
 dnl # 3.17 API change,
 dnl # wait_on_bit() no longer requires an action argument. The former
 dnl # "wait_on_bit" interface required an 'action' function to be provided
@@ -8,34 +31,20 @@ dnl # of just two functions: one which u
 dnl # uses schedule().  This API change was made to consolidate all of those
 dnl # redundant wait functions.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_WAIT_ON_BIT], [
-	AC_MSG_CHECKING([whether wait_on_bit() takes an action])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_WAIT_ON_BIT], [
+	ZFS_LINUX_TEST_SRC([wait_on_bit], [
 		#include <linux/wait.h>
 	],[
 		int (*action)(void *) = NULL;
 		wait_on_bit(NULL, 0, action, 0);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_WAIT_ON_BIT_ACTION, 1, [yes])
-	],[
-		AC_MSG_RESULT(no)
 	])
 ])
-dnl #
-dnl # 4.13 API change
-dnl # Renamed struct wait_queue -> struct wait_queue_entry.
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_WAIT_QUEUE_ENTRY_T], [
-	AC_MSG_CHECKING([whether wait_queue_entry_t exists])
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/wait.h>
-	],[
-		wait_queue_entry_t *entry __attribute__ ((unused));
-	],[
+
+AC_DEFUN([ZFS_AC_KERNEL_WAIT_ON_BIT], [
+	AC_MSG_CHECKING([whether wait_on_bit() takes an action])
+	ZFS_LINUX_TEST_RESULT([wait_on_bit], [
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_WAIT_QUEUE_ENTRY_T, 1,
-		    [wait_queue_entry_t exists])
+		AC_DEFINE(HAVE_WAIT_ON_BIT_ACTION, 1, [yes])
 	],[
 		AC_MSG_RESULT(no)
 	])
@@ -46,9 +55,8 @@ dnl # 4.13 API change
 dnl # Renamed wait_queue_head::task_list -> wait_queue_head::head
 dnl # Renamed wait_queue_entry::task_list -> wait_queue_entry::entry
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_WAIT_QUEUE_HEAD_ENTRY], [
-	AC_MSG_CHECKING([whether wq_head->head and wq_entry->entry exist])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_WAIT_QUEUE_HEAD_ENTRY], [
+	ZFS_LINUX_TEST_SRC([wait_queue_head_entry], [
 		#include <linux/wait.h>
 
 		#ifdef HAVE_WAIT_QUEUE_ENTRY_T
@@ -66,7 +74,12 @@ AC_DEFUN([ZFS_AC_KERNEL_WAIT_QUEUE_HEAD_
 
 		head = &wq_head.head;
 		entry = &wq_entry.entry;
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_WAIT_QUEUE_HEAD_ENTRY], [
+	AC_MSG_CHECKING([whether wq_head->head and wq_entry->entry exist])
+	ZFS_LINUX_TEST_RESULT([wait_queue_head_entry], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_WAIT_QUEUE_HEAD_ENTRY, 1,
 		    [wq_head->head and wq_entry->entry exist])
@@ -74,3 +87,13 @@ AC_DEFUN([ZFS_AC_KERNEL_WAIT_QUEUE_HEAD_
 		AC_MSG_RESULT(no)
 	])
 ])
+
+AC_DEFUN([ZFS_AC_KERNEL_SRC_WAIT], [
+	ZFS_AC_KERNEL_SRC_WAIT_ON_BIT
+	ZFS_AC_KERNEL_SRC_WAIT_QUEUE_HEAD_ENTRY
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_WAIT], [
+	ZFS_AC_KERNEL_WAIT_ON_BIT
+	ZFS_AC_KERNEL_WAIT_QUEUE_HEAD_ENTRY
+])
Index: zfs-linux-0.8.2/config/kernel-xattr-handler.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-xattr-handler.m4
+++ zfs-linux-0.8.2/config/kernel-xattr-handler.m4
@@ -3,9 +3,8 @@ dnl # 2.6.35 API change,
 dnl # The 'struct xattr_handler' was constified in the generic
 dnl # super_block structure.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_CONST_XATTR_HANDLER], [
-	AC_MSG_CHECKING([whether super_block uses const struct xattr_handler])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_CONST_XATTR_HANDLER], [
+	ZFS_LINUX_TEST_SRC([const_xattr_handler], [
 		#include <linux/fs.h>
 		#include <linux/xattr.h>
 
@@ -22,11 +21,15 @@ AC_DEFUN([ZFS_AC_KERNEL_CONST_XATTR_HAND
 		const struct super_block sb __attribute__ ((unused)) = {
 			.s_xattr = xattr_handlers,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_CONST_XATTR_HANDLER], [
+	AC_MSG_CHECKING([whether super_block uses const struct xattr_handler])
+	ZFS_LINUX_TEST_RESULT([const_xattr_handler], [
 		AC_MSG_RESULT([yes])
 		AC_DEFINE(HAVE_CONST_XATTR_HANDLER, 1,
-		          [super_block uses const struct xattr_handler])
+		    [super_block uses const struct xattr_handler])
 	],[
 		AC_MSG_RESULT([no])
 	])
@@ -38,17 +41,20 @@ dnl # struct xattr_handler added new mem
 dnl # xattr_handler which matches to whole name rather than prefix should use
 dnl # "name" instead of "prefix", e.g. "system.posix_acl_access"
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_NAME], [
-	AC_MSG_CHECKING([whether xattr_handler has name])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_XATTR_HANDLER_NAME], [
+	ZFS_LINUX_TEST_SRC([xattr_handler_name], [
 		#include <linux/xattr.h>
 
 		static const struct xattr_handler
 		    xops __attribute__ ((unused)) = {
 			.name = XATTR_NAME_POSIX_ACL_ACCESS,
 		};
-	],[
-	],[
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_NAME], [
+	AC_MSG_CHECKING([whether xattr_handler has name])
+	ZFS_LINUX_TEST_RESULT([xattr_handler_name], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_XATTR_HANDLER_NAME, 1,
 		    [xattr_handler has name])
@@ -58,52 +64,65 @@ AC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_NA
 ])
 
 dnl #
-dnl # 4.9 API change,
-dnl # iops->{set,get,remove}xattr and generic_{set,get,remove}xattr are
-dnl # removed. xattr operations will directly go through sb->s_xattr.
+dnl # Supported xattr handler get() interfaces checked newest to oldest.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_HAVE_GENERIC_SETXATTR], [
-	AC_MSG_CHECKING([whether generic_setxattr() exists])
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/fs.h>
+AC_DEFUN([ZFS_AC_KERNEL_SRC_XATTR_HANDLER_GET], [
+	ZFS_LINUX_TEST_SRC([xattr_handler_get_dentry_inode], [
 		#include <linux/xattr.h>
 
-		static const struct inode_operations
-		    iops __attribute__ ((unused)) = {
-			.setxattr = generic_setxattr
+		int get(const struct xattr_handler *handler,
+		    struct dentry *dentry, struct inode *inode,
+		    const char *name, void *buffer, size_t size) { return 0; }
+		static const struct xattr_handler
+		    xops __attribute__ ((unused)) = {
+			.get = get,
 		};
-	],[
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_GENERIC_SETXATTR, 1,
-		    [generic_setxattr() exists])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
+	],[])
 
-dnl #
-dnl # Supported xattr handler get() interfaces checked newest to oldest.
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_GET], [
-	dnl #
-	dnl # 4.7 API change,
-	dnl # The xattr_handler->get() callback was changed to take both
-	dnl # dentry and inode.
-	dnl #
-	AC_MSG_CHECKING([whether xattr_handler->get() wants both dentry and inode])
-	ZFS_LINUX_TRY_COMPILE([
+	ZFS_LINUX_TEST_SRC([xattr_handler_get_xattr_handler], [
 		#include <linux/xattr.h>
 
 		int get(const struct xattr_handler *handler,
-		    struct dentry *dentry, struct inode *inode,
-		    const char *name, void *buffer, size_t size) { return 0; }
+		    struct dentry *dentry, const char *name,
+		    void *buffer, size_t size) { return 0; }
 		static const struct xattr_handler
 		    xops __attribute__ ((unused)) = {
 			.get = get,
 		};
-	],[
-	],[
+	],[])
+
+	ZFS_LINUX_TEST_SRC([xattr_handler_get_dentry], [
+		#include <linux/xattr.h>
+
+		int get(struct dentry *dentry, const char *name,
+		    void *buffer, size_t size, int handler_flags)
+		    { return 0; }
+		static const struct xattr_handler
+		    xops __attribute__ ((unused)) = {
+			.get = get,
+		};
+	],[])
+
+	ZFS_LINUX_TEST_SRC([xattr_handler_get_inode], [
+		#include <linux/xattr.h>
+
+		int get(struct inode *ip, const char *name,
+		    void *buffer, size_t size) { return 0; }
+		static const struct xattr_handler
+		    xops __attribute__ ((unused)) = {
+			.get = get,
+		};
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_GET], [
+	dnl #
+	dnl # 4.7 API change,
+	dnl # The xattr_handler->get() callback was changed to take both
+	dnl # dentry and inode.
+	dnl #
+	AC_MSG_CHECKING([whether xattr_handler->get() wants dentry and inode])
+	ZFS_LINUX_TEST_RESULT([xattr_handler_get_dentry_inode], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_XATTR_GET_DENTRY_INODE, 1,
 		    [xattr_handler->get() wants both dentry and inode])
@@ -115,69 +134,40 @@ AC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_GE
 		dnl # should be accessed by handler->flags.
 		dnl #
 		AC_MSG_RESULT(no)
-		AC_MSG_CHECKING([whether xattr_handler->get() wants xattr_handler])
-		ZFS_LINUX_TRY_COMPILE([
-			#include <linux/xattr.h>
-
-			int get(const struct xattr_handler *handler,
-			    struct dentry *dentry, const char *name,
-			    void *buffer, size_t size) { return 0; }
-			static const struct xattr_handler
-			    xops __attribute__ ((unused)) = {
-				.get = get,
-			};
-		],[
-		],[
+		AC_MSG_CHECKING(
+		    [whether xattr_handler->get() wants xattr_handler])
+		ZFS_LINUX_TEST_RESULT([xattr_handler_get_xattr_handler], [
 			AC_MSG_RESULT(yes)
 			AC_DEFINE(HAVE_XATTR_GET_HANDLER, 1,
 			    [xattr_handler->get() wants xattr_handler])
 		],[
 			dnl #
 			dnl # 2.6.33 API change,
-			dnl # The xattr_handler->get() callback was changed to take
-			dnl # a dentry instead of an inode, and a handler_flags
-			dnl # argument was added.
+			dnl # The xattr_handler->get() callback was changed
+			dnl # to take a dentry instead of an inode, and a
+			dnl # handler_flags argument was added.
 			dnl #
 			AC_MSG_RESULT(no)
-			AC_MSG_CHECKING([whether xattr_handler->get() wants dentry])
-			ZFS_LINUX_TRY_COMPILE([
-				#include <linux/xattr.h>
-
-				int get(struct dentry *dentry, const char *name,
-				    void *buffer, size_t size, int handler_flags)
-				    { return 0; }
-				static const struct xattr_handler
-				    xops __attribute__ ((unused)) = {
-					.get = get,
-				};
-			],[
-			],[
+			AC_MSG_CHECKING(
+			    [whether xattr_handler->get() wants dentry])
+			ZFS_LINUX_TEST_RESULT([xattr_handler_get_dentry], [
 				AC_MSG_RESULT(yes)
 				AC_DEFINE(HAVE_XATTR_GET_DENTRY, 1,
 				    [xattr_handler->get() wants dentry])
 			],[
 				dnl #
-				dnl # 2.6.32 API
+				dnl # Legacy 2.6.32 API
 				dnl #
 				AC_MSG_RESULT(no)
 				AC_MSG_CHECKING(
 				    [whether xattr_handler->get() wants inode])
-				ZFS_LINUX_TRY_COMPILE([
-					#include <linux/xattr.h>
-
-					int get(struct inode *ip, const char *name,
-					    void *buffer, size_t size) { return 0; }
-					static const struct xattr_handler
-					    xops __attribute__ ((unused)) = {
-						.get = get,
-					};
-				],[
-				],[
+				ZFS_LINUX_TEST_RESULT(
+				    [xattr_handler_get_inode], [
 					AC_MSG_RESULT(yes)
 					AC_DEFINE(HAVE_XATTR_GET_INODE, 1,
 					    [xattr_handler->get() wants inode])
 				],[
-					AC_MSG_ERROR([no; please file a bug report])
+					ZFS_LINUX_TEST_ERROR([xattr get()])
 				])
 			])
 		])
@@ -187,14 +177,8 @@ AC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_GE
 dnl #
 dnl # Supported xattr handler set() interfaces checked newest to oldest.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_SET], [
-	dnl #
-	dnl # 4.7 API change,
-	dnl # The xattr_handler->set() callback was changed to take both
-	dnl # dentry and inode.
-	dnl #
-	AC_MSG_CHECKING([whether xattr_handler->set() wants both dentry and inode])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_XATTR_HANDLER_SET], [
+	ZFS_LINUX_TEST_SRC([xattr_handler_set_dentry_inode], [
 		#include <linux/xattr.h>
 
 		int set(const struct xattr_handler *handler,
@@ -206,8 +190,54 @@ AC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_SE
 		    xops __attribute__ ((unused)) = {
 			.set = set,
 		};
-	],[
-	],[
+	],[])
+
+	ZFS_LINUX_TEST_SRC([xattr_handler_set_xattr_handler], [
+		#include <linux/xattr.h>
+
+		int set(const struct xattr_handler *handler,
+		    struct dentry *dentry, const char *name,
+		    const void *buffer, size_t size, int flags)
+		    { return 0; }
+		static const struct xattr_handler
+		    xops __attribute__ ((unused)) = {
+			.set = set,
+		};
+	],[])
+
+	ZFS_LINUX_TEST_SRC([xattr_handler_set_dentry], [
+		#include <linux/xattr.h>
+
+		int set(struct dentry *dentry, const char *name,
+		    const void *buffer, size_t size, int flags,
+		    int handler_flags) { return 0; }
+		static const struct xattr_handler
+		    xops __attribute__ ((unused)) = {
+			.set = set,
+		};
+	],[])
+
+	ZFS_LINUX_TEST_SRC([xattr_handler_set_inode], [
+		#include <linux/xattr.h>
+
+		int set(struct inode *ip, const char *name,
+		    const void *buffer, size_t size, int flags)
+		    { return 0; }
+		static const struct xattr_handler
+		    xops __attribute__ ((unused)) = {
+			.set = set,
+		};
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_SET], [
+	dnl #
+	dnl # 4.7 API change,
+	dnl # The xattr_handler->set() callback was changed to take both
+	dnl # dentry and inode.
+	dnl #
+	AC_MSG_CHECKING([whether xattr_handler->set() wants dentry and inode])
+	ZFS_LINUX_TEST_RESULT([xattr_handler_set_dentry_inode], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_XATTR_SET_DENTRY_INODE, 1,
 		    [xattr_handler->set() wants both dentry and inode])
@@ -219,71 +249,40 @@ AC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_SE
 		dnl # should be accessed by handler->flags.
 		dnl #
 		AC_MSG_RESULT(no)
-		AC_MSG_CHECKING([whether xattr_handler->set() wants xattr_handler])
-		ZFS_LINUX_TRY_COMPILE([
-			#include <linux/xattr.h>
-
-			int set(const struct xattr_handler *handler,
-			    struct dentry *dentry, const char *name,
-			    const void *buffer, size_t size, int flags)
-			    { return 0; }
-			static const struct xattr_handler
-			    xops __attribute__ ((unused)) = {
-				.set = set,
-			};
-		],[
-		],[
+		AC_MSG_CHECKING(
+		    [whether xattr_handler->set() wants xattr_handler])
+		ZFS_LINUX_TEST_RESULT([xattr_handler_set_xattr_handler], [
 			AC_MSG_RESULT(yes)
 			AC_DEFINE(HAVE_XATTR_SET_HANDLER, 1,
 			    [xattr_handler->set() wants xattr_handler])
 		],[
 			dnl #
 			dnl # 2.6.33 API change,
-			dnl # The xattr_handler->set() callback was changed to take a
-			dnl # dentry instead of an inode, and a handler_flags
-			dnl # argument was added.
+			dnl # The xattr_handler->set() callback was changed
+			dnl # to take a dentry instead of an inode, and a
+			dnl # handler_flags argument was added.
 			dnl #
 			AC_MSG_RESULT(no)
-			AC_MSG_CHECKING([whether xattr_handler->set() wants dentry])
-			ZFS_LINUX_TRY_COMPILE([
-				#include <linux/xattr.h>
-
-				int set(struct dentry *dentry, const char *name,
-				    const void *buffer, size_t size, int flags,
-				    int handler_flags) { return 0; }
-				static const struct xattr_handler
-				    xops __attribute__ ((unused)) = {
-					.set = set,
-				};
-			],[
-			],[
+			AC_MSG_CHECKING(
+			    [whether xattr_handler->set() wants dentry])
+			ZFS_LINUX_TEST_RESULT([xattr_handler_set_dentry], [
 				AC_MSG_RESULT(yes)
 				AC_DEFINE(HAVE_XATTR_SET_DENTRY, 1,
 				    [xattr_handler->set() wants dentry])
 			],[
 				dnl #
-				dnl # 2.6.32 API
+				dnl # Legacy 2.6.32 API
 				dnl #
 				AC_MSG_RESULT(no)
 				AC_MSG_CHECKING(
 				    [whether xattr_handler->set() wants inode])
-				ZFS_LINUX_TRY_COMPILE([
-					#include <linux/xattr.h>
-
-					int set(struct inode *ip, const char *name,
-					    const void *buffer, size_t size, int flags)
-					    { return 0; }
-					static const struct xattr_handler
-					    xops __attribute__ ((unused)) = {
-						.set = set,
-					};
-				],[
-				],[
+				ZFS_LINUX_TEST_RESULT(
+				    [xattr_handler_set_inode], [
 					AC_MSG_RESULT(yes)
 					AC_DEFINE(HAVE_XATTR_SET_INODE, 1,
 					    [xattr_handler->set() wants inode])
 				],[
-		                        AC_MSG_ERROR([no; please file a bug report])
+					ZFS_LINUX_TEST_ERROR([xattr set()])
 				])
 			])
 		])
@@ -293,12 +292,8 @@ AC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_SE
 dnl #
 dnl # Supported xattr handler list() interfaces checked newest to oldest.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_LIST], [
-	dnl # 4.5 API change,
-	dnl # The xattr_handler->list() callback was changed to take only a
-	dnl # dentry and it only needs to return if it's accessible.
-	AC_MSG_CHECKING([whether xattr_handler->list() wants simple])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_XATTR_HANDLER_LIST], [
+	ZFS_LINUX_TEST_SRC([xattr_handler_list_simple], [
 		#include <linux/xattr.h>
 
 		bool list(struct dentry *dentry) { return 0; }
@@ -306,8 +301,52 @@ AC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_LI
 		    xops __attribute__ ((unused)) = {
 			.list = list,
 		};
-	],[
-	],[
+	],[])
+
+	ZFS_LINUX_TEST_SRC([xattr_handler_list_xattr_handler], [
+		#include <linux/xattr.h>
+
+		size_t list(const struct xattr_handler *handler,
+		    struct dentry *dentry, char *list, size_t list_size,
+		    const char *name, size_t name_len) { return 0; }
+		static const struct xattr_handler
+		    xops __attribute__ ((unused)) = {
+			.list = list,
+		};
+	],[])
+
+	ZFS_LINUX_TEST_SRC([xattr_handler_list_dentry], [
+		#include <linux/xattr.h>
+
+		size_t list(struct dentry *dentry,
+		    char *list, size_t list_size,
+		    const char *name, size_t name_len,
+		    int handler_flags) { return 0; }
+		static const struct xattr_handler
+		    xops __attribute__ ((unused)) = {
+			.list = list,
+		};
+	],[])
+
+	ZFS_LINUX_TEST_SRC([xattr_handler_list_inode], [
+		#include <linux/xattr.h>
+
+		size_t list(struct inode *ip, char *lst,
+		    size_t list_size, const char *name,
+		    size_t name_len) { return 0; }
+		static const struct xattr_handler
+		    xops __attribute__ ((unused)) = {
+			.list = list,
+		};
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_LIST], [
+	dnl # 4.5 API change,
+	dnl # The xattr_handler->list() callback was changed to take only a
+	dnl # dentry and it only needs to return if it's accessible.
+	AC_MSG_CHECKING([whether xattr_handler->list() wants simple])
+	ZFS_LINUX_TEST_RESULT([xattr_handler_list_simple], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_XATTR_LIST_SIMPLE, 1,
 		    [xattr_handler->list() wants simple])
@@ -321,18 +360,7 @@ AC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_LI
 		AC_MSG_RESULT(no)
 		AC_MSG_CHECKING(
 		    [whether xattr_handler->list() wants xattr_handler])
-		ZFS_LINUX_TRY_COMPILE([
-			#include <linux/xattr.h>
-
-			size_t list(const struct xattr_handler *handler,
-			    struct dentry *dentry, char *list, size_t list_size,
-			    const char *name, size_t name_len) { return 0; }
-			static const struct xattr_handler
-			    xops __attribute__ ((unused)) = {
-				.list = list,
-			};
-		],[
-		],[
+		ZFS_LINUX_TEST_RESULT([xattr_handler_list_xattr_handler], [
 			AC_MSG_RESULT(yes)
 			AC_DEFINE(HAVE_XATTR_LIST_HANDLER, 1,
 			    [xattr_handler->list() wants xattr_handler])
@@ -346,47 +374,24 @@ AC_DEFUN([ZFS_AC_KERNEL_XATTR_HANDLER_LI
 			AC_MSG_RESULT(no)
 			AC_MSG_CHECKING(
 			    [whether xattr_handler->list() wants dentry])
-			ZFS_LINUX_TRY_COMPILE([
-				#include <linux/xattr.h>
-
-				size_t list(struct dentry *dentry,
-				    char *list, size_t list_size,
-				    const char *name, size_t name_len,
-				    int handler_flags) { return 0; }
-				static const struct xattr_handler
-				    xops __attribute__ ((unused)) = {
-					.list = list,
-				};
-			],[
-			],[
+			ZFS_LINUX_TEST_RESULT([xattr_handler_list_dentry], [
 				AC_MSG_RESULT(yes)
 				AC_DEFINE(HAVE_XATTR_LIST_DENTRY, 1,
 				    [xattr_handler->list() wants dentry])
 			],[
 				dnl #
-				dnl # 2.6.32 API
+				dnl # Legacy 2.6.32 API
 				dnl #
 				AC_MSG_RESULT(no)
 				AC_MSG_CHECKING(
 				    [whether xattr_handler->list() wants inode])
-				ZFS_LINUX_TRY_COMPILE([
-					#include <linux/xattr.h>
-
-					size_t list(struct inode *ip, char *lst,
-					    size_t list_size, const char *name,
-					    size_t name_len) { return 0; }
-					static const struct xattr_handler
-					    xops __attribute__ ((unused)) = {
-						.list = list,
-					};
-				],[
-				],[
+				ZFS_LINUX_TEST_RESULT(
+				    [xattr_handler_list_inode], [
 					AC_MSG_RESULT(yes)
 					AC_DEFINE(HAVE_XATTR_LIST_INODE, 1,
 					    [xattr_handler->list() wants inode])
 				],[
-		                        AC_MSG_ERROR(
-					    [no; please file a bug report])
+					ZFS_LINUX_TEST_ERROR([xattr list()])
 				])
 			])
 		])
@@ -398,15 +403,19 @@ dnl # 3.7 API change,
 dnl # The posix_acl_{from,to}_xattr functions gained a new
 dnl # parameter: user_ns
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_POSIX_ACL_FROM_XATTR_USERNS], [
-	AC_MSG_CHECKING([whether posix_acl_from_xattr() needs user_ns])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_POSIX_ACL_FROM_XATTR_USERNS], [
+	ZFS_LINUX_TEST_SRC([posix_acl_from_xattr_userns], [
 		#include <linux/cred.h>
 		#include <linux/fs.h>
 		#include <linux/posix_acl_xattr.h>
 	],[
 		posix_acl_from_xattr(&init_user_ns, NULL, 0);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_POSIX_ACL_FROM_XATTR_USERNS], [
+	AC_MSG_CHECKING([whether posix_acl_from_xattr() needs user_ns])
+	ZFS_LINUX_TEST_RESULT([posix_acl_from_xattr_userns], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_POSIX_ACL_FROM_XATTR_USERNS, 1,
 		    [posix_acl_from_xattr() needs user_ns])
@@ -415,3 +424,50 @@ AC_DEFUN([ZFS_AC_KERNEL_POSIX_ACL_FROM_X
 	])
 ])
 
+dnl #
+dnl # 4.9 API change,
+dnl # iops->{set,get,remove}xattr and generic_{set,get,remove}xattr are
+dnl # removed. xattr operations will directly go through sb->s_xattr.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_GENERIC_SETXATTR], [
+	ZFS_LINUX_TEST_SRC([have_generic_setxattr], [
+		#include <linux/fs.h>
+		#include <linux/xattr.h>
+
+		static const struct inode_operations
+		    iops __attribute__ ((unused)) = {
+			.setxattr = generic_setxattr
+		};
+	],[])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_GENERIC_SETXATTR], [
+	AC_MSG_CHECKING([whether generic_setxattr() exists])
+	ZFS_LINUX_TEST_RESULT([have_generic_setxattr], [
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_GENERIC_SETXATTR, 1,
+		    [generic_setxattr() exists])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_SRC_XATTR], [
+	ZFS_AC_KERNEL_SRC_CONST_XATTR_HANDLER
+	ZFS_AC_KERNEL_SRC_XATTR_HANDLER_NAME
+	ZFS_AC_KERNEL_SRC_XATTR_HANDLER_GET
+	ZFS_AC_KERNEL_SRC_XATTR_HANDLER_SET
+	ZFS_AC_KERNEL_SRC_XATTR_HANDLER_LIST
+	ZFS_AC_KERNEL_SRC_POSIX_ACL_FROM_XATTR_USERNS
+	ZFS_AC_KERNEL_SRC_GENERIC_SETXATTR
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_XATTR], [
+	ZFS_AC_KERNEL_CONST_XATTR_HANDLER
+	ZFS_AC_KERNEL_XATTR_HANDLER_NAME
+	ZFS_AC_KERNEL_XATTR_HANDLER_GET
+	ZFS_AC_KERNEL_XATTR_HANDLER_SET
+	ZFS_AC_KERNEL_XATTR_HANDLER_LIST
+	ZFS_AC_KERNEL_POSIX_ACL_FROM_XATTR_USERNS
+	ZFS_AC_KERNEL_GENERIC_SETXATTR
+])
Index: zfs-linux-0.8.2/config/kernel-zlib.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel-zlib.m4
+++ zfs-linux-0.8.2/config/kernel-zlib.m4
@@ -1,62 +1,25 @@
 dnl #
-dnl # zlib inflate compat,
-dnl # Verify the kernel has CONFIG_ZLIB_INFLATE support enabled.
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_CONFIG_ZLIB_INFLATE], [
-	AC_MSG_CHECKING([whether CONFIG_ZLIB_INFLATE is defined])
-	ZFS_LINUX_TRY_COMPILE([
-		#if !defined(CONFIG_ZLIB_INFLATE) && \
-		    !defined(CONFIG_ZLIB_INFLATE_MODULE)
-		#error CONFIG_ZLIB_INFLATE not defined
-		#endif
-	],[ ],[
-		AC_MSG_RESULT([yes])
-	],[
-		AC_MSG_RESULT([no])
-		AC_MSG_ERROR([
-	*** This kernel does not include the required zlib inflate support.
-	*** Rebuild the kernel with CONFIG_ZLIB_INFLATE=y|m set.])
-	])
-])
-
-dnl #
-dnl # zlib deflate compat,
-dnl # Verify the kernel has CONFIG_ZLIB_DEFLATE support enabled.
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_CONFIG_ZLIB_DEFLATE], [
-	AC_MSG_CHECKING([whether CONFIG_ZLIB_DEFLATE is defined])
-	ZFS_LINUX_TRY_COMPILE([
-		#if !defined(CONFIG_ZLIB_DEFLATE) && \
-		    !defined(CONFIG_ZLIB_DEFLATE_MODULE)
-		#error CONFIG_ZLIB_DEFLATE not defined
-		#endif
-	],[ ],[
-		AC_MSG_RESULT([yes])
-	],[
-		AC_MSG_RESULT([no])
-		AC_MSG_ERROR([
-	*** This kernel does not include the required zlib deflate support.
-	*** Rebuild the kernel with CONFIG_ZLIB_DEFLATE=y|m set.])
-	])
-])
-
-dnl #
 dnl # 2.6.39 API compat,
+dnl
 dnl # The function zlib_deflate_workspacesize() now take 2 arguments.
 dnl # This was done to avoid always having to allocate the maximum size
 dnl # workspace (268K).  The caller can now specific the windowBits and
 dnl # memLevel compression parameters to get a smaller workspace.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_2ARGS_ZLIB_DEFLATE_WORKSPACESIZE],
-	[AC_MSG_CHECKING([whether zlib_deflate_workspacesize() wants 2 args])
-	ZFS_LINUX_TRY_COMPILE([
+AC_DEFUN([ZFS_AC_KERNEL_SRC_2ARGS_ZLIB_DEFLATE_WORKSPACESIZE], [
+	ZFS_LINUX_TEST_SRC([2args_zlib_deflate_workspacesize], [
 		#include <linux/zlib.h>
 	],[
 		return zlib_deflate_workspacesize(MAX_WBITS, MAX_MEM_LEVEL);
-	],[
+	])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_2ARGS_ZLIB_DEFLATE_WORKSPACESIZE], [
+	AC_MSG_CHECKING([whether zlib_deflate_workspacesize() wants 2 args])
+	ZFS_LINUX_TEST_RESULT([2args_zlib_deflate_workspacesize], [
 		AC_MSG_RESULT(yes)
 		AC_DEFINE(HAVE_2ARGS_ZLIB_DEFLATE_WORKSPACESIZE, 1,
-		          [zlib_deflate_workspacesize() wants 2 args])
+		    [zlib_deflate_workspacesize() wants 2 args])
 	],[
 		AC_MSG_RESULT(no)
 	])
Index: zfs-linux-0.8.2/config/kernel.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/kernel.m4
+++ zfs-linux-0.8.2/config/kernel.m4
@@ -2,111 +2,217 @@ dnl #
 dnl # Default ZFS kernel configuration
 dnl #
 AC_DEFUN([ZFS_AC_CONFIG_KERNEL], [
+	dnl # Setup the kernel build environment.
 	ZFS_AC_KERNEL
 	ZFS_AC_QAT
-	ZFS_AC_KERNEL_ACCESS_OK_TYPE
-	ZFS_AC_TEST_MODULE
+
+	dnl # Sanity checks for module building and CONFIG_* defines
+	ZFS_AC_KERNEL_TEST_MODULE
+	ZFS_AC_KERNEL_CONFIG_DEFINED
+
+	dnl # Sequential ZFS_LINUX_TRY_COMPILE tests
+	ZFS_AC_KERNEL_FPU_HEADER
+	ZFS_AC_KERNEL_WAIT_QUEUE_ENTRY_T
 	ZFS_AC_KERNEL_MISC_MINOR
+	ZFS_AC_KERNEL_DECLARE_EVENT_CLASS
+
+	dnl # Parallel ZFS_LINUX_TEST_SRC / ZFS_LINUX_TEST_RESULT tests
+	ZFS_AC_KERNEL_TEST_SRC
+	ZFS_AC_KERNEL_TEST_RESULT
+
+	AS_IF([test "$LINUX_OBJ" != "$LINUX"], [
+		KERNEL_MAKE="$KERNEL_MAKE O=$LINUX_OBJ"
+	])
+
+	AC_SUBST(KERNEL_MAKE)
+])
+
+dnl #
+dnl # Generate and compile all of the kernel API test cases to determine
+dnl # which interfaces are available.  By invoking the kernel build system
+dnl # only once the compilation can be done in parallel significantly
+dnl # speeding up the process.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_TEST_SRC], [
+	ZFS_AC_KERNEL_SRC_OBJTOOL
+	ZFS_AC_KERNEL_SRC_GLOBAL_PAGE_STATE
+	ZFS_AC_KERNEL_SRC_ACCESS_OK_TYPE
+	ZFS_AC_KERNEL_SRC_CTL_NAME
+	ZFS_AC_KERNEL_SRC_PDE_DATA
+	ZFS_AC_KERNEL_SRC_FALLOCATE
+	ZFS_AC_KERNEL_SRC_2ARGS_ZLIB_DEFLATE_WORKSPACESIZE
+	ZFS_AC_KERNEL_SRC_RWSEM
+	ZFS_AC_KERNEL_SRC_SCHED
+	ZFS_AC_KERNEL_SRC_USLEEP_RANGE
+	ZFS_AC_KERNEL_SRC_KMEM_CACHE
+	ZFS_AC_KERNEL_SRC_WAIT
+	ZFS_AC_KERNEL_SRC_INODE_TIMES
+	ZFS_AC_KERNEL_SRC_INODE_LOCK
+	ZFS_AC_KERNEL_SRC_GROUP_INFO_GID
+	ZFS_AC_KERNEL_SRC_RW
+	ZFS_AC_KERNEL_SRC_TIMER_SETUP
+	ZFS_AC_KERNEL_SRC_CURRENT_BIO_TAIL
+	ZFS_AC_KERNEL_SRC_SUPER_USER_NS
+	ZFS_AC_KERNEL_SRC_SUBMIT_BIO
+	ZFS_AC_KERNEL_SRC_BLOCK_DEVICE_OPERATIONS
+	ZFS_AC_KERNEL_SRC_BLKDEV_GET_BY_PATH
+	ZFS_AC_KERNEL_SRC_BLKDEV_REREAD_PART
+	ZFS_AC_KERNEL_SRC_INVALIDATE_BDEV
+	ZFS_AC_KERNEL_SRC_LOOKUP_BDEV
+	ZFS_AC_KERNEL_SRC_BDEV_OPEN_EXCLUSIVE
+	ZFS_AC_KERNEL_SRC_BDEV_LOGICAL_BLOCK_SIZE
+	ZFS_AC_KERNEL_SRC_BDEV_PHYSICAL_BLOCK_SIZE
+	ZFS_AC_KERNEL_SRC_BIO_BVEC_ITER
+	ZFS_AC_KERNEL_SRC_BIO_FAILFAST
+	ZFS_AC_KERNEL_SRC_BIO_SET_DEV
+	ZFS_AC_KERNEL_SRC_BIO_OPS
+	ZFS_AC_KERNEL_SRC_BIO_END_IO_T_ARGS
+	ZFS_AC_KERNEL_SRC_BIO_BI_STATUS
+	ZFS_AC_KERNEL_SRC_BIO_RW_BARRIER
+	ZFS_AC_KERNEL_SRC_BIO_RW_DISCARD
+	ZFS_AC_KERNEL_SRC_BLK_QUEUE_BDI
+	ZFS_AC_KERNEL_SRC_BLK_QUEUE_DISCARD
+	ZFS_AC_KERNEL_SRC_BLK_QUEUE_SECURE_ERASE
+	ZFS_AC_KERNEL_SRC_BLK_QUEUE_FLAGS
+	ZFS_AC_KERNEL_SRC_BLK_QUEUE_FLUSH
+	ZFS_AC_KERNEL_SRC_BLK_QUEUE_MAX_HW_SECTORS
+	ZFS_AC_KERNEL_SRC_BLK_QUEUE_MAX_SEGMENTS
+	ZFS_AC_KERNEL_SRC_BLK_QUEUE_PLUG
+	ZFS_AC_KERNEL_SRC_GET_DISK_AND_MODULE
+	ZFS_AC_KERNEL_SRC_GET_DISK_RO
+	ZFS_AC_KERNEL_SRC_GENERIC_READLINK_GLOBAL
+	ZFS_AC_KERNEL_SRC_DISCARD_GRANULARITY
+	ZFS_AC_KERNEL_SRC_INODE_OWNER_OR_CAPABLE
+	ZFS_AC_KERNEL_SRC_XATTR
+	ZFS_AC_KERNEL_SRC_ACL
+	ZFS_AC_KERNEL_SRC_INODE_GETATTR
+	ZFS_AC_KERNEL_SRC_INODE_SET_FLAGS
+	ZFS_AC_KERNEL_SRC_INODE_SET_IVERSION
+	ZFS_AC_KERNEL_SRC_SHOW_OPTIONS
+	ZFS_AC_KERNEL_SRC_FILE_INODE
+	ZFS_AC_KERNEL_SRC_FILE_DENTRY
+	ZFS_AC_KERNEL_SRC_FSYNC
+	ZFS_AC_KERNEL_SRC_AIO_FSYNC
+	ZFS_AC_KERNEL_SRC_EVICT_INODE
+	ZFS_AC_KERNEL_SRC_DIRTY_INODE
+	ZFS_AC_KERNEL_SRC_SHRINKER
+	ZFS_AC_KERNEL_SRC_MKDIR_UMODE_T
+	ZFS_AC_KERNEL_SRC_LOOKUP_NAMEIDATA
+	ZFS_AC_KERNEL_SRC_CREATE_NAMEIDATA
+	ZFS_AC_KERNEL_SRC_GET_LINK
+	ZFS_AC_KERNEL_SRC_PUT_LINK
+	ZFS_AC_KERNEL_SRC_TMPFILE
+	ZFS_AC_KERNEL_SRC_TRUNCATE_RANGE
+	ZFS_AC_KERNEL_SRC_AUTOMOUNT
+	ZFS_AC_KERNEL_SRC_ENCODE_FH_WITH_INODE
+	ZFS_AC_KERNEL_SRC_COMMIT_METADATA
+	ZFS_AC_KERNEL_SRC_CLEAR_INODE
+	ZFS_AC_KERNEL_SRC_SETATTR_PREPARE
+	ZFS_AC_KERNEL_SRC_INSERT_INODE_LOCKED
+	ZFS_AC_KERNEL_SRC_DENTRY
+	ZFS_AC_KERNEL_SRC_TRUNCATE_SETSIZE
+	ZFS_AC_KERNEL_SRC_SECURITY_INODE
+	ZFS_AC_KERNEL_SRC_FST_MOUNT
+	ZFS_AC_KERNEL_SRC_BDI
+	ZFS_AC_KERNEL_SRC_SET_NLINK
+	ZFS_AC_KERNEL_SRC_ELEVATOR_CHANGE
+	ZFS_AC_KERNEL_SRC_SGET
+	ZFS_AC_KERNEL_SRC_LSEEK_EXECUTE
+	ZFS_AC_KERNEL_SRC_VFS_GETATTR
+	ZFS_AC_KERNEL_SRC_VFS_FSYNC_2ARGS
+	ZFS_AC_KERNEL_SRC_VFS_ITERATE
+	ZFS_AC_KERNEL_SRC_VFS_DIRECT_IO
+	ZFS_AC_KERNEL_SRC_VFS_RW_ITERATE
+	ZFS_AC_KERNEL_SRC_VFS_GENERIC_WRITE_CHECKS
+	ZFS_AC_KERNEL_SRC_KMAP_ATOMIC_ARGS
+	ZFS_AC_KERNEL_SRC_FOLLOW_DOWN_ONE
+	ZFS_AC_KERNEL_SRC_MAKE_REQUEST_FN
+	ZFS_AC_KERNEL_SRC_GENERIC_IO_ACCT
+	ZFS_AC_KERNEL_SRC_FPU
+	ZFS_AC_KERNEL_SRC_FMODE_T
+	ZFS_AC_KERNEL_SRC_KUIDGID_T
+	ZFS_AC_KERNEL_SRC_KUID_HELPERS
+	ZFS_AC_KERNEL_SRC_MODULE_PARAM_CALL_CONST
+	ZFS_AC_KERNEL_SRC_RENAME_WANTS_FLAGS
+	ZFS_AC_KERNEL_SRC_CURRENT_TIME
+	ZFS_AC_KERNEL_SRC_USERNS_CAPABILITIES
+	ZFS_AC_KERNEL_SRC_IN_COMPAT_SYSCALL
+	ZFS_AC_KERNEL_SRC_KTIME_GET_COARSE_REAL_TS64
+	ZFS_AC_KERNEL_SRC_TOTALRAM_PAGES_FUNC
+	ZFS_AC_KERNEL_SRC_TOTALHIGH_PAGES
+	ZFS_AC_KERNEL_SRC_KSTRTOUL
+
+	AC_MSG_CHECKING([for available kernel interfaces])
+	ZFS_LINUX_TEST_COMPILE_ALL([kabi])
+	AC_MSG_RESULT([done])
+])
+
+dnl #
+dnl # Check results of kernel interface tests.
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_TEST_RESULT], [
+	ZFS_AC_KERNEL_ACCESS_OK_TYPE
+	ZFS_AC_KERNEL_GLOBAL_PAGE_STATE
 	ZFS_AC_KERNEL_OBJTOOL
-	ZFS_AC_KERNEL_CONFIG
 	ZFS_AC_KERNEL_CTL_NAME
 	ZFS_AC_KERNEL_PDE_DATA
-	ZFS_AC_KERNEL_2ARGS_VFS_FSYNC
-	ZFS_AC_KERNEL_KUIDGID_T
 	ZFS_AC_KERNEL_FALLOCATE
 	ZFS_AC_KERNEL_2ARGS_ZLIB_DEFLATE_WORKSPACESIZE
-	ZFS_AC_KERNEL_RWSEM_SPINLOCK_IS_RAW
-	ZFS_AC_KERNEL_RWSEM_ACTIVITY
-	ZFS_AC_KERNEL_RWSEM_ATOMIC_LONG_COUNT
-	ZFS_AC_KERNEL_SCHED_RT_HEADER
-	ZFS_AC_KERNEL_SCHED_SIGNAL_HEADER
-	ZFS_AC_KERNEL_IO_SCHEDULE_TIMEOUT
-	ZFS_AC_KERNEL_4ARGS_VFS_GETATTR
-	ZFS_AC_KERNEL_3ARGS_VFS_GETATTR
-	ZFS_AC_KERNEL_2ARGS_VFS_GETATTR
+	ZFS_AC_KERNEL_RWSEM
+	ZFS_AC_KERNEL_SCHED
 	ZFS_AC_KERNEL_USLEEP_RANGE
-	ZFS_AC_KERNEL_KMEM_CACHE_ALLOCFLAGS
-	ZFS_AC_KERNEL_KMEM_CACHE_CREATE_USERCOPY
-	ZFS_AC_KERNEL_WAIT_ON_BIT
-	ZFS_AC_KERNEL_WAIT_QUEUE_ENTRY_T
-	ZFS_AC_KERNEL_WAIT_QUEUE_HEAD_ENTRY
+	ZFS_AC_KERNEL_KMEM_CACHE
+	ZFS_AC_KERNEL_WAIT
 	ZFS_AC_KERNEL_INODE_TIMES
 	ZFS_AC_KERNEL_INODE_LOCK
 	ZFS_AC_KERNEL_GROUP_INFO_GID
-	ZFS_AC_KERNEL_WRITE
-	ZFS_AC_KERNEL_READ
+	ZFS_AC_KERNEL_RW
 	ZFS_AC_KERNEL_TIMER_SETUP
-	ZFS_AC_KERNEL_DECLARE_EVENT_CLASS
 	ZFS_AC_KERNEL_CURRENT_BIO_TAIL
 	ZFS_AC_KERNEL_SUPER_USER_NS
 	ZFS_AC_KERNEL_SUBMIT_BIO
-	ZFS_AC_KERNEL_BLOCK_DEVICE_OPERATIONS_CHECK_EVENTS
-	ZFS_AC_KERNEL_BLOCK_DEVICE_OPERATIONS_RELEASE_VOID
-	ZFS_AC_KERNEL_TYPE_FMODE_T
+	ZFS_AC_KERNEL_BLOCK_DEVICE_OPERATIONS
 	ZFS_AC_KERNEL_BLKDEV_GET_BY_PATH
 	ZFS_AC_KERNEL_BLKDEV_REREAD_PART
-	ZFS_AC_KERNEL_OPEN_BDEV_EXCLUSIVE
+	ZFS_AC_KERNEL_INVALIDATE_BDEV
 	ZFS_AC_KERNEL_LOOKUP_BDEV
-	ZFS_AC_KERNEL_INVALIDATE_BDEV_ARGS
+	ZFS_AC_KERNEL_BDEV_OPEN_EXCLUSIVE
 	ZFS_AC_KERNEL_BDEV_LOGICAL_BLOCK_SIZE
 	ZFS_AC_KERNEL_BDEV_PHYSICAL_BLOCK_SIZE
 	ZFS_AC_KERNEL_BIO_BVEC_ITER
-	ZFS_AC_KERNEL_BIO_FAILFAST_DTD
+	ZFS_AC_KERNEL_BIO_FAILFAST
 	ZFS_AC_KERNEL_BIO_SET_DEV
-	ZFS_AC_KERNEL_REQ_FAILFAST_MASK
-	ZFS_AC_KERNEL_REQ_OP_DISCARD
-	ZFS_AC_KERNEL_REQ_OP_SECURE_ERASE
-	ZFS_AC_KERNEL_REQ_OP_FLUSH
-	ZFS_AC_KERNEL_BIO_BI_OPF
+	ZFS_AC_KERNEL_BIO_OPS
 	ZFS_AC_KERNEL_BIO_END_IO_T_ARGS
 	ZFS_AC_KERNEL_BIO_BI_STATUS
 	ZFS_AC_KERNEL_BIO_RW_BARRIER
 	ZFS_AC_KERNEL_BIO_RW_DISCARD
 	ZFS_AC_KERNEL_BLK_QUEUE_BDI
-	ZFS_AC_KERNEL_BLK_QUEUE_FLAG_CLEAR
-	ZFS_AC_KERNEL_BLK_QUEUE_FLAG_SET
+	ZFS_AC_KERNEL_BLK_QUEUE_DISCARD
+	ZFS_AC_KERNEL_BLK_QUEUE_SECURE_ERASE
+	ZFS_AC_KERNEL_BLK_QUEUE_FLAGS
 	ZFS_AC_KERNEL_BLK_QUEUE_FLUSH
 	ZFS_AC_KERNEL_BLK_QUEUE_MAX_HW_SECTORS
 	ZFS_AC_KERNEL_BLK_QUEUE_MAX_SEGMENTS
-	ZFS_AC_KERNEL_BLK_QUEUE_HAVE_BIO_RW_UNPLUG
-	ZFS_AC_KERNEL_BLK_QUEUE_HAVE_BLK_PLUG
+	ZFS_AC_KERNEL_BLK_QUEUE_PLUG
 	ZFS_AC_KERNEL_GET_DISK_AND_MODULE
 	ZFS_AC_KERNEL_GET_DISK_RO
-	ZFS_AC_KERNEL_HAVE_BIO_SET_OP_ATTRS
 	ZFS_AC_KERNEL_GENERIC_READLINK_GLOBAL
 	ZFS_AC_KERNEL_DISCARD_GRANULARITY
-	ZFS_AC_KERNEL_CONST_XATTR_HANDLER
-	ZFS_AC_KERNEL_XATTR_HANDLER_NAME
-	ZFS_AC_KERNEL_XATTR_HANDLER_GET
-	ZFS_AC_KERNEL_XATTR_HANDLER_SET
-	ZFS_AC_KERNEL_XATTR_HANDLER_LIST
 	ZFS_AC_KERNEL_INODE_OWNER_OR_CAPABLE
-	ZFS_AC_KERNEL_POSIX_ACL_FROM_XATTR_USERNS
-	ZFS_AC_KERNEL_POSIX_ACL_RELEASE
-	ZFS_AC_KERNEL_SET_CACHED_ACL_USABLE
-	ZFS_AC_KERNEL_POSIX_ACL_CHMOD
-	ZFS_AC_KERNEL_POSIX_ACL_EQUIV_MODE_WANTS_UMODE_T
-	ZFS_AC_KERNEL_POSIX_ACL_VALID_WITH_NS
-	ZFS_AC_KERNEL_INODE_OPERATIONS_PERMISSION
-	ZFS_AC_KERNEL_INODE_OPERATIONS_PERMISSION_WITH_NAMEIDATA
-	ZFS_AC_KERNEL_INODE_OPERATIONS_CHECK_ACL
-	ZFS_AC_KERNEL_INODE_OPERATIONS_CHECK_ACL_WITH_FLAGS
-	ZFS_AC_KERNEL_INODE_OPERATIONS_GET_ACL
-	ZFS_AC_KERNEL_INODE_OPERATIONS_SET_ACL
-	ZFS_AC_KERNEL_INODE_OPERATIONS_GETATTR
+	ZFS_AC_KERNEL_XATTR
+	ZFS_AC_KERNEL_ACL
+	ZFS_AC_KERNEL_INODE_GETATTR
 	ZFS_AC_KERNEL_INODE_SET_FLAGS
 	ZFS_AC_KERNEL_INODE_SET_IVERSION
-	ZFS_AC_KERNEL_GET_ACL_HANDLE_CACHE
 	ZFS_AC_KERNEL_SHOW_OPTIONS
 	ZFS_AC_KERNEL_FILE_INODE
 	ZFS_AC_KERNEL_FILE_DENTRY
 	ZFS_AC_KERNEL_FSYNC
-	ZFS_AC_KERNEL_EVICT_INODE
-	ZFS_AC_KERNEL_DIRTY_INODE_WITH_FLAGS
-	ZFS_AC_KERNEL_NR_CACHED_OBJECTS
-	ZFS_AC_KERNEL_FREE_CACHED_OBJECTS
-	ZFS_AC_KERNEL_FALLOCATE
 	ZFS_AC_KERNEL_AIO_FSYNC
+	ZFS_AC_KERNEL_EVICT_INODE
+	ZFS_AC_KERNEL_DIRTY_INODE
+	ZFS_AC_KERNEL_SHRINKER
 	ZFS_AC_KERNEL_MKDIR_UMODE_T
 	ZFS_AC_KERNEL_LOOKUP_NAMEIDATA
 	ZFS_AC_KERNEL_CREATE_NAMEIDATA
@@ -120,58 +226,38 @@ AC_DEFUN([ZFS_AC_CONFIG_KERNEL], [
 	ZFS_AC_KERNEL_CLEAR_INODE
 	ZFS_AC_KERNEL_SETATTR_PREPARE
 	ZFS_AC_KERNEL_INSERT_INODE_LOCKED
-	ZFS_AC_KERNEL_D_MAKE_ROOT
-	ZFS_AC_KERNEL_D_OBTAIN_ALIAS
-	ZFS_AC_KERNEL_D_PRUNE_ALIASES
-	ZFS_AC_KERNEL_D_SET_D_OP
-	ZFS_AC_KERNEL_D_REVALIDATE_NAMEIDATA
-	ZFS_AC_KERNEL_CONST_DENTRY_OPERATIONS
+	ZFS_AC_KERNEL_DENTRY
 	ZFS_AC_KERNEL_TRUNCATE_SETSIZE
-	ZFS_AC_KERNEL_6ARGS_SECURITY_INODE_INIT_SECURITY
-	ZFS_AC_KERNEL_CALLBACK_SECURITY_INODE_INIT_SECURITY
+	ZFS_AC_KERNEL_SECURITY_INODE
 	ZFS_AC_KERNEL_FST_MOUNT
-	ZFS_AC_KERNEL_SHRINK
-	ZFS_AC_KERNEL_SHRINK_CONTROL_HAS_NID
-	ZFS_AC_KERNEL_SHRINK_CONTROL_STRUCT
-	ZFS_AC_KERNEL_SHRINKER_CALLBACK
-	ZFS_AC_KERNEL_S_INSTANCES_LIST_HEAD
-	ZFS_AC_KERNEL_S_D_OP
 	ZFS_AC_KERNEL_BDI
 	ZFS_AC_KERNEL_SET_NLINK
 	ZFS_AC_KERNEL_ELEVATOR_CHANGE
-	ZFS_AC_KERNEL_5ARG_SGET
+	ZFS_AC_KERNEL_SGET
 	ZFS_AC_KERNEL_LSEEK_EXECUTE
+	ZFS_AC_KERNEL_VFS_GETATTR
+	ZFS_AC_KERNEL_VFS_FSYNC_2ARGS
 	ZFS_AC_KERNEL_VFS_ITERATE
-	ZFS_AC_KERNEL_VFS_RW_ITERATE
 	ZFS_AC_KERNEL_VFS_DIRECT_IO
-	ZFS_AC_KERNEL_GENERIC_WRITE_CHECKS
+	ZFS_AC_KERNEL_VFS_RW_ITERATE
+	ZFS_AC_KERNEL_VFS_GENERIC_WRITE_CHECKS
 	ZFS_AC_KERNEL_KMAP_ATOMIC_ARGS
 	ZFS_AC_KERNEL_FOLLOW_DOWN_ONE
 	ZFS_AC_KERNEL_MAKE_REQUEST_FN
-	ZFS_AC_KERNEL_GENERIC_IO_ACCT_3ARG
-	ZFS_AC_KERNEL_GENERIC_IO_ACCT_4ARG
+	ZFS_AC_KERNEL_GENERIC_IO_ACCT
 	ZFS_AC_KERNEL_FPU
+	ZFS_AC_KERNEL_FMODE_T
+	ZFS_AC_KERNEL_KUIDGID_T
 	ZFS_AC_KERNEL_KUID_HELPERS
 	ZFS_AC_KERNEL_MODULE_PARAM_CALL_CONST
 	ZFS_AC_KERNEL_RENAME_WANTS_FLAGS
-	ZFS_AC_KERNEL_HAVE_GENERIC_SETXATTR
 	ZFS_AC_KERNEL_CURRENT_TIME
-	ZFS_AC_KERNEL_GLOBAL_PAGE_STATE
-	ZFS_AC_KERNEL_ACL_HAS_REFCOUNT
 	ZFS_AC_KERNEL_USERNS_CAPABILITIES
 	ZFS_AC_KERNEL_IN_COMPAT_SYSCALL
 	ZFS_AC_KERNEL_KTIME_GET_COARSE_REAL_TS64
 	ZFS_AC_KERNEL_TOTALRAM_PAGES_FUNC
 	ZFS_AC_KERNEL_TOTALHIGH_PAGES
-	ZFS_AC_KERNEL_BLK_QUEUE_DISCARD
-	ZFS_AC_KERNEL_BLK_QUEUE_SECURE_ERASE
 	ZFS_AC_KERNEL_KSTRTOUL
-
-	AS_IF([test "$LINUX_OBJ" != "$LINUX"], [
-		KERNEL_MAKE="$KERNEL_MAKE O=$LINUX_OBJ"
-	])
-
-	AC_SUBST(KERNEL_MAKE)
 ])
 
 dnl #
@@ -190,9 +276,10 @@ AC_DEFUN([ZFS_AC_MODULE_SYMVERS], [
 		AS_IF([test ! -f "$LINUX_OBJ/$LINUX_SYMBOLS"], [
 			AC_MSG_ERROR([
 	*** Please make sure the kernel devel package for your distribution
-	*** is installed.  If you are building with a custom kernel, make sure the
-	*** kernel is configured, built, and the '--with-linux=PATH' configure
-	*** option refers to the location of the kernel source.])
+	*** is installed.  If you are building with a custom kernel, make sure
+	*** the kernel is configured, built, and the '--with-linux=PATH'
+	*** configure option refers to the location of the kernel source.
+			])
 		])
 	], [
 		LINUX_SYMBOLS=NONE
@@ -285,12 +372,16 @@ AC_DEFUN([ZFS_AC_KERNEL], [
 
 		AS_IF([test -z "$kernsrcver"], [
 			AC_MSG_RESULT([Not found])
-			AC_MSG_ERROR([*** Cannot determine kernel version.])
+			AC_MSG_ERROR([
+	*** Cannot determine kernel version.
+			])
 		])
 	], [
 		AC_MSG_RESULT([Not found])
 		if test "x$enable_linux_builtin" != xyes; then
-			AC_MSG_ERROR([*** Cannot find UTS_RELEASE definition.])
+			AC_MSG_ERROR([
+	*** Cannot find UTS_RELEASE definition.
+			])
 		else
 			AC_MSG_ERROR([
 	*** Cannot find UTS_RELEASE definition.
@@ -312,24 +403,27 @@ AC_DEFUN([ZFS_AC_KERNEL], [
 ])
 
 dnl #
-dnl # Detect the QAT module to be built against
-dnl # QAT provides hardware acceleration for data compression:
-dnl # 	https://01.org/intel-quickassist-technology
-dnl # * Download and install QAT driver from the above link
-dnl # * Start QAT driver in your system:
-dnl # 	service qat_service start
-dnl # * Enable QAT in ZFS, e.g.:
-dnl # 	./configure --with-qat=<qat-driver-path>/QAT1.6
-dnl #	make
-dnl # * Set GZIP compression in ZFS dataset:
-dnl # 	zfs set compression = gzip <dataset>
-dnl # Then the data written to this ZFS pool is compressed
-dnl # by QAT accelerator automatically, and de-compressed by
-dnl # QAT when read from the pool.
-dnl # * Get QAT hardware statistics by:
-dnl #	cat /proc/icp_dh895xcc_dev/qat
-dnl # * To disable QAT:
-dnl # 	insmod zfs.ko zfs_qat_disable=1
+dnl # Detect the QAT module to be built against, QAT provides hardware
+dnl # acceleration for data compression:
+dnl #
+dnl # https://01.org/intel-quickassist-technology
+dnl #
+dnl # 1) Download and install QAT driver from the above link
+dnl # 2) Start QAT driver in your system:
+dnl # 	 service qat_service start
+dnl # 3) Enable QAT in ZFS, e.g.:
+dnl # 	 ./configure --with-qat=<qat-driver-path>/QAT1.6
+dnl # 	 make
+dnl # 4) Set GZIP compression in ZFS dataset:
+dnl # 	 zfs set compression = gzip <dataset>
+dnl #
+dnl # Then the data written to this ZFS pool is compressed by QAT accelerator
+dnl # automatically, and de-compressed by QAT when read from the pool.
+dnl #
+dnl # 1) Get QAT hardware statistics with:
+dnl #	 cat /proc/icp_dh895xcc_dev/qat
+dnl # 2) To disable QAT:
+dnl # 	 insmod zfs.ko zfs_qat_disable=1
 dnl #
 AC_DEFUN([ZFS_AC_QAT], [
 	AC_ARG_WITH([qat],
@@ -350,11 +444,11 @@ AC_DEFUN([ZFS_AC_QAT], [
 		QAT_SRC="${qatsrc}/quickassist"
 		AS_IF([ test ! -e "$QAT_SRC/include/cpa.h"], [
 			AC_MSG_ERROR([
-		*** Please make sure the qat driver package is installed
-		*** and specify the location of the qat source with the
-		*** '--with-qat=PATH' option then try again. Failed to
-		*** find cpa.h in:
-		${QAT_SRC}/include])
+	*** Please make sure the qat driver package is installed
+	*** and specify the location of the qat source with the
+	*** '--with-qat=PATH' option then try again. Failed to
+	*** find cpa.h in:
+	${QAT_SRC}/include])
 		])
 	])
 
@@ -368,9 +462,9 @@ AC_DEFUN([ZFS_AC_QAT], [
 		QAT_OBJ=${qatbuild}
 		AS_IF([ ! test -e "$QAT_OBJ/icp_qa_al.ko" && ! test -e "$QAT_OBJ/qat_api.ko"], [
 			AC_MSG_ERROR([
-		*** Please make sure the qat driver is installed then try again.
-		*** Failed to find icp_qa_al.ko or qat_api.ko in:
-		$QAT_OBJ])
+	*** Please make sure the qat driver is installed then try again.
+	*** Failed to find icp_qa_al.ko or qat_api.ko in:
+	$QAT_OBJ])
 		])
 
 		AC_SUBST(QAT_SRC)
@@ -391,10 +485,10 @@ AC_DEFUN([ZFS_AC_QAT], [
 			AC_MSG_RESULT([$QAT_SYMBOLS])
 			AC_SUBST(QAT_SYMBOLS)
 		],[
-                       AC_MSG_ERROR([
-			*** Please make sure the qat driver is installed then try again.
-			*** Failed to find Module.symvers in:
-			$QAT_SYMBOLS])
+			AC_MSG_ERROR([
+	*** Please make sure the qat driver is installed then try again.
+	*** Failed to find Module.symvers in:
+	$QAT_SYMBOLS
 			])
 		])
 	])
@@ -403,14 +497,16 @@ AC_DEFUN([ZFS_AC_QAT], [
 dnl #
 dnl # Basic toolchain sanity check.
 dnl #
-AC_DEFUN([ZFS_AC_TEST_MODULE], [
+AC_DEFUN([ZFS_AC_KERNEL_TEST_MODULE], [
 	AC_MSG_CHECKING([whether modules can be built])
-	ZFS_LINUX_TRY_COMPILE([],[],[
+	ZFS_LINUX_TRY_COMPILE([], [], [
 		AC_MSG_RESULT([yes])
 	],[
 		AC_MSG_RESULT([no])
 		if test "x$enable_linux_builtin" != xyes; then
-			AC_MSG_ERROR([*** Unable to build an empty module.])
+			AC_MSG_ERROR([
+	*** Unable to build an empty module.
+			])
 		else
 			AC_MSG_ERROR([
 	*** Unable to build an empty module.
@@ -420,207 +516,313 @@ AC_DEFUN([ZFS_AC_TEST_MODULE], [
 ])
 
 dnl #
-dnl # Certain kernel build options are not supported.  These must be
-dnl # detected at configure time and cause a build failure.  Otherwise
-dnl # modules may be successfully built that behave incorrectly.
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_CONFIG], [
-	AS_IF([test "x$cross_compiling" != xyes], [
-		AC_RUN_IFELSE([
-			AC_LANG_PROGRAM([
-				#include "$LINUX/include/linux/license.h"
-			], [
-				return !license_is_gpl_compatible("$ZFS_META_LICENSE");
-			])
-		], [
-			AC_DEFINE([ZFS_IS_GPL_COMPATIBLE], [1],
-			    [Define to 1 if GPL-only symbols can be used])
-		], [
-		])
-	])
+dnl # ZFS_LINUX_CONFTEST_H
+dnl #
+AC_DEFUN([ZFS_LINUX_CONFTEST_H], [
+test -d build/$2 || mkdir -p build/$2
+cat - <<_ACEOF >build/$2/$2.h
+$1
+_ACEOF
+])
 
-	ZFS_AC_KERNEL_CONFIG_THREAD_SIZE
-	ZFS_AC_KERNEL_CONFIG_DEBUG_LOCK_ALLOC
-	ZFS_AC_KERNEL_CONFIG_TRIM_UNUSED_KSYMS
-	ZFS_AC_KERNEL_CONFIG_ZLIB_INFLATE
-	ZFS_AC_KERNEL_CONFIG_ZLIB_DEFLATE
+dnl #
+dnl # ZFS_LINUX_CONFTEST_C
+dnl #
+AC_DEFUN([ZFS_LINUX_CONFTEST_C], [
+test -d build/$2 || mkdir -p build/$2
+cat confdefs.h - <<_ACEOF >build/$2/$2.c
+$1
+_ACEOF
 ])
 
 dnl #
-dnl # Check configured THREAD_SIZE
-dnl #
-dnl # The stack size will vary by architecture, but as of Linux 3.15 on x86_64
-dnl # the default thread stack size was increased to 16K from 8K.  Therefore,
-dnl # on newer kernels and some architectures stack usage optimizations can be
-dnl # conditionally applied to improve performance without negatively impacting
-dnl # stability.
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_CONFIG_THREAD_SIZE], [
-	AC_MSG_CHECKING([whether kernel was built with 16K or larger stacks])
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/module.h>
-	],[
-		#if (THREAD_SIZE < 16384)
-		#error "THREAD_SIZE is less than 16K"
-		#endif
-	],[
-		AC_MSG_RESULT([yes])
-		AC_DEFINE(HAVE_LARGE_STACKS, 1, [kernel has large stacks])
-	],[
-		AC_MSG_RESULT([no])
-	])
+dnl # ZFS_LINUX_CONFTEST_MAKEFILE
+dnl #
+dnl # $1 - test case name
+dnl # $2 - add to top-level Makefile
+dnl # $3 - additional build flags
+dnl #
+AC_DEFUN([ZFS_LINUX_CONFTEST_MAKEFILE], [
+	test -d build || mkdir -p build
+	test -d build/$1 || mkdir -p build/$1
+
+	file=build/$1/Makefile
+
+	dnl # Example command line to manually build source.
+	cat - <<_ACEOF >$file
+# Example command line to manually build source
+# make modules -C $LINUX_OBJ $ARCH_UM M=$PWD/build/$1
+
+ccflags-y := -Werror $FRAME_LARGER_THAN
+_ACEOF
+
+	dnl # Additional custom CFLAGS as requested.
+	m4_ifval($3, [echo "ccflags-y += $3" >>$file], [])
+
+	dnl # Test case source
+	echo "obj-m := $1.o" >>$file
+
+	AS_IF([test "x$2" = "xyes"], [echo "obj-m += $1/" >>build/Makefile], [])
 ])
 
 dnl #
-dnl # Check CONFIG_DEBUG_LOCK_ALLOC
+dnl # ZFS_LINUX_TEST_PROGRAM(C)([PROLOGUE], [BODY])
 dnl #
-dnl # This is typically only set for debug kernels because it comes with
-dnl # a performance penalty.  However, when it is set it maps the non-GPL
-dnl # symbol mutex_lock() to the GPL-only mutex_lock_nested() symbol.
-dnl # This will cause a failure at link time which we'd rather know about
-dnl # at compile time.
-dnl #
-dnl # Since we plan to pursue making mutex_lock_nested() a non-GPL symbol
-dnl # with the upstream community we add a check to detect this case.
-dnl #
-AC_DEFUN([ZFS_AC_KERNEL_CONFIG_DEBUG_LOCK_ALLOC], [
-
-	ZFS_LINUX_CONFIG([DEBUG_LOCK_ALLOC], [
-		AC_MSG_CHECKING([whether mutex_lock() is GPL-only])
-		tmp_flags="$EXTRA_KCFLAGS"
-		ZFS_LINUX_TRY_COMPILE([
-			#include <linux/module.h>
-			#include <linux/mutex.h>
+m4_define([ZFS_LINUX_TEST_PROGRAM], [
+$1
+int
+main (void)
+{
+$2
+	;
+	return 0;
+}
+])
 
-			MODULE_LICENSE("$ZFS_META_LICENSE");
-		],[
-			struct mutex lock;
+dnl #
+dnl # ZFS_LINUX_TEST_REMOVE
+dnl #
+dnl # Removes the specified test source and results.
+dnl #
+AC_DEFUN([ZFS_LINUX_TEST_REMOVE], [
+	test -d build/$1 && rm -Rf build/$1
+	test -f build/Makefile && sed '/$1/d' build/Makefile
+])
 
-			mutex_init(&lock);
-			mutex_lock(&lock);
-			mutex_unlock(&lock);
-		],[
-			AC_MSG_RESULT(no)
-		],[
-			AC_MSG_RESULT(yes)
-			AC_MSG_ERROR([
-	*** Kernel built with CONFIG_DEBUG_LOCK_ALLOC which is incompatible
-	*** with the CDDL license and will prevent the module linking stage
-	*** from succeeding.  You must rebuild your kernel without this
-	*** option enabled.])
-		])
-		EXTRA_KCFLAGS="$tmp_flags"
-	], [])
+dnl #
+dnl # ZFS_LINUX_COMPILE
+dnl #
+dnl # $1 - build dir
+dnl # $2 - test command
+dnl # $3 - pass command
+dnl # $4 - fail command
+dnl # $5 - set KBUILD_MODPOST_NOFINAL='yes'
+dnl # $6 - set KBUILD_MODPOST_WARN='yes'
+dnl #
+dnl # Used internally by ZFS_LINUX_TEST_{COMPILE,MODPOST}
+dnl #
+AC_DEFUN([ZFS_LINUX_COMPILE], [
+	AC_TRY_COMMAND([
+	    KBUILD_MODPOST_NOFINAL="$5" KBUILD_MODPOST_WARN="$6"
+	    make modules -k -j$TEST_JOBS -C $LINUX_OBJ $ARCH_UM
+	    M=$PWD/$1 &>$1/build.log])
+	AS_IF([AC_TRY_COMMAND([$2])], [$3], [$4])
 ])
 
 dnl #
-dnl # Check CONFIG_TRIM_UNUSED_KSYMS
+dnl # ZFS_LINUX_TEST_COMPILE
 dnl #
-dnl # Verify the kernel has CONFIG_TRIM_UNUSED_KSYMS disabled.
+dnl # Perform a full compile excluding the final modpost phase.
 dnl #
-AC_DEFUN([ZFS_AC_KERNEL_CONFIG_TRIM_UNUSED_KSYMS], [
-	AC_MSG_CHECKING([whether CONFIG_TRIM_UNUSED_KSYM is disabled])
-	ZFS_LINUX_TRY_COMPILE([
-		#if defined(CONFIG_TRIM_UNUSED_KSYMS)
-		#error CONFIG_TRIM_UNUSED_KSYMS not defined
-		#endif
-	],[ ],[
-		AC_MSG_RESULT([yes])
+AC_DEFUN([ZFS_LINUX_TEST_COMPILE], [
+	ZFS_LINUX_COMPILE([$2], [test -f $2/build.log], [
+		mv $2/Makefile $2/Makefile.compile.$1
+		mv $2/build.log $2/build.log.$1
 	],[
-		AC_MSG_RESULT([no])
-		AS_IF([test "x$enable_linux_builtin" != xyes], [
-			AC_MSG_ERROR([
-	*** This kernel has unused symbols trimming enabled, please disable.
-	*** Rebuild the kernel with CONFIG_TRIM_UNUSED_KSYMS=n set.])
-	])])
+	        AC_MSG_ERROR([
+        *** Unable to compile test source to determine kernel interfaces.])
+	], [yes], [])
 ])
 
 dnl #
-dnl # ZFS_LINUX_CONFTEST_H
+dnl # ZFS_LINUX_TEST_MODPOST
 dnl #
-AC_DEFUN([ZFS_LINUX_CONFTEST_H], [
-cat - <<_ACEOF >conftest.h
-$1
-_ACEOF
+dnl # Perform a full compile including the modpost phase.  This may
+dnl # be an incremental build if the objects have already been built.
+dnl #
+AC_DEFUN([ZFS_LINUX_TEST_MODPOST], [
+	ZFS_LINUX_COMPILE([$2], [test -f $2/build.log], [
+		mv $2/Makefile $2/Makefile.modpost.$1
+		cat $2/build.log >>build/build.log.$1
+	],[
+	        AC_MSG_ERROR([
+        *** Unable to modpost test source to determine kernel interfaces.])
+	], [], [yes])
 ])
 
 dnl #
-dnl # ZFS_LINUX_CONFTEST_C
+dnl # Perform the compilation of the test cases in two phases.
 dnl #
-AC_DEFUN([ZFS_LINUX_CONFTEST_C], [
-cat confdefs.h - <<_ACEOF >conftest.c
-$1
-_ACEOF
+dnl # Phase 1) attempt to build the object files for all of the tests
+dnl #          defined by the ZFS_LINUX_TEST_SRC macro.  But do not
+dnl #          perform the final modpost stage.
+dnl #
+dnl # Phase 2) disable all tests which failed the initial compilation,
+dnl #          then invoke the final modpost step for the remaining tests.
+dnl #
+dnl # This allows us efficiently build the test cases in parallel while
+dnl # remaining resilient to build failures which are expected when
+dnl # detecting the available kernel interfaces.
+dnl #
+dnl # The maximum allowed parallelism can be controlled by setting the
+dnl # TEST_JOBS environment variable.  Otherwise, it default to $(nproc).
+dnl #
+AC_DEFUN([ZFS_LINUX_TEST_COMPILE_ALL], [
+	dnl # Phase 1 - Compilation only, final linking is skipped.
+	ZFS_LINUX_TEST_COMPILE([$1], [build])
+
+	dnl #
+	dnl # Phase 2 - When building external modules disable test cases
+	dnl # which failed to compile and invoke modpost to verify the
+	dnl # final linking.
+	dnl #
+	dnl # Test names suffixed with '_license' call modpost independently
+	dnl # to ensure that a single incompatibility does not result in the
+	dnl # modpost phase exiting early.  This check is not performed on
+	dnl # every symbol since the majority are compatible and doing so
+	dnl # would significantly slow down this phase.
+	dnl #
+	dnl # When configuring for builtin (--enable-linux-builtin)
+	dnl # fake the linking step artificially create the expected .ko
+	dnl # files for tests which did compile.  This is required for
+	dnl # kernels which do not have loadable module support or have
+	dnl # not yet been built.
+	dnl #
+	AS_IF([test "x$enable_linux_builtin" = "xno"], [
+		for dir in $(awk '/^obj-m/ { print [$]3 }' \
+		    build/Makefile.compile.$1); do
+			name=${dir%/}
+			AS_IF([test -f build/$name/$name.o], [
+				AS_IF([test "${name##*_}" = "license"], [
+					ZFS_LINUX_TEST_MODPOST([$1],
+					    [build/$name])
+					echo "obj-n += $dir" >>build/Makefile
+				], [
+					echo "obj-m += $dir" >>build/Makefile
+				])
+			], [
+				echo "obj-n += $dir" >>build/Makefile
+			])
+		done
+
+		ZFS_LINUX_TEST_MODPOST([$1], [build])
+	], [
+		for dir in $(awk '/^obj-m/ { print [$]3 }' \
+		    build/Makefile.compile.$1); do
+			name=${dir%/}
+			AS_IF([test -f build/$name/$name.o], [
+				touch build/$name/$name.ko
+			])
+		done
+	])
 ])
 
 dnl #
-dnl # ZFS_LANG_PROGRAM(C)([PROLOGUE], [BODY])
+dnl # ZFS_LINUX_TEST_SRC
 dnl #
-m4_define([ZFS_LANG_PROGRAM], [
-$1
-int
-main (void)
-{
-dnl Do *not* indent the following line: there may be CPP directives.
-dnl Don't move the `;' right after for the same reason.
-$2
-  ;
-  return 0;
-}
+dnl # $1 - name
+dnl # $2 - global
+dnl # $3 - source
+dnl # $4 - extra cflags
+dnl # $5 - check license-compatibility
+dnl #
+dnl # N.B because all of the test cases are compiled in parallel they
+dnl # must never depend on the results of previous tests.  Each test
+dnl # needs to be entirely independent.
+dnl #
+AC_DEFUN([ZFS_LINUX_TEST_SRC], [
+	ZFS_LINUX_CONFTEST_C([ZFS_LINUX_TEST_PROGRAM([[$2]], [[$3]])], [$1])
+	ZFS_LINUX_CONFTEST_MAKEFILE([$1], [yes], [$4])
+
+	AS_IF([ test -n "$5" ], [
+		ZFS_LINUX_CONFTEST_C([ZFS_LINUX_TEST_PROGRAM([[
+			#include <linux/module.h>
+			MODULE_LICENSE("$5");
+			$2]], [[$3]])], [$1_license])
+		ZFS_LINUX_CONFTEST_MAKEFILE([$1_license], [yes], [$4])
+	])
 ])
 
 dnl #
-dnl # ZFS_LINUX_COMPILE_IFELSE / like AC_COMPILE_IFELSE
+dnl # ZFS_LINUX_TEST_RESULT
 dnl #
-AC_DEFUN([ZFS_LINUX_COMPILE_IFELSE], [
-	m4_ifvaln([$1], [ZFS_LINUX_CONFTEST_C([$1])])
-	m4_ifvaln([$6], [ZFS_LINUX_CONFTEST_H([$6])], [ZFS_LINUX_CONFTEST_H([])])
-	rm -Rf build && mkdir -p build && touch build/conftest.mod.c
-	echo "obj-m := conftest.o" >build/Makefile
-	modpost_flag=''
-	test "x$enable_linux_builtin" = xyes && modpost_flag='modpost=true' # fake modpost stage
-	AS_IF(
-		[AC_TRY_COMMAND(cp conftest.c conftest.h build && make [$2] -C $LINUX_OBJ EXTRA_CFLAGS="-Werror $FRAME_LARGER_THAN $EXTRA_KCFLAGS" $ARCH_UM M=$PWD/build $modpost_flag) >/dev/null && AC_TRY_COMMAND([$3])],
-		[$4],
-		[_AC_MSG_LOG_CONFTEST m4_ifvaln([$5],[$5])]
-	)
-	rm -Rf build
+dnl # $1 - name of a test source (ZFS_LINUX_TEST_SRC)
+dnl # $2 - run on success (valid .ko generated)
+dnl # $3 - run on failure (unable to compile)
+dnl #
+AC_DEFUN([ZFS_LINUX_TEST_RESULT], [
+	AS_IF([test -d build/$1], [
+		AS_IF([test -f build/$1/$1.ko], [$2], [$3])
+	], [
+		AC_MSG_ERROR([
+	*** No matching source for the "$1" test, check that
+	*** both the test source and result macros refer to the same name.
+		])
+	])
 ])
 
 dnl #
-dnl # ZFS_LINUX_TRY_COMPILE like AC_TRY_COMPILE
-dnl #
-AC_DEFUN([ZFS_LINUX_TRY_COMPILE],
-	[ZFS_LINUX_COMPILE_IFELSE(
-	[AC_LANG_SOURCE([ZFS_LANG_PROGRAM([[$1]], [[$2]])])],
-	[modules],
-	[test -s build/conftest.o],
-	[$3], [$4])
+dnl # ZFS_LINUX_TEST_ERROR
+dnl #
+dnl # Generic error message which can be used when none of the expected
+dnl # kernel interfaces were detected.
+dnl #
+AC_DEFUN([ZFS_LINUX_TEST_ERROR], [
+	AC_MSG_ERROR([
+	*** None of the expected "$1" interfaces were detected.
+	*** This may be because your kernel version is newer than what is
+	*** supported, or you are using a patched custom kernel with
+	*** incompatible modifications.
+	***
+	*** ZFS Version: $ZFS_META_ALIAS
+	*** Compatible Kernels: $ZFS_META_KVER_MIN - $ZFS_META_KVER_MAX
+	])
 ])
 
 dnl #
-dnl # ZFS_LINUX_CONFIG
-dnl #
-AC_DEFUN([ZFS_LINUX_CONFIG],
-	[AC_MSG_CHECKING([whether kernel was built with CONFIG_$1])
-	ZFS_LINUX_TRY_COMPILE([
-		#include <linux/module.h>
-	],[
-		#ifndef CONFIG_$1
-		#error CONFIG_$1 not #defined
-		#endif
-	],[
-		AC_MSG_RESULT([yes])
-		$2
-	],[
-		AC_MSG_RESULT([no])
-		$3
+dnl # ZFS_LINUX_TEST_RESULT_SYMBOL
+dnl #
+dnl # Like ZFS_LINUX_TEST_RESULT except ZFS_CHECK_SYMBOL_EXPORT is called to
+dnl # verify symbol exports, unless --enable-linux-builtin was provided to
+dnl # configure.
+dnl #
+AC_DEFUN([ZFS_LINUX_TEST_RESULT_SYMBOL], [
+	AS_IF([ ! test -f build/$1/$1.ko], [
+		$5
+	], [
+		AS_IF([test "x$enable_linux_builtin" != "xyes"], [
+			ZFS_CHECK_SYMBOL_EXPORT([$2], [$3], [$4], [$5])
+		], [
+			$4
+		])
 	])
 ])
 
 dnl #
+dnl # ZFS_LINUX_COMPILE_IFELSE
+dnl #
+AC_DEFUN([ZFS_LINUX_COMPILE_IFELSE], [
+	ZFS_LINUX_TEST_REMOVE([conftest])
+
+	m4_ifvaln([$1], [ZFS_LINUX_CONFTEST_C([$1], [conftest])])
+	m4_ifvaln([$5], [ZFS_LINUX_CONFTEST_H([$5], [conftest])],
+	    [ZFS_LINUX_CONFTEST_H([], [conftest])])
+
+	ZFS_LINUX_CONFTEST_MAKEFILE([conftest], [no],
+	    [m4_ifvaln([$5], [-I$PWD/build/conftest], [])])
+	ZFS_LINUX_COMPILE([build/conftest], [$2], [$3], [$4], [], [])
+])
+
+dnl #
+dnl # ZFS_LINUX_TRY_COMPILE
+dnl #
+dnl # $1 - global
+dnl # $2 - source
+dnl # $3 - run on success (valid .ko generated)
+dnl # $4 - run on failure (unable to compile)
+dnl #
+AC_DEFUN([ZFS_LINUX_TRY_COMPILE], [
+	ZFS_LINUX_COMPILE_IFELSE(
+	    [ZFS_LINUX_TEST_PROGRAM([[$1]], [[$2]])],
+	    [test -f build/conftest/conftest.ko],
+	    [$3], [$4])
+])
+
+dnl #
 dnl # ZFS_CHECK_SYMBOL_EXPORT
-dnl # check symbol exported or not
+dnl #
+dnl # Check if a symbol is exported on not by consulting the symbols
+dnl # file, or optionally the source code.
 dnl #
 AC_DEFUN([ZFS_CHECK_SYMBOL_EXPORT], [
 	grep -q -E '[[[:space:]]]$1[[[:space:]]]' \
@@ -649,8 +851,10 @@ AC_DEFUN([ZFS_CHECK_SYMBOL_EXPORT], [
 
 dnl #
 dnl # ZFS_LINUX_TRY_COMPILE_SYMBOL
-dnl # like ZFS_LINUX_TRY_COMPILE, except ZFS_CHECK_SYMBOL_EXPORT
-dnl # is called if not compiling for builtin
+dnl #
+dnl # Like ZFS_LINUX_TRY_COMPILER except ZFS_CHECK_SYMBOL_EXPORT is called
+dnl # to verify symbol exports, unless --enable-linux-builtin was provided
+dnl # to configure.
 dnl #
 AC_DEFUN([ZFS_LINUX_TRY_COMPILE_SYMBOL], [
 	ZFS_LINUX_TRY_COMPILE([$1], [$2], [rc=0], [rc=1])
@@ -673,10 +877,9 @@ dnl # ZFS_LINUX_TRY_COMPILE_HEADER
 dnl # like ZFS_LINUX_TRY_COMPILE, except the contents conftest.h are
 dnl # provided via the fifth parameter
 dnl #
-AC_DEFUN([ZFS_LINUX_TRY_COMPILE_HEADER],
-	[ZFS_LINUX_COMPILE_IFELSE(
-	[AC_LANG_SOURCE([ZFS_LANG_PROGRAM([[$1]], [[$2]])])],
-	[modules],
-	[test -s build/conftest.o],
-	[$3], [$4], [$5])
+AC_DEFUN([ZFS_LINUX_TRY_COMPILE_HEADER], [
+	ZFS_LINUX_COMPILE_IFELSE(
+	    [ZFS_LINUX_TEST_PROGRAM([[$1]], [[$2]])],
+	    [test -f build/conftest/conftest.ko],
+	    [$3], [$4], [$5])
 ])
Index: zfs-linux-0.8.2/config/zfs-build.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/zfs-build.m4
+++ zfs-linux-0.8.2/config/zfs-build.m4
@@ -166,6 +166,17 @@ AC_DEFUN([ZFS_AC_CONFIG_ALWAYS], [
 ])
 
 AC_DEFUN([ZFS_AC_CONFIG], [
+
+        dnl # Remove the previous build test directory.
+        rm -Rf build
+
+	AC_ARG_VAR([TEST_JOBS],
+	    [simultaneous jobs during configure (defaults to $(nproc))])
+	if test "x$ac_cv_env_TEST_JOBS_set" != "xset"; then
+		TEST_JOBS=$(nproc)
+	fi
+	AC_SUBST(TEST_JOBS)
+
 	ZFS_CONFIG=all
 	AC_ARG_WITH([config],
 		AS_HELP_STRING([--with-config=CONFIG],
Index: zfs-linux-0.8.2/config/zfs-meta.m4
===================================================================
--- zfs-linux-0.8.2.orig/config/zfs-meta.m4
+++ zfs-linux-0.8.2/config/zfs-meta.m4
@@ -161,6 +161,24 @@ AC_DEFUN([ZFS_AC_META], [
 			AC_SUBST([ZFS_META_AUTHOR])
 		fi
 
+		ZFS_META_KVER_MIN=_ZFS_AC_META_GETVAL([Linux-Minimum]);
+		if test -n "$ZFS_META_KVER_MIN"; then
+			AC_DEFINE_UNQUOTED([ZFS_META_KVER_MIN],
+			    ["$ZFS_META_KVER_MIN"],
+			    [Define the minimum compatible kernel version.]
+			)
+			AC_SUBST([ZFS_META_KVER_MIN])
+		fi
+
+		ZFS_META_KVER_MAX=_ZFS_AC_META_GETVAL([Linux-Maximum]);
+		if test -n "$ZFS_META_KVER_MAX"; then
+			AC_DEFINE_UNQUOTED([ZFS_META_KVER_MAX],
+			    ["$ZFS_META_KVER_MAX"],
+			    [Define the maximum compatible kernel version.]
+			)
+			AC_SUBST([ZFS_META_KVER_MAX])
+		fi
+
 		m4_pattern_allow([^LT_(CURRENT|REVISION|AGE)$])
 		ZFS_META_LT_CURRENT=_ZFS_AC_META_GETVAL([LT_Current]);
 		ZFS_META_LT_REVISION=_ZFS_AC_META_GETVAL([LT_Revision]);
