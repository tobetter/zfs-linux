From 68dde63d138882860109178f4ab0b7b1b1bb3cfd Mon Sep 17 00:00:00 2001
From: Brian Behlendorf <behlendorf1@llnl.gov>
Date: Thu, 9 Apr 2020 09:16:46 -0700
Subject: [PATCH] Linux 5.7 compat: blk_alloc_queue()
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 8bit

Commit https://github.com/torvalds/linux/commit/3d745ea5 simplified
the blk_alloc_queue() interface by updating it to take the request
queue as an argument.  Add a wrapper function which accepts the new
arguments and internally uses the available interfaces.

Other minor changes include increasing the Linux-Maximum to 5.6 now
that 5.6 has been released.  It was not bumped to 5.7 because this
release has not yet been finalized and is still subject to change.

Added local 'struct zvol_state_os *zso' variable to zvol_alloc.

Reviewed-by: George Melikov <mail@gmelikov.ru>
Reviewed-by: Tony Hutter <hutter2@llnl.gov>
Signed-off-by: Brian Behlendorf <behlendorf1@llnl.gov>
Closes #10181
Closes #10187
Signed-off-by: Colin Ian King <colin.king@canonical.com>
---

diff -Npur a/config/kernel-make-request-fn.m4 b/config/kernel-make-request-fn.m4
--- a/config/kernel-make-request-fn.m4	2020-01-22 16:49:01.000000000 -0500
+++ b/config/kernel-make-request-fn.m4	2020-04-12 15:56:35.244111118 -0400
@@ -25,23 +25,34 @@ AC_DEFUN([ZFS_AC_KERNEL_SRC_MAKE_REQUEST
 	],[
 		blk_queue_make_request(NULL, &make_request);
 	])
+	ZFS_LINUX_TEST_SRC([blk_alloc_queue_request_fn], [
+		#include <linux/blkdev.h>
+		blk_qc_t make_request(struct request_queue *q,
+		    struct bio *bio) { return (BLK_QC_T_NONE); }
+	],[
+		struct request_queue *q __attribute__ ((unused));
+		q = blk_alloc_queue(make_request, NUMA_NO_NODE);
+	])
 ])
 
 AC_DEFUN([ZFS_AC_KERNEL_MAKE_REQUEST_FN], [
 	dnl #
-	dnl # Legacy API
-	dnl # make_request_fn returns int.
+	dnl # Linux 5.7 API Change
+	dnl # blk_alloc_queue() expects request function.
 	dnl #
-	AC_MSG_CHECKING([whether make_request_fn() returns int])
-	ZFS_LINUX_TEST_RESULT([make_request_fn_int], [
+	AC_MSG_CHECKING([whether blk_alloc_queue() expects request function])
+	ZFS_LINUX_TEST_RESULT([blk_alloc_queue_request_fn], [
+		AC_MSG_RESULT(yes)
+		dnl # Checked as part of the blk_alloc_queue_request_fn test
+		AC_MSG_CHECKING([whether make_request_fn() returns blk_qc_t])
 		AC_MSG_RESULT(yes)
-		AC_DEFINE(MAKE_REQUEST_FN_RET, int,
+		AC_DEFINE(HAVE_BLK_ALLOC_QUEUE_REQUEST_FN, 1,
+		    [blk_alloc_queue() expects request function])
+		AC_DEFINE(MAKE_REQUEST_FN_RET, blk_qc_t,
 		    [make_request_fn() return type])
-		AC_DEFINE(HAVE_MAKE_REQUEST_FN_RET_INT, 1,
-		    [Noting that make_request_fn() returns int])
+		AC_DEFINE(HAVE_MAKE_REQUEST_FN_RET_QC, 1,
+		    [Noting that make_request_fn() returns blk_qc_t])
 	],[
-		AC_MSG_RESULT(no)
-
 		dnl #
 		dnl # Linux 3.2 API Change
 		dnl # make_request_fn returns void.
@@ -55,7 +66,6 @@ AC_DEFUN([ZFS_AC_KERNEL_MAKE_REQUEST_FN]
 			    [Noting that make_request_fn() returns void])
 		],[
 			AC_MSG_RESULT(no)
-
 			dnl #
 			dnl # Linux 4.4 API Change
 			dnl # make_request_fn returns blk_qc_t.
diff -Npur a/include/linux/blkdev_compat.h b/include/linux/blkdev_compat.h
--- a/include/linux/blkdev_compat.h	2020-01-22 16:49:04.000000000 -0500
+++ b/include/linux/blkdev_compat.h	2020-04-12 15:56:35.244111118 -0400
@@ -669,4 +669,18 @@ blk_generic_end_io_acct(struct request_q
 #endif
 }
 
+static inline struct request_queue *
+blk_generic_alloc_queue(make_request_fn make_request, int node_id)
+{
+#if defined(HAVE_BLK_ALLOC_QUEUE_REQUEST_FN)
+	return (blk_alloc_queue(make_request, node_id));
+#else
+	struct request_queue *q = blk_alloc_queue(GFP_KERNEL);
+	if (q != NULL)
+		blk_queue_make_request(q, make_request);
+
+	return (q);
+#endif
+}
+
 #endif /* _ZFS_BLKDEV_H */
diff -Npur a/META b/META
--- a/META	2020-04-02 06:35:22.000000000 -0400
+++ b/META	2020-04-12 15:56:35.244111118 -0400
@@ -6,5 +6,5 @@ Release:      1ubuntu11
 Release-Tags:  relext
 License:       CDDL
 Author:        OpenZFS on Linux
-Linux-Maximum: 5.4
+Linux-Maximum: 5.7
 Linux-Minimum: 2.6.32
diff -Npur a/module/zfs/zvol.c b/module/zfs/zvol.c
--- a/module/zfs/zvol.c	2020-04-02 06:35:22.000000000 -0400
+++ b/module/zfs/zvol.c	2020-04-12 16:07:56.720930686 -0400
@@ -113,6 +113,13 @@ static struct ida zvol_ida;
 /*
  * The in-core state of each volume.
  */
+struct zvol_state_os {
+	struct gendisk		*zvo_disk;	/* generic disk */
+	struct request_queue	*zvo_queue;	/* request queue */
+	dataset_kstats_t	zvo_kstat;	/* zvol kstats */
+	dev_t			zvo_dev;	/* device id */
+};
+
 struct zvol_state {
 	char			zv_name[MAXNAMELEN];	/* name */
 	uint64_t		zv_volsize;		/* advertised space */
@@ -134,6 +141,7 @@ struct zvol_state {
 	kmutex_t		zv_state_lock;	/* protects zvol_state_t */
 	atomic_t		zv_suspend_ref;	/* refcount for suspend */
 	krwlock_t		zv_suspend_lock;	/* suspend lock */
+	struct zvol_state_os	*zv_zso;	/* private platform state */
 };
 
 typedef enum {
@@ -1686,6 +1694,7 @@ static zvol_state_t *
 zvol_alloc(dev_t dev, const char *name)
 {
 	zvol_state_t *zv;
+	struct zvol_state_os *zso;
 	uint64_t volmode;
 
 	if (dsl_prop_get_integer(name, "volmode", &volmode, NULL) != 0)
@@ -1698,39 +1707,39 @@ zvol_alloc(dev_t dev, const char *name)
 		return (NULL);
 
 	zv = kmem_zalloc(sizeof (zvol_state_t), KM_SLEEP);
+	zso = kmem_zalloc(sizeof (struct zvol_state_os), KM_SLEEP);
+	zv->zv_zso = zso;
 
 	list_link_init(&zv->zv_next);
-
 	mutex_init(&zv->zv_state_lock, NULL, MUTEX_DEFAULT, NULL);
 
-	zv->zv_queue = blk_alloc_queue(GFP_ATOMIC);
-	if (zv->zv_queue == NULL)
+	zso->zvo_queue = blk_generic_alloc_queue(zvol_request, NUMA_NO_NODE);
+	if (zso->zvo_queue == NULL)
 		goto out_kmem;
 
-	blk_queue_make_request(zv->zv_queue, zvol_request);
-	blk_queue_set_write_cache(zv->zv_queue, B_TRUE, B_TRUE);
+	blk_queue_set_write_cache(zso->zvo_queue, B_TRUE, B_TRUE);
 
 	/* Limit read-ahead to a single page to prevent over-prefetching. */
-	blk_queue_set_read_ahead(zv->zv_queue, 1);
+	blk_queue_set_read_ahead(zso->zvo_queue, 1);
 
 	/* Disable write merging in favor of the ZIO pipeline. */
-	blk_queue_flag_set(QUEUE_FLAG_NOMERGES, zv->zv_queue);
+	blk_queue_flag_set(QUEUE_FLAG_NOMERGES, zso->zvo_queue);
 
-	zv->zv_disk = alloc_disk(ZVOL_MINORS);
-	if (zv->zv_disk == NULL)
+	zso->zvo_disk = alloc_disk(ZVOL_MINORS);
+	if (zso->zvo_disk == NULL)
 		goto out_queue;
 
-	zv->zv_queue->queuedata = zv;
-	zv->zv_dev = dev;
+	zso->zvo_queue->queuedata = zv;
+	zso->zvo_dev = dev;
 	zv->zv_open_count = 0;
 	strlcpy(zv->zv_name, name, MAXNAMELEN);
 
 	zfs_rangelock_init(&zv->zv_rangelock, NULL, NULL);
 	rw_init(&zv->zv_suspend_lock, NULL, RW_DEFAULT, NULL);
 
-	zv->zv_disk->major = zvol_major;
+	zso->zvo_disk->major = zvol_major;
 #ifdef HAVE_BLOCK_DEVICE_OPERATIONS_CHECK_EVENTS
-	zv->zv_disk->events = DISK_EVENT_MEDIA_CHANGE;
+	zso->zvo_disk->events = DISK_EVENT_MEDIA_CHANGE;
 #endif
 
 	if (volmode == ZFS_VOLMODE_DEV) {
@@ -1741,26 +1750,27 @@ zvol_alloc(dev_t dev, const char *name)
 		 * and suppresses partition scanning (GENHD_FL_NO_PART_SCAN)
 		 * setting gendisk->flags accordingly.
 		 */
-		zv->zv_disk->minors = 1;
+		zso->zvo_disk->minors = 1;
 #if defined(GENHD_FL_EXT_DEVT)
-		zv->zv_disk->flags &= ~GENHD_FL_EXT_DEVT;
+		zso->zvo_disk->flags &= ~GENHD_FL_EXT_DEVT;
 #endif
 #if defined(GENHD_FL_NO_PART_SCAN)
-		zv->zv_disk->flags |= GENHD_FL_NO_PART_SCAN;
+		zso->zvo_disk->flags |= GENHD_FL_NO_PART_SCAN;
 #endif
 	}
-	zv->zv_disk->first_minor = (dev & MINORMASK);
-	zv->zv_disk->fops = &zvol_ops;
-	zv->zv_disk->private_data = zv;
-	zv->zv_disk->queue = zv->zv_queue;
-	snprintf(zv->zv_disk->disk_name, DISK_NAME_LEN, "%s%d",
+	zso->zvo_disk->first_minor = (dev & MINORMASK);
+	zso->zvo_disk->fops = &zvol_ops;
+	zso->zvo_disk->private_data = zv;
+	zso->zvo_disk->queue = zso->zvo_queue;
+	snprintf(zso->zvo_disk->disk_name, DISK_NAME_LEN, "%s%d",
 	    ZVOL_DEV_NAME, (dev & MINORMASK));
 
 	return (zv);
 
 out_queue:
-	blk_cleanup_queue(zv->zv_queue);
+	blk_cleanup_queue(zso->zvo_queue);
 out_kmem:
+	kmem_free(zso, sizeof (struct zvol_state_os));
 	kmem_free(zv, sizeof (zvol_state_t));
 
 	return (NULL);
